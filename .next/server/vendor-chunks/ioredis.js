"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ioredis";
exports.ids = ["vendor-chunks/ioredis"];
exports.modules = {

/***/ "(rsc)/./node_modules/ioredis/built/Command.js":
/*!***********************************************!*\
  !*** ./node_modules/ioredis/built/Command.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */\nclass Command {\n    /**\n     * Creates an instance of Command.\n     * @param name Command name\n     * @param args An array of command arguments\n     * @param options\n     * @param callback The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     */\n    constructor(name, args = [], options = {}, callback) {\n        this.name = name;\n        this.inTransaction = false;\n        this.isResolved = false;\n        this.transformed = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = args.flat();\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            // @ts-expect-error\n            const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n            // @ts-expect-error\n            let keyPrefixBuffer = isBufferKeyPrefix\n                ? options.keyPrefix\n                : null;\n            this._iterateKeys((key) => {\n                if (key instanceof Buffer) {\n                    if (keyPrefixBuffer === null) {\n                        keyPrefixBuffer = Buffer.from(options.keyPrefix);\n                    }\n                    return Buffer.concat([keyPrefixBuffer, key]);\n                }\n                else if (isBufferKeyPrefix) {\n                    // @ts-expect-error\n                    return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);\n                }\n                return options.keyPrefix + key;\n            });\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    /**\n     * Check whether the command has the flag\n     */\n    static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach((commandName) => {\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Convert command to writable buffer or string\n     */\n    toWritable(_socket) {\n        let result;\n        const commandStr = \"*\" +\n            (this.args.length + 1) +\n            \"\\r\\n$\" +\n            Buffer.byteLength(this.name) +\n            \"\\r\\n\" +\n            this.name +\n            \"\\r\\n\";\n        if (this.bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    }\n                    else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                }\n                else {\n                    buffers.push(\"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        }\n        else {\n            result = commandStr;\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                result +=\n                    \"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for (let i = 0; i < this.args.length; ++i) {\n            const arg = this.args[i];\n            if (typeof arg === \"string\") {\n                // buffers and strings don't need any transformation\n            }\n            else if (arg instanceof Buffer) {\n                this.bufferMode = true;\n            }\n            else {\n                this.args[i] = (0, utils_1.toArg)(arg);\n            }\n        }\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     */\n    transformReply(result) {\n        if (this.replyEncoding) {\n            result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n    /**\n     * Set the wait time before terminating the attempt to execute a command\n     * and generating an error.\n     */\n    setTimeout(ms) {\n        if (!this._commandTimeoutTimer) {\n            this._commandTimeoutTimer = setTimeout(() => {\n                if (!this.isResolved) {\n                    this.reject(new Error(\"Command timed out\"));\n                }\n            }, ms);\n        }\n    }\n    initPromise() {\n        const promise = new Promise((resolve, reject) => {\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = (err) => {\n                    reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n                };\n            }\n            else {\n                this.reject = reject;\n            }\n        });\n        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     */\n    _iterateKeys(transform = (key) => key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if ((0, commands_1.exists)(this.name)) {\n                // @ts-expect-error\n                const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);\n                for (const index of keyIndexes) {\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     */\n    _convertValue(resolve) {\n        return (value) => {\n            try {\n                const existingTimer = this._commandTimeoutTimer;\n                if (existingTimer) {\n                    clearTimeout(existingTimer);\n                    delete this._commandTimeoutTimer;\n                }\n                resolve(this.transformReply(value));\n                this.isResolved = true;\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n}\nexports[\"default\"] = Command;\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ssubscribe\",\n        \"sunsubscribe\",\n        \"ping\",\n        \"quit\",\n    ],\n    VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n    ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"ssubscribe\"],\n    EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\", \"sunsubscribe\"],\n    WILL_DISCONNECT: [\"quit\"],\n};\nCommand._transformer = {\n    argument: {},\n    reply: {},\n};\nconst msetArgumentTransformer = function (args) {\n    if (args.length === 1) {\n        if (args[0] instanceof Map) {\n            return (0, utils_1.convertMapToArray)(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return (0, utils_1.convertObjectToArray)(args[0]);\n        }\n    }\n    return args;\n};\nconst hsetArgumentTransformer = function (args) {\n    if (args.length === 2) {\n        if (args[1] instanceof Map) {\n            return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n    if (Array.isArray(result)) {\n        const obj = {};\n        for (let i = 0; i < result.length; i += 2) {\n            const key = result[i];\n            const value = result[i + 1];\n            if (key in obj) {\n                // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n                // https://github.com/luin/ioredis/issues/1267\n                Object.defineProperty(obj, key, {\n                    value,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true,\n                });\n            }\n            else {\n                obj[key] = value;\n            }\n        }\n        return obj;\n    }\n    return result;\n});\nclass MixedBuffers {\n    constructor() {\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items) {\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item)\n                ? item.copy(result, offset)\n                : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9Db21tYW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLGdGQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDaEQsK0JBQStCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvQ29tbWFuZC5qcz80NDkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENvbW1hbmQgaW5zdGFuY2VcbiAqXG4gKiBJdCdzIHJhcmUgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBDb21tYW5kIGluc3RhbmNlIHlvdXJzZWxmLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgaW5mb0NvbW1hbmQgPSBuZXcgQ29tbWFuZCgnaW5mbycsIG51bGwsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0KTtcbiAqIH0pO1xuICpcbiAqIHJlZGlzLnNlbmRDb21tYW5kKGluZm9Db21tYW5kKTtcbiAqXG4gKiAvLyBXaGVuIG5vIGNhbGxiYWNrIHByb3ZpZGVkLCBDb21tYW5kIGluc3RhbmNlIHdpbGwgaGF2ZSBhIGBwcm9taXNlYCBwcm9wZXJ0eSxcbiAqIC8vIHdoaWNoIHdpbGwgcmVzb2x2ZS9yZWplY3Qgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBjb21tYW5kLlxuICogdmFyIGdldENvbW1hbmQgPSBuZXcgQ29tbWFuZCgnZ2V0JywgWydmb28nXSk7XG4gKiBnZXRDb21tYW5kLnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKCdyZXN1bHQnLCByZXN1bHQpO1xuICogfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tbWFuZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb21tYW5kLlxuICAgICAqIEBwYXJhbSBuYW1lIENvbW1hbmQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFuIGFycmF5IG9mIGNvbW1hbmQgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG4gICAgICogSWYgb21pdCwgdGhlIHJlc3BvbnNlIHdpbGwgYmUgaGFuZGxlZCB2aWEgUHJvbWlzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MgPSBbXSwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXBseUVuY29kaW5nID0gb3B0aW9ucy5yZXBseUVuY29kaW5nO1xuICAgICAgICB0aGlzLmVycm9yU3RhY2sgPSBvcHRpb25zLmVycm9yU3RhY2s7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3MuZmxhdCgpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5UHJlZml4KSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjb25zdCBpc0J1ZmZlcktleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IGluc3RhbmNlb2YgQnVmZmVyO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGtleVByZWZpeEJ1ZmZlciA9IGlzQnVmZmVyS2V5UHJlZml4XG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmtleVByZWZpeFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGVLZXlzKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQcmVmaXhCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVByZWZpeEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMua2V5UHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChba2V5UHJlZml4QnVmZmVyLCBrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCdWZmZXJLZXlQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbb3B0aW9ucy5rZXlQcmVmaXgsIEJ1ZmZlci5mcm9tKFN0cmluZyhrZXkpKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlQcmVmaXggKyBrZXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjb21tYW5kIGhhcyB0aGUgZmxhZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja0ZsYWcoZmxhZ05hbWUsIGNvbW1hbmROYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RmxhZ01hcCgpW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV07XG4gICAgfVxuICAgIHN0YXRpYyBzZXRBcmd1bWVudFRyYW5zZm9ybWVyKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZXIuYXJndW1lbnRbbmFtZV0gPSBmdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UmVwbHlUcmFuc2Zvcm1lcihuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVyLnJlcGx5W25hbWVdID0gZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGdldEZsYWdNYXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGFnTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdNYXAgPSBPYmplY3Qua2V5cyhDb21tYW5kLkZMQUdTKS5yZWR1Y2UoKG1hcCwgZmxhZ05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBtYXBbZmxhZ05hbWVdID0ge307XG4gICAgICAgICAgICAgICAgQ29tbWFuZC5GTEFHU1tmbGFnTmFtZV0uZm9yRWFjaCgoY29tbWFuZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ01hcDtcbiAgICB9XG4gICAgZ2V0U2xvdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNsb3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5cygpWzBdO1xuICAgICAgICAgICAgdGhpcy5zbG90ID0ga2V5ID09IG51bGwgPyBudWxsIDogY2FsY3VsYXRlU2xvdChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3Q7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRlS2V5cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGNvbW1hbmQgdG8gd3JpdGFibGUgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAqL1xuICAgIHRvV3JpdGFibGUoX3NvY2tldCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBjb21tYW5kU3RyID0gXCIqXCIgK1xuICAgICAgICAgICAgKHRoaXMuYXJncy5sZW5ndGggKyAxKSArXG4gICAgICAgICAgICBcIlxcclxcbiRcIiArXG4gICAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aCh0aGlzLm5hbWUpICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlck1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBuZXcgTWl4ZWRCdWZmZXJzKCk7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY29tbWFuZFN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkMFxcclxcblxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChcIiRcIiArIGFyZy5sZW5ndGggKyBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoYXJnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXJzLnRvQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kU3RyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgICAgICAgIFwiJFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGFyZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdHJpbmdpZnlBcmd1bWVudHMoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlcnMgYW5kIHN0cmluZ3MgZG9uJ3QgbmVlZCBhbnkgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaV0gPSAoMCwgdXRpbHNfMS50b0FyZykoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGJ1ZmZlci9idWZmZXJbXSB0byBzdHJpbmcvc3RyaW5nW10sXG4gICAgICogYW5kIGFwcGx5IHJlcGx5IHRyYW5zZm9ybWVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybVJlcGx5KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5yZXBseUVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoMCwgdXRpbHNfMS5jb252ZXJ0QnVmZmVyVG9TdHJpbmcpKHJlc3VsdCwgdGhpcy5yZXBseUVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IENvbW1hbmQuX3RyYW5zZm9ybWVyLnJlcGx5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdhaXQgdGltZSBiZWZvcmUgdGVybWluYXRpbmcgdGhlIGF0dGVtcHQgdG8gZXhlY3V0ZSBhIGNvbW1hbmRcbiAgICAgKiBhbmQgZ2VuZXJhdGluZyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzZXRUaW1lb3V0KG1zKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcihcIkNvbW1hbmQgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFByb21pc2UoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IENvbW1hbmQuX3RyYW5zZm9ybWVyLmFyZ3VtZW50W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IHRyYW5zZm9ybWVyKHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSB0aGlzLl9jb252ZXJ0VmFsdWUocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgdXRpbHNfMS5vcHRpbWl6ZUVycm9yU3RhY2spKGVyciwgdGhpcy5lcnJvclN0YWNrLnN0YWNrLCBfX2Rpcm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UgPSAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLCB0aGlzLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjb21tYW5kIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25zaWRlcmVkIGtleXMuXG4gICAgICovXG4gICAgX2l0ZXJhdGVLZXlzKHRyYW5zZm9ybSA9IChrZXkpID0+IGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgICAgICBpZiAoKDAsIGNvbW1hbmRzXzEuZXhpc3RzKSh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZGV4ZXMgPSAoMCwgY29tbWFuZHNfMS5nZXRLZXlJbmRleGVzKSh0aGlzLm5hbWUsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBrZXlJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm0odGhpcy5hcmdzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKHRoaXMuYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSB2YWx1ZSBmcm9tIGJ1ZmZlciB0byB0aGUgdGFyZ2V0IGVuY29kaW5nLlxuICAgICAqL1xuICAgIF9jb252ZXJ0VmFsdWUocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLl9jb21tYW5kVGltZW91dFRpbWVyO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1RpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1hbmRUaW1lb3V0VGltZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50cmFuc2Zvcm1SZXBseSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWFuZDtcbkNvbW1hbmQuRkxBR1MgPSB7XG4gICAgVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFOiBbXG4gICAgICAgIFwic3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHN1YnNjcmliZVwiLFxuICAgICAgICBcInVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwic3N1YnNjcmliZVwiLFxuICAgICAgICBcInN1bnN1YnNjcmliZVwiLFxuICAgICAgICBcInBpbmdcIixcbiAgICAgICAgXCJxdWl0XCIsXG4gICAgXSxcbiAgICBWQUxJRF9JTl9NT05JVE9SX01PREU6IFtcIm1vbml0b3JcIiwgXCJhdXRoXCJdLFxuICAgIEVOVEVSX1NVQlNDUklCRVJfTU9ERTogW1wic3Vic2NyaWJlXCIsIFwicHN1YnNjcmliZVwiLCBcInNzdWJzY3JpYmVcIl0sXG4gICAgRVhJVF9TVUJTQ1JJQkVSX01PREU6IFtcInVuc3Vic2NyaWJlXCIsIFwicHVuc3Vic2NyaWJlXCIsIFwic3Vuc3Vic2NyaWJlXCJdLFxuICAgIFdJTExfRElTQ09OTkVDVDogW1wicXVpdFwiXSxcbn07XG5Db21tYW5kLl90cmFuc2Zvcm1lciA9IHtcbiAgICBhcmd1bWVudDoge30sXG4gICAgcmVwbHk6IHt9LFxufTtcbmNvbnN0IG1zZXRBcmd1bWVudFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb252ZXJ0TWFwVG9BcnJheSkoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiICYmIGFyZ3NbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb252ZXJ0T2JqZWN0VG9BcnJheSkoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59O1xuY29uc3QgaHNldEFyZ3VtZW50VHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoYXJnc1sxXSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIFthcmdzWzBdXS5jb25jYXQoKDAsIHV0aWxzXzEuY29udmVydE1hcFRvQXJyYXkpKGFyZ3NbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09IFwib2JqZWN0XCIgJiYgYXJnc1sxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFthcmdzWzBdXS5jb25jYXQoKDAsIHV0aWxzXzEuY29udmVydE9iamVjdFRvQXJyYXkpKGFyZ3NbMV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn07XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJtc2V0XCIsIG1zZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcIm1zZXRueFwiLCBtc2V0QXJndW1lbnRUcmFuc2Zvcm1lcik7XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJoc2V0XCIsIGhzZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcImhtc2V0XCIsIGhzZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0UmVwbHlUcmFuc2Zvcm1lcihcImhnZXRhbGxcIiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXN1bHRbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpICsgMV07XG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIHRydXRoeSBpZiB0aGUgcHJvcGVydHkgaXMgc3BlY2lhbCBzb21laG93LCBsaWtlICdfX3Byb3RvX18nIG9yICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbHVpbi9pb3JlZGlzL2lzc3Vlcy8xMjY3XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG5jbGFzcyBNaXhlZEJ1ZmZlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgcHVzaCh4KSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHgpO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goeCk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5sZW5ndGgpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGl0ZW0pO1xuICAgICAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBpdGVtLmNvcHkocmVzdWx0LCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgOiByZXN1bHQud3JpdGUoaXRlbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/DataHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/DataHandler.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst RedisParser = __webpack_require__(/*! redis-parser */ \"(rsc)/./node_modules/redis-parser/index.js\");\nconst SubscriptionSet_1 = __webpack_require__(/*! ./SubscriptionSet */ \"(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\");\nconst debug = (0, utils_1.Debug)(\"dataHandler\");\nclass DataHandler {\n    constructor(redis, parserOptions) {\n        this.redis = redis;\n        const parser = new RedisParser({\n            stringNumbers: parserOptions.stringNumbers,\n            returnBuffers: true,\n            returnError: (err) => {\n                this.returnError(err);\n            },\n            returnFatalError: (err) => {\n                this.returnFatalError(err);\n            },\n            returnReply: (reply) => {\n                this.returnReply(reply);\n            },\n        });\n        redis.stream.on(\"data\", (data) => {\n            parser.execute(data);\n        });\n    }\n    returnFatalError(err) {\n        err.message += \". Please report this.\";\n        this.redis.recoverFromFatalError(err, err, { offlineQueue: false });\n    }\n    returnError(err) {\n        const item = this.shiftCommand(err);\n        if (!item) {\n            return;\n        }\n        err.command = {\n            name: item.command.name,\n            args: item.command.args,\n        };\n        this.redis.handleReconnection(err, item);\n    }\n    returnReply(reply) {\n        if (this.handleMonitorReply(reply)) {\n            return;\n        }\n        if (this.handleSubscriberReply(reply)) {\n            return;\n        }\n        const item = this.shiftCommand(reply);\n        if (!item) {\n            return;\n        }\n        if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n            this.redis.condition.subscriber = new SubscriptionSet_1.default();\n            this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n            if (!fillSubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else if (Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n            if (!fillUnsubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else {\n            item.command.resolve(reply);\n        }\n    }\n    handleSubscriberReply(reply) {\n        if (!this.redis.condition.subscriber) {\n            return false;\n        }\n        const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n        debug('receive reply \"%s\" in subscriber mode', replyType);\n        switch (replyType) {\n            case \"message\":\n                if (this.redis.listeners(\"message\").length > 0) {\n                    // Check if there're listeners to avoid unnecessary `toString()`.\n                    this.redis.emit(\"message\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n                break;\n            case \"pmessage\": {\n                const pattern = reply[1].toString();\n                if (this.redis.listeners(\"pmessage\").length > 0) {\n                    this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n                }\n                this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n                break;\n            }\n            case \"smessage\": {\n                if (this.redis.listeners(\"smessage\").length > 0) {\n                    this.redis.emit(\"smessage\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"smessageBuffer\", reply[1], reply[2]);\n                break;\n            }\n            case \"ssubscribe\":\n            case \"subscribe\":\n            case \"psubscribe\": {\n                const channel = reply[1].toString();\n                this.redis.condition.subscriber.add(replyType, channel);\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillSubCommand(item.command, reply[2])) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            case \"sunsubscribe\":\n            case \"unsubscribe\":\n            case \"punsubscribe\": {\n                const channel = reply[1] ? reply[1].toString() : null;\n                if (channel) {\n                    this.redis.condition.subscriber.del(replyType, channel);\n                }\n                const count = reply[2];\n                if (Number(count) === 0) {\n                    this.redis.condition.subscriber = false;\n                }\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillUnsubCommand(item.command, count)) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            default: {\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                item.command.resolve(reply);\n            }\n        }\n        return true;\n    }\n    handleMonitorReply(reply) {\n        if (this.redis.status !== \"monitoring\") {\n            return false;\n        }\n        const replyStr = reply.toString();\n        if (replyStr === \"OK\") {\n            // Valid commands in the monitoring mode are AUTH and MONITOR,\n            // both of which always reply with 'OK'.\n            // So if we got an 'OK', we can make certain that\n            // the reply is made to AUTH & MONITOR.\n            return false;\n        }\n        // Since commands sent in the monitoring mode will trigger an exception,\n        // any replies we received in the monitoring mode should consider to be\n        // realtime monitor data instead of result of commands.\n        const len = replyStr.indexOf(\" \");\n        const timestamp = replyStr.slice(0, len);\n        const argIndex = replyStr.indexOf('\"');\n        const args = replyStr\n            .slice(argIndex + 1, -1)\n            .split('\" \"')\n            .map((elem) => elem.replace(/\\\\\"/g, '\"'));\n        const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(\" \");\n        this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n        return true;\n    }\n    shiftCommand(reply) {\n        const item = this.redis.commandQueue.shift();\n        if (!item) {\n            const message = \"Command queue state error. If you can reproduce this, please report it.\";\n            const error = new Error(message +\n                (reply instanceof Error\n                    ? ` Last error: ${reply.message}`\n                    : ` Last reply: ${reply.toString()}`));\n            this.redis.emit(\"error\", error);\n            return null;\n        }\n        return item;\n    }\n}\nexports[\"default\"] = DataHandler;\nconst remainingRepliesMap = new WeakMap();\nfunction fillSubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command)\n        ? remainingRepliesMap.get(command)\n        : command.args.length;\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        remainingRepliesMap.delete(command);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\nfunction fillUnsubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command)\n        ? remainingRepliesMap.get(command)\n        : command.args.length;\n    if (remainingReplies === 0) {\n        if (Number(count) === 0) {\n            remainingRepliesMap.delete(command);\n            command.resolve(count);\n            return true;\n        }\n        return false;\n    }\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9EYXRhSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQywwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L0RhdGFIYW5kbGVyLmpzPzJlMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgUmVkaXNQYXJzZXIgPSByZXF1aXJlKFwicmVkaXMtcGFyc2VyXCIpO1xuY29uc3QgU3Vic2NyaXB0aW9uU2V0XzEgPSByZXF1aXJlKFwiLi9TdWJzY3JpcHRpb25TZXRcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcImRhdGFIYW5kbGVyXCIpO1xuY2xhc3MgRGF0YUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlZGlzLCBwYXJzZXJPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVkaXMgPSByZWRpcztcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFJlZGlzUGFyc2VyKHtcbiAgICAgICAgICAgIHN0cmluZ051bWJlcnM6IHBhcnNlck9wdGlvbnMuc3RyaW5nTnVtYmVycyxcbiAgICAgICAgICAgIHJldHVybkJ1ZmZlcnM6IHRydWUsXG4gICAgICAgICAgICByZXR1cm5FcnJvcjogKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm5GYXRhbEVycm9yOiAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5GYXRhbEVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuUmVwbHk6IChyZXBseSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuUmVwbHkocmVwbHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlZGlzLnN0cmVhbS5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5leGVjdXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuRmF0YWxFcnJvcihlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgKz0gXCIuIFBsZWFzZSByZXBvcnQgdGhpcy5cIjtcbiAgICAgICAgdGhpcy5yZWRpcy5yZWNvdmVyRnJvbUZhdGFsRXJyb3IoZXJyLCBlcnIsIHsgb2ZmbGluZVF1ZXVlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNoaWZ0Q29tbWFuZChlcnIpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0uY29tbWFuZC5uYW1lLFxuICAgICAgICAgICAgYXJnczogaXRlbS5jb21tYW5kLmFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVkaXMuaGFuZGxlUmVjb25uZWN0aW9uKGVyciwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVyblJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZU1vbml0b3JSZXBseShyZXBseSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYW5kbGVTdWJzY3JpYmVyUmVwbHkocmVwbHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVOVEVSX1NVQlNDUklCRVJfTU9ERVwiLCBpdGVtLmNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaXB0aW9uU2V0XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQoaXRlbS5jb21tYW5kLm5hbWUsIHJlcGx5WzFdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKCFmaWxsU3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIHJlcGx5WzJdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29tbWFuZFF1ZXVlLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiRVhJVF9TVUJTQ1JJQkVSX01PREVcIiwgaXRlbS5jb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIWZpbGxVbnN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZXJSZXBseShyZXBseSkge1xuICAgICAgICBpZiAoIXRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVR5cGUgPSBBcnJheS5pc0FycmF5KHJlcGx5KSA/IHJlcGx5WzBdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZSByZXBseSBcIiVzXCIgaW4gc3Vic2NyaWJlciBtb2RlJywgcmVwbHlUeXBlKTtcbiAgICAgICAgc3dpdGNoIChyZXBseVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwibWVzc2FnZVwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3JlIGxpc3RlbmVycyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBgdG9TdHJpbmcoKWAuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VcIiwgcmVwbHlbMV0udG9TdHJpbmcoKSwgcmVwbHlbMl0gPyByZXBseVsyXS50b1N0cmluZygpIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwicG1lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJwbWVzc2FnZVwiLCBwYXR0ZXJuLCByZXBseVsyXS50b1N0cmluZygpLCByZXBseVszXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwicG1lc3NhZ2VCdWZmZXJcIiwgcGF0dGVybiwgcmVwbHlbMl0sIHJlcGx5WzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwic21lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJzbWVzc2FnZVwiLCByZXBseVsxXS50b1N0cmluZygpLCByZXBseVsyXSA/IHJlcGx5WzJdLnRvU3RyaW5nKCkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwic21lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQocmVwbHlUeXBlLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb21tYW5kUXVldWUudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwidW5zdWJzY3JpYmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwdW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSByZXBseVsxXSA/IHJlcGx5WzFdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIuZGVsKHJlcGx5VHlwZSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gcmVwbHlbMl07XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihjb3VudCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFVuc3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIGNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlTW9uaXRvclJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyAhPT0gXCJtb25pdG9yaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVN0ciA9IHJlcGx5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXBseVN0ciA9PT0gXCJPS1wiKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBjb21tYW5kcyBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIGFyZSBBVVRIIGFuZCBNT05JVE9SLFxuICAgICAgICAgICAgLy8gYm90aCBvZiB3aGljaCBhbHdheXMgcmVwbHkgd2l0aCAnT0snLlxuICAgICAgICAgICAgLy8gU28gaWYgd2UgZ290IGFuICdPSycsIHdlIGNhbiBtYWtlIGNlcnRhaW4gdGhhdFxuICAgICAgICAgICAgLy8gdGhlIHJlcGx5IGlzIG1hZGUgdG8gQVVUSCAmIE1PTklUT1IuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgY29tbWFuZHMgc2VudCBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIHdpbGwgdHJpZ2dlciBhbiBleGNlcHRpb24sXG4gICAgICAgIC8vIGFueSByZXBsaWVzIHdlIHJlY2VpdmVkIGluIHRoZSBtb25pdG9yaW5nIG1vZGUgc2hvdWxkIGNvbnNpZGVyIHRvIGJlXG4gICAgICAgIC8vIHJlYWx0aW1lIG1vbml0b3IgZGF0YSBpbnN0ZWFkIG9mIHJlc3VsdCBvZiBjb21tYW5kcy5cbiAgICAgICAgY29uc3QgbGVuID0gcmVwbHlTdHIuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHJlcGx5U3RyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIGNvbnN0IGFyZ0luZGV4ID0gcmVwbHlTdHIuaW5kZXhPZignXCInKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcGx5U3RyXG4gICAgICAgICAgICAuc2xpY2UoYXJnSW5kZXggKyAxLCAtMSlcbiAgICAgICAgICAgIC5zcGxpdCgnXCIgXCInKVxuICAgICAgICAgICAgLm1hcCgoZWxlbSkgPT4gZWxlbS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykpO1xuICAgICAgICBjb25zdCBkYkFuZFNvdXJjZSA9IHJlcGx5U3RyLnNsaWNlKGxlbiArIDIsIGFyZ0luZGV4IC0gMikuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtb25pdG9yXCIsIHRpbWVzdGFtcCwgYXJncywgZGJBbmRTb3VyY2VbMV0sIGRiQW5kU291cmNlWzBdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNoaWZ0Q29tbWFuZChyZXBseSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5yZWRpcy5jb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJDb21tYW5kIHF1ZXVlIHN0YXRlIGVycm9yLiBJZiB5b3UgY2FuIHJlcHJvZHVjZSB0aGlzLCBwbGVhc2UgcmVwb3J0IGl0LlwiO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSArXG4gICAgICAgICAgICAgICAgKHJlcGx5IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBgIExhc3QgZXJyb3I6ICR7cmVwbHkubWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgICAgIDogYCBMYXN0IHJlcGx5OiAke3JlcGx5LnRvU3RyaW5nKCl9YCkpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUhhbmRsZXI7XG5jb25zdCByZW1haW5pbmdSZXBsaWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGZpbGxTdWJDb21tYW5kKGNvbW1hbmQsIGNvdW50KSB7XG4gICAgbGV0IHJlbWFpbmluZ1JlcGxpZXMgPSByZW1haW5pbmdSZXBsaWVzTWFwLmhhcyhjb21tYW5kKVxuICAgICAgICA/IHJlbWFpbmluZ1JlcGxpZXNNYXAuZ2V0KGNvbW1hbmQpXG4gICAgICAgIDogY29tbWFuZC5hcmdzLmxlbmd0aDtcbiAgICByZW1haW5pbmdSZXBsaWVzIC09IDE7XG4gICAgaWYgKHJlbWFpbmluZ1JlcGxpZXMgPD0gMCkge1xuICAgICAgICBjb21tYW5kLnJlc29sdmUoY291bnQpO1xuICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXNNYXAuc2V0KGNvbW1hbmQsIHJlbWFpbmluZ1JlcGxpZXMpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbGxVbnN1YkNvbW1hbmQoY29tbWFuZCwgY291bnQpIHtcbiAgICBsZXQgcmVtYWluaW5nUmVwbGllcyA9IHJlbWFpbmluZ1JlcGxpZXNNYXAuaGFzKGNvbW1hbmQpXG4gICAgICAgID8gcmVtYWluaW5nUmVwbGllc01hcC5nZXQoY29tbWFuZClcbiAgICAgICAgOiBjb21tYW5kLmFyZ3MubGVuZ3RoO1xuICAgIGlmIChyZW1haW5pbmdSZXBsaWVzID09PSAwKSB7XG4gICAgICAgIGlmIChOdW1iZXIoY291bnQpID09PSAwKSB7XG4gICAgICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXMgLT0gMTtcbiAgICBpZiAocmVtYWluaW5nUmVwbGllcyA8PSAwKSB7XG4gICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1haW5pbmdSZXBsaWVzTWFwLnNldChjb21tYW5kLCByZW1haW5pbmdSZXBsaWVzKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/DataHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Pipeline.js":
/*!************************************************!*\
  !*** ./node_modules/ioredis/built/Pipeline.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/\nfunction generateMultiWithNodes(redis, keys) {\n    const slot = calculateSlot(keys[0]);\n    const target = redis._groupsBySlot[slot];\n    for (let i = 1; i < keys.length; i++) {\n        if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n            return -1;\n        }\n    }\n    return slot;\n}\nclass Pipeline extends Commander_1.default {\n    constructor(redis) {\n        super();\n        this.redis = redis;\n        this.isPipeline = true;\n        this.replyPending = 0;\n        this._queue = [];\n        this._result = [];\n        this._transactions = 0;\n        this._shaToScript = {};\n        this.isCluster =\n            this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n        this.options = redis.options;\n        Object.keys(redis.scriptsSet).forEach((name) => {\n            const script = redis.scriptsSet[name];\n            this._shaToScript[script.sha] = script;\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        redis.addedBuiltinSet.forEach((name) => {\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        const _this = this;\n        Object.defineProperty(this, \"length\", {\n            get: function () {\n                return _this._queue.length;\n            },\n        });\n    }\n    fillResult(value, position) {\n        if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n            const execLength = value[1].length;\n            for (let i = 0; i < execLength; i++) {\n                if (value[1][i] instanceof Error) {\n                    continue;\n                }\n                const cmd = this._queue[position - (execLength - i)];\n                try {\n                    value[1][i] = cmd.transformReply(value[1][i]);\n                }\n                catch (err) {\n                    value[1][i] = err;\n                }\n            }\n        }\n        this._result[position] = value;\n        if (--this.replyPending) {\n            return;\n        }\n        if (this.isCluster) {\n            let retriable = true;\n            let commonError;\n            for (let i = 0; i < this._result.length; ++i) {\n                const error = this._result[i][0];\n                const command = this._queue[i];\n                if (error) {\n                    if (command.name === \"exec\" &&\n                        error.message ===\n                            \"EXECABORT Transaction discarded because of previous errors.\") {\n                        continue;\n                    }\n                    if (!commonError) {\n                        commonError = {\n                            name: error.name,\n                            message: error.message,\n                        };\n                    }\n                    else if (commonError.name !== error.name ||\n                        commonError.message !== error.message) {\n                        retriable = false;\n                        break;\n                    }\n                }\n                else if (!command.inTransaction) {\n                    const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n                    if (!isReadOnly) {\n                        retriable = false;\n                        break;\n                    }\n                }\n            }\n            if (commonError && retriable) {\n                const _this = this;\n                const errv = commonError.message.split(\" \");\n                const queue = this._queue;\n                let inTransaction = false;\n                this._queue = [];\n                for (let i = 0; i < queue.length; ++i) {\n                    if (errv[0] === \"ASK\" &&\n                        !inTransaction &&\n                        queue[i].name !== \"asking\" &&\n                        (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n                        const asking = new Command_1.default(\"asking\");\n                        asking.ignore = true;\n                        this.sendCommand(asking);\n                    }\n                    queue[i].initPromise();\n                    this.sendCommand(queue[i]);\n                    inTransaction = queue[i].inTransaction;\n                }\n                let matched = true;\n                if (typeof this.leftRedirections === \"undefined\") {\n                    this.leftRedirections = {};\n                }\n                const exec = function () {\n                    _this.exec();\n                };\n                const cluster = this.redis;\n                cluster.handleError(commonError, this.leftRedirections, {\n                    moved: function (_slot, key) {\n                        _this.preferKey = key;\n                        cluster.slots[errv[1]] = [key];\n                        cluster._groupsBySlot[errv[1]] =\n                            cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n                        cluster.refreshSlotsCache();\n                        _this.exec();\n                    },\n                    ask: function (_slot, key) {\n                        _this.preferKey = key;\n                        _this.exec();\n                    },\n                    tryagain: exec,\n                    clusterDown: exec,\n                    connectionClosed: exec,\n                    maxRedirections: () => {\n                        matched = false;\n                    },\n                    defaults: () => {\n                        matched = false;\n                    },\n                });\n                if (matched) {\n                    return;\n                }\n            }\n        }\n        let ignoredCount = 0;\n        for (let i = 0; i < this._queue.length - ignoredCount; ++i) {\n            if (this._queue[i + ignoredCount].ignore) {\n                ignoredCount += 1;\n            }\n            this._result[i] = this._result[i + ignoredCount];\n        }\n        this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n    }\n    sendCommand(command) {\n        if (this._transactions > 0) {\n            command.inTransaction = true;\n        }\n        const position = this._queue.length;\n        command.pipelineIndex = position;\n        command.promise\n            .then((result) => {\n            this.fillResult([null, result], position);\n        })\n            .catch((error) => {\n            this.fillResult([error], position);\n        });\n        this._queue.push(command);\n        return this;\n    }\n    addBatch(commands) {\n        let command, commandName, args;\n        for (let i = 0; i < commands.length; ++i) {\n            command = commands[i];\n            commandName = command[0];\n            args = command.slice(1);\n            this[commandName].apply(this, args);\n        }\n        return this;\n    }\n}\nexports[\"default\"] = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function () {\n    this._transactions += 1;\n    return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function () {\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n    }\n    return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function (callback) {\n    // Wait for the cluster to be connected, since we need nodes information before continuing\n    if (this.isCluster && !this.redis.slots.length) {\n        if (this.redis.status === \"wait\")\n            this.redis.connect().catch(utils_1.noop);\n        if (callback && !this.nodeifiedPromise) {\n            this.nodeifiedPromise = true;\n            (0, standard_as_callback_1.default)(this.promise, callback);\n        }\n        this.redis.delayUntilReady((err) => {\n            if (err) {\n                this.reject(err);\n                return;\n            }\n            this.exec(callback);\n        });\n        return this.promise;\n    }\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n        return execBuffer.apply(this, arguments);\n    }\n    if (!this.nodeifiedPromise) {\n        this.nodeifiedPromise = true;\n        (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    if (!this._queue.length) {\n        this.resolve([]);\n    }\n    let pipelineSlot;\n    if (this.isCluster) {\n        // List of the first key for each command\n        const sampleKeys = [];\n        for (let i = 0; i < this._queue.length; i++) {\n            const keys = this._queue[i].getKeys();\n            if (keys.length) {\n                sampleKeys.push(keys[0]);\n            }\n            // For each command, check that the keys belong to the same slot\n            if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n                this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n                return this.promise;\n            }\n        }\n        if (sampleKeys.length) {\n            pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n            if (pipelineSlot < 0) {\n                this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n                return this.promise;\n            }\n        }\n        else {\n            // Send the pipeline to a random node\n            pipelineSlot = (Math.random() * 16384) | 0;\n        }\n    }\n    const _this = this;\n    execPipeline();\n    return this.promise;\n    function execPipeline() {\n        let writePending = (_this.replyPending = _this._queue.length);\n        let node;\n        if (_this.isCluster) {\n            node = {\n                slot: pipelineSlot,\n                redis: _this.redis.connectionPool.nodes.all[_this.preferKey],\n            };\n        }\n        let data = \"\";\n        let buffers;\n        const stream = {\n            isPipeline: true,\n            destination: _this.isCluster ? node : { redis: _this.redis },\n            write(writable) {\n                if (typeof writable !== \"string\") {\n                    if (!buffers) {\n                        buffers = [];\n                    }\n                    if (data) {\n                        buffers.push(Buffer.from(data, \"utf8\"));\n                        data = \"\";\n                    }\n                    buffers.push(writable);\n                }\n                else {\n                    data += writable;\n                }\n                if (!--writePending) {\n                    if (buffers) {\n                        if (data) {\n                            buffers.push(Buffer.from(data, \"utf8\"));\n                        }\n                        stream.destination.redis.stream.write(Buffer.concat(buffers));\n                    }\n                    else {\n                        stream.destination.redis.stream.write(data);\n                    }\n                    // Reset writePending for resending\n                    writePending = _this._queue.length;\n                    data = \"\";\n                    buffers = undefined;\n                }\n            },\n        };\n        for (let i = 0; i < _this._queue.length; ++i) {\n            _this.redis.sendCommand(_this._queue[i], stream, node);\n        }\n        return _this.promise;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLHNGQUFzQjtBQUM3RCxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsZ0VBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVM7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcz80MjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBDb21tYW5kZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0NvbW1hbmRlclwiKTtcbi8qXG4gIFRoaXMgZnVuY3Rpb24gZGVyaXZlcyBmcm9tIHRoZSBjbHVzdGVyLWtleS1zbG90IGltcGxlbWVudGF0aW9uLlxuICBJbnN0ZWFkIG9mIGNoZWNraW5nIHRoYXQgYWxsIGtleXMgaGF2ZSB0aGUgc2FtZSBzbG90LCBpdCBjaGVja3MgdGhhdCBhbGwgc2xvdHMgYXJlIHNlcnZlZCBieSB0aGUgc2FtZSBzZXQgb2Ygbm9kZXMuXG4gIElmIHRoaXMgaXMgc2F0aXNmaWVkLCBpdCByZXR1cm5zIHRoZSBmaXJzdCBrZXkncyBzbG90LlxuKi9cbmZ1bmN0aW9uIGdlbmVyYXRlTXVsdGlXaXRoTm9kZXMocmVkaXMsIGtleXMpIHtcbiAgICBjb25zdCBzbG90ID0gY2FsY3VsYXRlU2xvdChrZXlzWzBdKTtcbiAgICBjb25zdCB0YXJnZXQgPSByZWRpcy5fZ3JvdXBzQnlTbG90W3Nsb3RdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVkaXMuX2dyb3Vwc0J5U2xvdFtjYWxjdWxhdGVTbG90KGtleXNbaV0pXSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3Q7XG59XG5jbGFzcyBQaXBlbGluZSBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJlZGlzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVkaXMgPSByZWRpcztcbiAgICAgICAgdGhpcy5pc1BpcGVsaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXBseVBlbmRpbmcgPSAwO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zID0gMDtcbiAgICAgICAgdGhpcy5fc2hhVG9TY3JpcHQgPSB7fTtcbiAgICAgICAgdGhpcy5pc0NsdXN0ZXIgPVxuICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkNsdXN0ZXJcIiB8fCB0aGlzLnJlZGlzLmlzQ2x1c3RlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gcmVkaXMub3B0aW9ucztcbiAgICAgICAgT2JqZWN0LmtleXMocmVkaXMuc2NyaXB0c1NldCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gcmVkaXMuc2NyaXB0c1NldFtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuX3NoYVRvU2NyaXB0W3NjcmlwdC5zaGFdID0gc2NyaXB0O1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHJlZGlzW25hbWVdO1xuICAgICAgICAgICAgdGhpc1tuYW1lICsgXCJCdWZmZXJcIl0gPSByZWRpc1tuYW1lICsgXCJCdWZmZXJcIl07XG4gICAgICAgIH0pO1xuICAgICAgICByZWRpcy5hZGRlZEJ1aWx0aW5TZXQuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHJlZGlzW25hbWVdO1xuICAgICAgICAgICAgdGhpc1tuYW1lICsgXCJCdWZmZXJcIl0gPSByZWRpc1tuYW1lICsgXCJCdWZmZXJcIl07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWxsUmVzdWx0KHZhbHVlLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fcXVldWVbcG9zaXRpb25dLm5hbWUgPT09IFwiZXhlY1wiICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMV0pKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjTGVuZ3RoID0gdmFsdWVbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGVjTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMV1baV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY21kID0gdGhpcy5fcXVldWVbcG9zaXRpb24gLSAoZXhlY0xlbmd0aCAtIGkpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsxXVtpXSA9IGNtZC50cmFuc2Zvcm1SZXBseSh2YWx1ZVsxXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV1baV0gPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtwb3NpdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKC0tdGhpcy5yZXBseVBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIGxldCByZXRyaWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNvbW1vbkVycm9yO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX3Jlc3VsdFtpXVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5fcXVldWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwiZXhlY1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRVhFQ0FCT1JUIFRyYW5zYWN0aW9uIGRpc2NhcmRlZCBiZWNhdXNlIG9mIHByZXZpb3VzIGVycm9ycy5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21tb25FcnJvci5uYW1lICE9PSBlcnJvci5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb25FcnJvci5tZXNzYWdlICE9PSBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb21tYW5kLmluVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkT25seSA9ICgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZC5uYW1lKSAmJiAoMCwgY29tbWFuZHNfMS5oYXNGbGFnKShjb21tYW5kLm5hbWUsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tb25FcnJvciAmJiByZXRyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJydiA9IGNvbW1vbkVycm9yLm1lc3NhZ2Uuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgICAgICAgICAgICAgbGV0IGluVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycnZbMF0gPT09IFwiQVNLXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpblRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5uYW1lICE9PSBcImFza2luZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXF1ZXVlW2kgLSAxXSB8fCBxdWV1ZVtpIC0gMV0ubmFtZSAhPT0gXCJhc2tpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFza2luZyA9IG5ldyBDb21tYW5kXzEuZGVmYXVsdChcImFza2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFza2luZy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChhc2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmluaXRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQocXVldWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpblRyYW5zYWN0aW9uID0gcXVldWVbaV0uaW5UcmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZWZ0UmVkaXJlY3Rpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFJlZGlyZWN0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBleGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5leGVjKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbHVzdGVyID0gdGhpcy5yZWRpcztcbiAgICAgICAgICAgICAgICBjbHVzdGVyLmhhbmRsZUVycm9yKGNvbW1vbkVycm9yLCB0aGlzLmxlZnRSZWRpcmVjdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQ6IGZ1bmN0aW9uIChfc2xvdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmVmZXJLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnNsb3RzW2VycnZbMV1dID0gW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLl9ncm91cHNCeVNsb3RbZXJydlsxXV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuX2dyb3Vwc0lkc1tjbHVzdGVyLnNsb3RzW2VycnZbMV1dLmpvaW4oXCI7XCIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIucmVmcmVzaFNsb3RzQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNrOiBmdW5jdGlvbiAoX3Nsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlZmVyS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cnlhZ2FpbjogZXhlYyxcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlckRvd246IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25DbG9zZWQ6IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIG1heFJlZGlyZWN0aW9uczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0czogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlnbm9yZWRDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoIC0gaWdub3JlZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZVtpICsgaWdub3JlZENvdW50XS5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVkQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX3Jlc3VsdFtpICsgaWdub3JlZENvdW50XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmUodGhpcy5fcmVzdWx0LnNsaWNlKDAsIHRoaXMuX3Jlc3VsdC5sZW5ndGggLSBpZ25vcmVkQ291bnQpKTtcbiAgICB9XG4gICAgc2VuZENvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25zID4gMCkge1xuICAgICAgICAgICAgY29tbWFuZC5pblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICAgICAgY29tbWFuZC5waXBlbGluZUluZGV4ID0gcG9zaXRpb247XG4gICAgICAgIGNvbW1hbmQucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWxsUmVzdWx0KFtudWxsLCByZXN1bHRdLCBwb3NpdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbGxSZXN1bHQoW2Vycm9yXSwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaChjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEJhdGNoKGNvbW1hbmRzKSB7XG4gICAgICAgIGxldCBjb21tYW5kLCBjb21tYW5kTmFtZSwgYXJncztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgY29tbWFuZE5hbWUgPSBjb21tYW5kWzBdO1xuICAgICAgICAgICAgYXJncyA9IGNvbW1hbmQuc2xpY2UoMSk7XG4gICAgICAgICAgICB0aGlzW2NvbW1hbmROYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQaXBlbGluZTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IG11bHRpID0gUGlwZWxpbmUucHJvdG90eXBlLm11bHRpO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuUGlwZWxpbmUucHJvdG90eXBlLm11bHRpID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9ucyArPSAxO1xuICAgIHJldHVybiBtdWx0aS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGV4ZWNCdWZmZXIgPSBQaXBlbGluZS5wcm90b3R5cGUuZXhlY0J1ZmZlcjtcbi8vIEB0cy1leHBlY3QtZXJyb3JcblBpcGVsaW5lLnByb3RvdHlwZS5leGVjQnVmZmVyID0gKDAsIHV0aWxfMS5kZXByZWNhdGUpKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGV4ZWNCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIFwiUGlwZWxpbmUjZXhlY0J1ZmZlcjogVXNlIFBpcGVsaW5lI2V4ZWMgaW5zdGVhZFwiKTtcbi8vIE5PVEU6IFRvIGF2b2lkIGFuIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiwgdGhpcyB3aWxsIHVuY29uZGl0aW9uYWxseSBhbHdheXMgcmV0dXJuIHRoaXMucHJvbWlzZSxcbi8vIHdoaWNoIGFsd2F5cyBoYXMgdGhlIHJlamVjdGlvbiBoYW5kbGVkIGJ5IHN0YW5kYXJkLWFzLWNhbGxiYWNrXG4vLyBhZGRpbmcgdGhlIHByb3ZpZGVkIHJlamVjdGlvbiBjYWxsYmFjay5cbi8vXG4vLyBJZiBhIGRpZmZlcmVudCBwcm9taXNlIGluc3RhbmNlIHdlcmUgcmV0dXJuZWQsIHRoYXQgcHJvbWlzZSB3b3VsZCBjYXVzZSBpdHMgb3duIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvblxuLy8gZXJyb3JzLCBldmVuIGlmIHRoYXQgcHJvbWlzZSB1bmNvbmRpdGlvbmFsbHkgcmVzb2x2ZWQgdG8gKip0aGUgcmVzb2x2ZWQgdmFsdWUgb2YqKiB0aGlzLnByb21pc2UuXG5QaXBlbGluZS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIFdhaXQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIGNvbm5lY3RlZCwgc2luY2Ugd2UgbmVlZCBub2RlcyBpbmZvcm1hdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgIGlmICh0aGlzLmlzQ2x1c3RlciAmJiAhdGhpcy5yZWRpcy5zbG90cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVkaXMuc3RhdHVzID09PSBcIndhaXRcIilcbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29ubmVjdCgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIGlmIChjYWxsYmFjayAmJiAhdGhpcy5ub2RlaWZpZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVpZmllZFByb21pc2UgPSB0cnVlO1xuICAgICAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRpcy5kZWxheVVudGlsUmVhZHkoKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGVjKGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbnMgPiAwKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucyAtPSAxO1xuICAgICAgICByZXR1cm4gZXhlY0J1ZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9kZWlmaWVkUHJvbWlzZSkge1xuICAgICAgICB0aGlzLm5vZGVpZmllZFByb21pc2UgPSB0cnVlO1xuICAgICAgICAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KSh0aGlzLnByb21pc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgbGV0IHBpcGVsaW5lU2xvdDtcbiAgICBpZiAodGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB0aGUgZmlyc3Qga2V5IGZvciBlYWNoIGNvbW1hbmRcbiAgICAgICAgY29uc3Qgc2FtcGxlS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5fcXVldWVbaV0uZ2V0S2V5cygpO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlS2V5cy5wdXNoKGtleXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggY29tbWFuZCwgY2hlY2sgdGhhdCB0aGUga2V5cyBiZWxvbmcgdG8gdGhlIHNhbWUgc2xvdFxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoICYmIGNhbGN1bGF0ZVNsb3QuZ2VuZXJhdGVNdWx0aShrZXlzKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoXCJBbGwgdGhlIGtleXMgaW4gYSBwaXBlbGluZSBjb21tYW5kIHNob3VsZCBiZWxvbmcgdG8gdGhlIHNhbWUgc2xvdFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FtcGxlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBpcGVsaW5lU2xvdCA9IGdlbmVyYXRlTXVsdGlXaXRoTm9kZXModGhpcy5yZWRpcywgc2FtcGxlS2V5cyk7XG4gICAgICAgICAgICBpZiAocGlwZWxpbmVTbG90IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcihcIkFsbCBrZXlzIGluIHRoZSBwaXBlbGluZSBzaG91bGQgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RzIGFsbG9jYXRpb24gZ3JvdXBcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBwaXBlbGluZSB0byBhIHJhbmRvbSBub2RlXG4gICAgICAgICAgICBwaXBlbGluZVNsb3QgPSAoTWF0aC5yYW5kb20oKSAqIDE2Mzg0KSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGV4ZWNQaXBlbGluZSgpO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgZnVuY3Rpb24gZXhlY1BpcGVsaW5lKCkge1xuICAgICAgICBsZXQgd3JpdGVQZW5kaW5nID0gKF90aGlzLnJlcGx5UGVuZGluZyA9IF90aGlzLl9xdWV1ZS5sZW5ndGgpO1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgaWYgKF90aGlzLmlzQ2x1c3Rlcikge1xuICAgICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBzbG90OiBwaXBlbGluZVNsb3QsXG4gICAgICAgICAgICAgICAgcmVkaXM6IF90aGlzLnJlZGlzLmNvbm5lY3Rpb25Qb29sLm5vZGVzLmFsbFtfdGhpcy5wcmVmZXJLZXldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IFwiXCI7XG4gICAgICAgIGxldCBidWZmZXJzO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB7XG4gICAgICAgICAgICBpc1BpcGVsaW5lOiB0cnVlLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IF90aGlzLmlzQ2x1c3RlciA/IG5vZGUgOiB7IHJlZGlzOiBfdGhpcy5yZWRpcyB9LFxuICAgICAgICAgICAgd3JpdGUod3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyaXRhYmxlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oZGF0YSwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaCh3cml0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhICs9IHdyaXRhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIS0td3JpdGVQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChCdWZmZXIuZnJvbShkYXRhLCBcInV0ZjhcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmRlc3RpbmF0aW9uLnJlZGlzLnN0cmVhbS53cml0ZShCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0aW5hdGlvbi5yZWRpcy5zdHJlYW0ud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgd3JpdGVQZW5kaW5nIGZvciByZXNlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVQZW5kaW5nID0gX3RoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfdGhpcy5fcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZGlzLnNlbmRDb21tYW5kKF90aGlzLl9xdWV1ZVtpXSwgc3RyZWFtLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Redis.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/Redis.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst connectors_1 = __webpack_require__(/*! ./connectors */ \"(rsc)/./node_modules/ioredis/built/connectors/index.js\");\nconst SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nconst eventHandler = __webpack_require__(/*! ./redis/event_handler */ \"(rsc)/./node_modules/ioredis/built/redis/event_handler.js\");\nconst RedisOptions_1 = __webpack_require__(/*! ./redis/RedisOptions */ \"(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\");\nconst ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ./utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */\n        this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        }\n        else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        }\n        else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */\n    static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready.\n     */\n    connect(callback) {\n        const promise = new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username\n                    ? [options.username, options.password]\n                    : options.password,\n                subscriber: false,\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n                _this.silentEmit(type, err);\n            }), function (err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options &&\n                    options.sentinels &&\n                    !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, () => {\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    }\n                    else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */\n                        let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function () {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function () {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                }\n                else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(() => {\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                }\n                else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function () {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function () {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */\n    disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        }\n        else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */\n    end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */\n    duplicate(override) {\n        return new Redis({ ...this.options, ...override });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */\n    get mode() {\n        var _a;\n        return this.options.monitor\n            ? \"monitor\"\n            : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber)\n                ? \"subscriber\"\n                : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */\n    monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false,\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function () {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */\n    sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) &&\n            !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        let writable = this.status === \"ready\" ||\n            (!stream &&\n                this.status === \"connect\" &&\n                (0, commands_1.exists)(command.name) &&\n                (0, commands_1.hasFlag)(command.name, \"loading\"));\n        if (!this.stream) {\n            writable = false;\n        }\n        else if (!this.stream.writable) {\n            writable = false;\n            // @ts-expect-error\n        }\n        else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n        }\n        else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                }\n                else {\n                    stream.write(command.toWritable(stream));\n                }\n            }\n            else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n            if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n                this.setSocketTimeout();\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    setSocketTimeout() {\n        this.socketTimeoutTimer = setTimeout(() => {\n            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n            this.socketTimeoutTimer = undefined;\n        }, this.options.socketTimeout);\n        // this handler must run after the \"data\" handler in \"DataHandler\"\n        // so that `this.commandQueue.length` will be updated\n        this.stream.once(\"data\", () => {\n            clearTimeout(this.socketTimeoutTimer);\n            this.socketTimeoutTimer = undefined;\n            if (this.commandQueue.length === 0)\n                return;\n            this.setSocketTimeout();\n        });\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", { options });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", { options });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */\n    silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error &&\n                    (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n                        // @ts-expect-error\n                        error.syscall === \"connect\" ||\n                        // @ts-expect-error\n                        error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */\n    recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */\n    handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch (needReconnect) {\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select &&\n                    item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */\n    _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        }\n        else if (this.stream &&\n            this.stream.remoteAddress &&\n            this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        }\n        else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        }\n        else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for (let i = 0; i < args.length; ++i) {\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            }\n            else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            }\n            else if (typeof arg === \"number\") {\n                options.port = arg;\n            }\n            else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, { tls: true });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */\n    setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */\n    flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true,\n        });\n        let item;\n        if (options.offlineQueue) {\n            while ((item = this.offlineQueue.shift())) {\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while ((item = this.commandQueue.shift())) {\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */\n    _readyCheck(callback) {\n        const _this = this;\n        this.info(function (err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            }\n            else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime &&\n                    _this.options.maxLoadingRetryTime < loadingEtaMs\n                    ? _this.options.maxLoadingRetryTime\n                    : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function () {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports[\"default\"] = Redis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9SZWRpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsK0JBQStCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHNFQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLDRFQUFjO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLGdIQUFnQztBQUNwRSxxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDcEQsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ3JELHFCQUFxQixtQkFBTyxDQUFDLHNFQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFvQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxvREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLDJCQUEyQjtBQUNsSTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVk7QUFDdEcsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUmVkaXMuanM/Mzc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgY2x1c3Rlcl8xID0gcmVxdWlyZShcIi4vY2x1c3RlclwiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRcIik7XG5jb25zdCBjb25uZWN0b3JzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzXCIpO1xuY29uc3QgU2VudGluZWxDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3JcIik7XG5jb25zdCBldmVudEhhbmRsZXIgPSByZXF1aXJlKFwiLi9yZWRpcy9ldmVudF9oYW5kbGVyXCIpO1xuY29uc3QgUmVkaXNPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9yZWRpcy9SZWRpc09wdGlvbnNcIik7XG5jb25zdCBTY2FuU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9TY2FuU3RyZWFtXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgYXBwbHlNaXhpbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvYXBwbHlNaXhpblwiKTtcbmNvbnN0IENvbW1hbmRlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvQ29tbWFuZGVyXCIpO1xuY29uc3QgbG9kYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9sb2Rhc2hcIik7XG5jb25zdCBEZXF1ZSA9IHJlcXVpcmUoXCJkZW5xdWVcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcInJlZGlzXCIpO1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWpvciBjb21wb25lbnQgb2YgaW9yZWRpcy5cbiAqIFVzZSBpdCB0byBjb25uZWN0IHRvIGEgc3RhbmRhbG9uZSBSZWRpcyBzZXJ2ZXIgb3IgU2VudGluZWxzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKCk7IC8vIERlZmF1bHQgcG9ydCBpcyA2Mzc5XG4gKiBhc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICogICByZWRpcy5zZXQoXCJmb29cIiwgXCJiYXJcIik7XG4gKiAgIHJlZGlzLmdldChcImZvb1wiLCAoZXJyLCByZXN1bHQpID0+IHtcbiAqICAgICAvLyBgcmVzdWx0YCBzaG91bGQgYmUgXCJiYXJcIlxuICogICAgIGNvbnNvbGUubG9nKGVyciwgcmVzdWx0KTtcbiAqICAgfSk7XG4gKiAgIC8vIE9yIHVzZSBQcm9taXNlXG4gKiAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZGlzLmdldChcImZvb1wiKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBSZWRpcyBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcIndhaXRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoID0gMDtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gUHJlcGFyZSBhdXRvcGlwZWxpbmVzIHN0cnVjdHVyZXNcbiAgICAgICAgdGhpcy5fYXV0b1BpcGVsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnVubmluZ0F1dG9QaXBlbGluZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICBldmVudHNfMS5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldENvbW1hbmRRdWV1ZSgpO1xuICAgICAgICB0aGlzLnJlc2V0T2ZmbGluZVF1ZXVlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuQ29ubmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyB0aGlzLm9wdGlvbnMuQ29ubmVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLnNlbnRpbmVscykge1xuICAgICAgICAgICAgY29uc3Qgc2VudGluZWxDb25uZWN0b3IgPSBuZXcgU2VudGluZWxDb25uZWN0b3JfMS5kZWZhdWx0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBzZW50aW5lbENvbm5lY3Rvci5lbWl0dGVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gc2VudGluZWxDb25uZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBjb25uZWN0b3JzXzEuU3RhbmRhbG9uZUNvbm5lY3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NyaXB0cykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLnNjcmlwdHMpLmZvckVhY2goKFtuYW1lLCBkZWZpbml0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ29tbWFuZChuYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZChvciB3YWl0KSAtPiBjb25uZWN0aW5nIC0+IGNvbm5lY3QgLT4gcmVhZHkgLT4gZW5kXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF6eUNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwid2FpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJlZGlzIGluc3RhbmNlLlxuICAgICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYG5ldyBSZWRpcygpYCBidXQgaXMgaW5jbHVkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub2RlLXJlZGlzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDbGllbnQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZGlzKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBnZXQgYXV0b1BpcGVsaW5lUXVldWVTaXplKCkge1xuICAgICAgICBsZXQgcXVldWVkID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwaXBlbGluZSBvZiB0aGlzLl9hdXRvUGlwZWxpbmVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBxdWV1ZWQgKz0gcGlwZWxpbmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gdG8gUmVkaXMuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGF1dG9tYXRpY2FsbHkgd2hlbiBjcmVhdGluZyBhIG5ldyBSZWRpcyBpbnN0YW5jZVxuICAgICAqIHVubGVzcyBgbGF6eUNvbm5lY3Q6IHRydWVgIGlzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBtYW51YWxseSwgYSBQcm9taXNlIGlzIHJldHVybmVkLCB3aGljaCB3aWxsXG4gICAgICogYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgaXMgcmVhZHkuXG4gICAgICovXG4gICAgY29ubmVjdChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVkaXMgaXMgYWxyZWFkeSBjb25uZWN0aW5nL2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uRXBvY2ggKz0gMTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgIHNlbGVjdDogb3B0aW9ucy5kYixcbiAgICAgICAgICAgICAgICBhdXRoOiBvcHRpb25zLnVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgID8gW29wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmRdXG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KSh0aGlzLmNvbm5lY3Rvci5jb25uZWN0KGZ1bmN0aW9uICh0eXBlLCBlcnIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaWxlbnRFbWl0KHR5cGUsIGVycik7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKGVyciwgc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mbHVzaFF1ZXVlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKFwiZW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBDT05ORUNUX0VWRU5UID0gb3B0aW9ucy50bHMgPyBcInNlY3VyZUNvbm5lY3RcIiA6IFwiY29ubmVjdFwiO1xuICAgICAgICAgICAgICAgIGlmIChcInNlbnRpbmVsc1wiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZW50aW5lbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgIW9wdGlvbnMuZW5hYmxlVExTRm9yU2VudGluZWxNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIENPTk5FQ1RfRVZFTlQgPSBcImNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaWdub3JlcyBzZXRLZWVwQWxpdmUgYmVmb3JlIGNvbm5lY3QsIHRoZXJlZm9yZSB3ZSB3YWl0IGZvciB0aGUgZXZlbnQ6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMTY2M1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5rZWVwQWxpdmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShDT05ORUNUX0VWRU5ULCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldEtlZXBBbGl2ZSh0cnVlLCBvcHRpb25zLmtlZXBBbGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRLZWVwQWxpdmUodHJ1ZSwgb3B0aW9ucy5rZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShDT05ORUNUX0VWRU5ULCBldmVudEhhbmRsZXIuY29ubmVjdEhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUeXBpY2FsbHksIFNvY2tldCNzZXRUaW1lb3V0KDApIHdpbGwgY2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYmVmb3JlLiBIb3dldmVyLCBpbiBzb21lIHBsYXRmb3JtcyAoRWxlY3Ryb24gMy54fjQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgdGltZXIgd2lsbCBub3QgYmUgY2xlYXJlZC4gU28gd2UgaW50cm9kdWNlIGEgdmFyaWFibGUgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8xNDkxNVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29ubmVjdFRpbWVvdXRDbGVhcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0VGltZW91dChvcHRpb25zLmNvbm5lY3RUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RUaW1lb3V0Q2xlYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiY29ubmVjdCBFVElNRURPVVRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5lcnJvcm5vID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCA9IFwiY29ubmVjdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5lcnJvckhhbmRsZXIoX3RoaXMpKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmNlKENPTk5FQ1RfRVZFTlQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dENsZWFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVycm9yID0gX3RoaXMuY29ubmVjdG9yLmZpcnN0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuZXJyb3JIYW5kbGVyKF90aGlzKShmaXJzdEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZXZlbnRIYW5kbGVyLmNsb3NlSGFuZGxlcihfdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhldmVudEhhbmRsZXIuY29ubmVjdEhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgZXZlbnRIYW5kbGVyLmVycm9ySGFuZGxlcihfdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShcImNsb3NlXCIsIGV2ZW50SGFuZGxlci5jbG9zZUhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvblJlYWR5SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjb25uZWN0aW9uQ2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25DbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKFwicmVhZHlcIiwgY29ubmVjdGlvblJlYWR5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY2UoXCJyZWFkeVwiLCBjb25uZWN0aW9uUmVhZHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwiY2xvc2VcIiwgY29ubmVjdGlvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSBSZWRpcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNsb3NlcyB0aGUgY29ubmVjdGlvbiBpbW1lZGlhdGVseSxcbiAgICAgKiBhbmQgbWF5IGxvc2Ugc29tZSBwZW5kaW5nIHJlcGxpZXMgdGhhdCBoYXZlbid0IHdyaXR0ZW4gdG8gY2xpZW50LlxuICAgICAqIElmIHlvdSB3YW50IHRvIHdhaXQgZm9yIHRoZSBwZW5kaW5nIHJlcGxpZXMsIHVzZSBSZWRpcyNxdWl0IGluc3RlYWQuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChyZWNvbm5lY3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQgJiYgIXJlY29ubmVjdCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlci5jbG9zZUhhbmRsZXIodGhpcykoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gUmVkaXMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciByZWRpcyA9IG5ldyBSZWRpcyg2MzgwKTtcbiAgICAgKiB2YXIgYW5vdGhlclJlZGlzID0gcmVkaXMuZHVwbGljYXRlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZHVwbGljYXRlKG92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVkaXMoeyAuLi50aGlzLm9wdGlvbnMsIC4uLm92ZXJyaWRlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogT25lIG9mIGBcIm5vcm1hbFwiYCwgYFwic3Vic2NyaWJlclwiYCwgb3IgYFwibW9uaXRvclwiYC4gV2hlbiB0aGUgY29ubmVjdGlvbiBpc1xuICAgICAqIG5vdCBpbiBgXCJub3JtYWxcImAgbW9kZSwgY2VydGFpbiBjb21tYW5kcyBhcmUgbm90IGFsbG93ZWQuXG4gICAgICovXG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tb25pdG9yXG4gICAgICAgICAgICA/IFwibW9uaXRvclwiXG4gICAgICAgICAgICA6ICgoX2EgPSB0aGlzLmNvbmRpdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZXIpXG4gICAgICAgICAgICAgICAgPyBcInN1YnNjcmliZXJcIlxuICAgICAgICAgICAgICAgIDogXCJub3JtYWxcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBhbGwgcmVxdWVzdHMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlciBpbiByZWFsIHRpbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbW1hbmQgd2lsbCBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiB0byBSZWRpcyBhbmQgc2VuZCBhXG4gICAgICogTU9OSVRPUiBjb21tYW5kIHZpYSB0aGUgbmV3IGNvbm5lY3Rpb24gaW4gb3JkZXIgdG8gYXZvaWQgZGlzdHVyYmluZ1xuICAgICAqIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBJZiBvbWl0LCBhIHByb21pc2Ugd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJlZGlzID0gbmV3IFJlZGlzKCk7XG4gICAgICogcmVkaXMubW9uaXRvcihmdW5jdGlvbiAoZXJyLCBtb25pdG9yKSB7XG4gICAgICogICAvLyBFbnRlcmluZyBtb25pdG9yaW5nIG1vZGUuXG4gICAgICogICBtb25pdG9yLm9uKCdtb25pdG9yJywgZnVuY3Rpb24gKHRpbWUsIGFyZ3MsIHNvdXJjZSwgZGF0YWJhc2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2codGltZSArIFwiOiBcIiArIHV0aWwuaW5zcGVjdChhcmdzKSk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIHN1cHBvcnRzIHByb21pc2UgYXMgd2VsbCBhcyBvdGhlciBjb21tYW5kc1xuICAgICAqIHJlZGlzLm1vbml0b3IoKS50aGVuKGZ1bmN0aW9uIChtb25pdG9yKSB7XG4gICAgICogICBtb25pdG9yLm9uKCdtb25pdG9yJywgZnVuY3Rpb24gKHRpbWUsIGFyZ3MsIHNvdXJjZSwgZGF0YWJhc2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2codGltZSArIFwiOiBcIiArIHV0aWwuaW5zcGVjdChhcmdzKSk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBtb25pdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3JJbnN0YW5jZSA9IHRoaXMuZHVwbGljYXRlKHtcbiAgICAgICAgICAgIG1vbml0b3I6IHRydWUsXG4gICAgICAgICAgICBsYXp5Q29ubmVjdDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgbW9uaXRvckluc3RhbmNlLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgbW9uaXRvckluc3RhbmNlLm9uY2UoXCJtb25pdG9yaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1vbml0b3JJbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbW1hbmQgdG8gUmVkaXNcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgaW4gbW9zdCBjYXNlcyB5b3Ugc2hvdWxkIG5vdFxuICAgICAqIHVzZSBpdCBkaXJlY3RseS4gSWYgeW91IG5lZWQgdG8gc2VuZCBhIGNvbW1hbmQgdGhhdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogYnkgdGhlIGxpYnJhcnksIHlvdSBjYW4gdXNlIHRoZSBgY2FsbGAgbWV0aG9kOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCByZWRpcyA9IG5ldyBSZWRpcygpO1xuICAgICAqXG4gICAgICogcmVkaXMuY2FsbCgnc2V0JywgJ2ZvbycsICdiYXInKTtcbiAgICAgKiAvLyBvclxuICAgICAqIHJlZGlzLmNhbGwoWydzZXQnLCAnZm9vJywgJ2JhciddKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzZW5kQ29tbWFuZChjb21tYW5kLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2gobG9kYXNoXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmNvbmRpdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZXIpICYmXG4gICAgICAgICAgICAhQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gaW4gc3Vic2NyaWJlciBtb2RlLCBvbmx5IHN1YnNjcmliZXIgY29tbWFuZHMgbWF5IGJlIHVzZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb21tYW5kVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29tbWFuZC5zZXRUaW1lb3V0KHRoaXMub3B0aW9ucy5jb21tYW5kVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyaXRhYmxlID0gdGhpcy5zdGF0dXMgPT09IFwicmVhZHlcIiB8fFxuICAgICAgICAgICAgKCFzdHJlYW0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAoMCwgY29tbWFuZHNfMS5leGlzdHMpKGNvbW1hbmQubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAoMCwgY29tbWFuZHNfMS5oYXNGbGFnKShjb21tYW5kLm5hbWUsIFwibG9hZGluZ1wiKSk7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RyZWFtLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHRoaXMuc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBhcyB0aGUgUFIgaGFzIGFscmVhZHkgYmVlbiBtZXJnZWQuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW9qcy9pby5qcy9wdWxsLzEyMTdcbiAgICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3cml0YWJsZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlT2ZmbGluZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiU3RyZWFtIGlzbid0IHdyaXRlYWJsZSBhbmQgZW5hYmxlT2ZmbGluZVF1ZXVlIG9wdGlvbnMgaXMgZmFsc2VcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcInF1aXRcIiAmJiB0aGlzLm9mZmxpbmVRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlc29sdmUoQnVmZmVyLmZyb20oXCJPS1wiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJxdWV1ZSBjb21tYW5kWyVzXTogJWQgLT4gJXMoJW8pXCIsIHRoaXMuX2dldERlc2NyaXB0aW9uKCksIHRoaXMuY29uZGl0aW9uLnNlbGVjdCwgY29tbWFuZC5uYW1lLCBjb21tYW5kLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuY29uZGl0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndyaXRlIGNvbW1hbmRbJXNdOiAlZCAtPiAlcyglbylcIiwgdGhpcy5fZ2V0RGVzY3JpcHRpb24oKSwgKF9iID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZWxlY3QsIGNvbW1hbmQubmFtZSwgY29tbWFuZC5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpc1BpcGVsaW5lXCIgaW4gc3RyZWFtICYmIHN0cmVhbS5pc1BpcGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS53cml0ZShjb21tYW5kLnRvV3JpdGFibGUoc3RyZWFtLmRlc3RpbmF0aW9uLnJlZGlzLnN0cmVhbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlKGNvbW1hbmQudG9Xcml0YWJsZShzdHJlYW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShjb21tYW5kLnRvV3JpdGFibGUodGhpcy5zdHJlYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbWFuZFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLmNvbmRpdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJXSUxMX0RJU0NPTk5FQ1RcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc29ja2V0VGltZW91dFRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNvY2tldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcInNlbGVjdFwiICYmICgwLCB1dGlsc18xLmlzSW50KShjb21tYW5kLmFyZ3NbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IHBhcnNlSW50KGNvbW1hbmQuYXJnc1swXSwgMTApO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uLnNlbGVjdCAhPT0gZGIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5zZWxlY3QgPSBkYjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJzZWxlY3RcIiwgZGIpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3dpdGNoIHRvIGRiIFslZF1cIiwgdGhpcy5jb25kaXRpb24uc2VsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgIH1cbiAgICBzZXRTb2NrZXRUaW1lb3V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYFNvY2tldCB0aW1lb3V0LiBFeHBlY3RpbmcgZGF0YSwgYnV0IGRpZG4ndCByZWNlaXZlIGFueSBpbiAke3RoaXMub3B0aW9ucy5zb2NrZXRUaW1lb3V0fW1zLmApKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0VGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dCk7XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlciBtdXN0IHJ1biBhZnRlciB0aGUgXCJkYXRhXCIgaGFuZGxlciBpbiBcIkRhdGFIYW5kbGVyXCJcbiAgICAgICAgLy8gc28gdGhhdCBgdGhpcy5jb21tYW5kUXVldWUubGVuZ3RoYCB3aWxsIGJlIHVwZGF0ZWRcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcImRhdGFcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc29ja2V0VGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0VGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWFuZFF1ZXVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldFNvY2tldFRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjYW5TdHJlYW0ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic2NhblwiLCB7IG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHNjYW5CdWZmZXJTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic2NhbkJ1ZmZlclwiLCB7IG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHNzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic3NjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHNzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic3NjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIGhzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwiaHNjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIGhzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwiaHNjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHpzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwienNjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHpzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwienNjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgb25seSB3aGVuIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHNpbGVudEVtaXQoZXZlbnROYW1lLCBhcmcpIHtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGVycm9yID0gYXJnO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsbHlDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGNvbm5lY3Rpb24gcmVsYXRlZCBlcnJvcnMgd2hlbiBtYW51YWxseSBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVycm9yLm1lc3NhZ2UgPT09IHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zeXNjYWxsID09PSBcImNvbm5lY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3lzY2FsbCA9PT0gXCJyZWFkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKGV2ZW50TmFtZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW2lvcmVkaXNdIFVuaGFuZGxlZCBlcnJvciBldmVudDpcIiwgZXJyb3Iuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJlY292ZXJGcm9tRmF0YWxFcnJvcihfY29tbWFuZEVycm9yLCBlcnIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5mbHVzaFF1ZXVlKGVyciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2lsZW50RW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGhhbmRsZVJlY29ubmVjdGlvbihlcnIsIGl0ZW0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgbmVlZFJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlY29ubmVjdE9uRXJyb3IpIHtcbiAgICAgICAgICAgIG5lZWRSZWNvbm5lY3QgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0T25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobmVlZFJlY29ubmVjdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuY29uZGl0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VsZWN0KSAhPT0gaXRlbS5zZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLm5hbWUgIT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaXRlbS5zZWxlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkZXNjcmlwdGlvbiBvZiB0aGUgY29ubmVjdGlvbi4gVXNlZCBmb3IgZGVidWdnaW5nLlxuICAgICAqL1xuICAgIF9nZXREZXNjcmlwdGlvbigpIHtcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoXCJwYXRoXCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtICYmXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdGVBZGRyZXNzICYmXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdGVQb3J0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMuc3RyZWFtLnJlbW90ZUFkZHJlc3MgKyBcIjpcIiArIHRoaXMuc3RyZWFtLnJlbW90ZVBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJob3N0XCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5ob3N0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5ob3N0ICsgXCI6XCIgKyB0aGlzLm9wdGlvbnMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWRcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgICgke3RoaXMub3B0aW9ucy5jb25uZWN0aW9uTmFtZX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHJlc2V0Q29tbWFuZFF1ZXVlKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgICByZXNldE9mZmxpbmVRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgcGFyc2VPcHRpb25zKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXQgaXNUbHMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKG9wdGlvbnMsICgwLCB1dGlsc18xLnBhcnNlVVJMKShhcmcpKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLnN0YXJ0c1dpdGgoXCJyZWRpc3M6Ly9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNUbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IFwiICsgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUbHMpIHtcbiAgICAgICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgeyB0bHM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShvcHRpb25zLCBSZWRpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZUludChvcHRpb25zLnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGIgPSBwYXJzZUludChvcHRpb25zLmRiLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgdXRpbHNfMS5yZXNvbHZlVExTUHJvZmlsZSkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBpbnN0YW5jZSdzIHN0YXR1c1xuICAgICAqL1xuICAgIHNldFN0YXR1cyhzdGF0dXMsIGFyZykge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0YXR1c1slc106ICVzIC0+ICVzXCIsIHRoaXMuX2dldERlc2NyaXB0aW9uKCksIHRoaXMuc3RhdHVzIHx8IFwiW2VtcHR5XVwiLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW1pdC5iaW5kKHRoaXMsIHN0YXR1cywgYXJnKSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjYW5TdHJlYW0oY29tbWFuZCwgeyBrZXksIG9wdGlvbnMgPSB7fSB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhblN0cmVhbV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcmVkaXM6IHRoaXMsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIG9mZmxpbmUgcXVldWUgYW5kIGNvbW1hbmQgcXVldWUgd2l0aCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3Igb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGNvbW1hbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xuICAgICAqL1xuICAgIGZsdXNoUXVldWUoZXJyb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9ICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbW1hbmRRdWV1ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAob3B0aW9ucy5vZmZsaW5lUXVldWUpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IHRoaXMub2ZmbGluZVF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29tbWFuZFF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21tYW5kUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJkYXRhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSB0aGlzLmNvbW1hbmRRdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBSZWRpcyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgcGVyc2lzdGVudCBkYXRhIGFuZCBpcyBhYmxlIHRvXG4gICAgICogcHJvY2VzcyBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfcmVhZHlDaGVjayhjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mbyhmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJOT1BFUk1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyB0aGUgcmVhZHkgY2hlY2sgYmVjYXVzZSBJTkZPIGNvbW1hbmQgZmFpbHM6IFwiJHtlcnIubWVzc2FnZX1cIi4gWW91IGNhbiBkaXNhYmxlIHJlYWR5IGNoZWNrIHdpdGggXCJlbmFibGVSZWFkeUNoZWNrXCIuIE1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9sdWluL2lvcmVkaXMvd2lraS9EaXNhYmxlLXJlYWR5LWNoZWNrLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge307XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHJlcy5zcGxpdChcIlxcclxcblwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmllbGROYW1lLCAuLi5maWVsZFZhbHVlUGFydHNdID0gbGluZXNbaV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlUGFydHMuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb1tmaWVsZE5hbWVdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluZm8ubG9hZGluZyB8fCBpbmZvLmxvYWRpbmcgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nRXRhTXMgPSAoaW5mby5sb2FkaW5nX2V0YV9zZWNvbmRzIHx8IDEpICogMTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBfdGhpcy5vcHRpb25zLm1heExvYWRpbmdSZXRyeVRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5tYXhMb2FkaW5nUmV0cnlUaW1lIDwgbG9hZGluZ0V0YU1zXG4gICAgICAgICAgICAgICAgICAgID8gX3RoaXMub3B0aW9ucy5tYXhMb2FkaW5nUmV0cnlUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogbG9hZGluZ0V0YU1zO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiUmVkaXMgc2VydmVyIHN0aWxsIGxvYWRpbmcsIHRyeWluZyBhZ2FpbiBpbiBcIiArIHJldHJ5VGltZSArIFwibXNcIik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWFkeUNoZWNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LCByZXRyeVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICB9XG59XG5SZWRpcy5DbHVzdGVyID0gY2x1c3Rlcl8xLmRlZmF1bHQ7XG5SZWRpcy5Db21tYW5kID0gQ29tbWFuZF8xLmRlZmF1bHQ7XG4vKipcbiAqIERlZmF1bHQgb3B0aW9uc1xuICovXG5SZWRpcy5kZWZhdWx0T3B0aW9ucyA9IFJlZGlzT3B0aW9uc18xLkRFRkFVTFRfUkVESVNfT1BUSU9OUztcbigwLCBhcHBseU1peGluXzEuZGVmYXVsdCkoUmVkaXMsIGV2ZW50c18xLkV2ZW50RW1pdHRlcik7XG4oMCwgdHJhbnNhY3Rpb25fMS5hZGRUcmFuc2FjdGlvblN1cHBvcnQpKFJlZGlzLnByb3RvdHlwZSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Redis.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/ScanStream.js":
/*!**************************************************!*\
  !*** ./node_modules/ioredis/built/ScanStream.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Convenient class to convert the process of scanning keys to a readable stream.\n */\nclass ScanStream extends stream_1.Readable {\n    constructor(opt) {\n        super(opt);\n        this.opt = opt;\n        this._redisCursor = \"0\";\n        this._redisDrained = false;\n    }\n    _read() {\n        if (this._redisDrained) {\n            this.push(null);\n            return;\n        }\n        const args = [this._redisCursor];\n        if (this.opt.key) {\n            args.unshift(this.opt.key);\n        }\n        if (this.opt.match) {\n            args.push(\"MATCH\", this.opt.match);\n        }\n        if (this.opt.type) {\n            args.push(\"TYPE\", this.opt.type);\n        }\n        if (this.opt.count) {\n            args.push(\"COUNT\", String(this.opt.count));\n        }\n        this.opt.redis[this.opt.command](args, (err, res) => {\n            if (err) {\n                this.emit(\"error\", err);\n                return;\n            }\n            this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];\n            if (this._redisCursor === \"0\") {\n                this._redisDrained = true;\n            }\n            this.push(res[1]);\n        });\n    }\n    close() {\n        this._redisDrained = true;\n    }\n}\nexports[\"default\"] = ScanStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY2FuU3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NhblN0cmVhbS5qcz8wODA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIHRvIGNvbnZlcnQgdGhlIHByb2Nlc3Mgb2Ygc2Nhbm5pbmcga2V5cyB0byBhIHJlYWRhYmxlIHN0cmVhbS5cbiAqL1xuY2xhc3MgU2NhblN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgdGhpcy5vcHQgPSBvcHQ7XG4gICAgICAgIHRoaXMuX3JlZGlzQ3Vyc29yID0gXCIwXCI7XG4gICAgICAgIHRoaXMuX3JlZGlzRHJhaW5lZCA9IGZhbHNlO1xuICAgIH1cbiAgICBfcmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZGlzRHJhaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbdGhpcy5fcmVkaXNDdXJzb3JdO1xuICAgICAgICBpZiAodGhpcy5vcHQua2V5KSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpcy5vcHQua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQubWF0Y2gpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIk1BVENIXCIsIHRoaXMub3B0Lm1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQudHlwZSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiVFlQRVwiLCB0aGlzLm9wdC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQuY291bnQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIkNPVU5UXCIsIFN0cmluZyh0aGlzLm9wdC5jb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0LnJlZGlzW3RoaXMub3B0LmNvbW1hbmRdKGFyZ3MsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVkaXNDdXJzb3IgPSByZXNbMF0gaW5zdGFuY2VvZiBCdWZmZXIgPyByZXNbMF0udG9TdHJpbmcoKSA6IHJlc1swXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWRpc0N1cnNvciA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKHJlc1sxXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fcmVkaXNEcmFpbmVkID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTY2FuU3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/ScanStream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Script.js":
/*!**********************************************!*\
  !*** ./node_modules/ioredis/built/Script.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nclass Script {\n    constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false) {\n        this.lua = lua;\n        this.numberOfKeys = numberOfKeys;\n        this.keyPrefix = keyPrefix;\n        this.readOnly = readOnly;\n        this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n        const sha = this.sha;\n        const socketHasScriptLoaded = new WeakSet();\n        this.Command = class CustomScriptCommand extends Command_1.default {\n            toWritable(socket) {\n                const origReject = this.reject;\n                this.reject = (err) => {\n                    if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n                        socketHasScriptLoaded.delete(socket);\n                    }\n                    origReject.call(this, err);\n                };\n                if (!socketHasScriptLoaded.has(socket)) {\n                    socketHasScriptLoaded.add(socket);\n                    this.name = \"eval\";\n                    this.args[0] = lua;\n                }\n                else if (this.name === \"eval\") {\n                    this.name = \"evalsha\";\n                    this.args[0] = sha;\n                }\n                return super.toWritable(socket);\n            }\n        };\n    }\n    execute(container, args, options, callback) {\n        if (typeof this.numberOfKeys === \"number\") {\n            args.unshift(this.numberOfKeys);\n        }\n        if (this.keyPrefix) {\n            options.keyPrefix = this.keyPrefix;\n        }\n        if (this.readOnly) {\n            options.readOnly = true;\n        }\n        const evalsha = new this.Command(\"evalsha\", [this.sha, ...args], options);\n        evalsha.promise = evalsha.promise.catch((err) => {\n            if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n                throw err;\n            }\n            // Resend the same custom evalsha command that gets transformed\n            // to an eval in case it's not loaded yet on the connection.\n            const resend = new this.Command(\"evalsha\", [this.sha, ...args], options);\n            const client = container.isPipeline ? container.redis : container;\n            return client.sendCommand(resend);\n        });\n        (0, standard_as_callback_1.default)(evalsha.promise, callback);\n        return container.sendCommand(evalsha);\n    }\n}\nexports[\"default\"] = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQVc7QUFDckMsK0JBQStCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NyaXB0LmpzPzM1MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNsYXNzIFNjcmlwdCB7XG4gICAgY29uc3RydWN0b3IobHVhLCBudW1iZXJPZktleXMgPSBudWxsLCBrZXlQcmVmaXggPSBcIlwiLCByZWFkT25seSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubHVhID0gbHVhO1xuICAgICAgICB0aGlzLm51bWJlck9mS2V5cyA9IG51bWJlck9mS2V5cztcbiAgICAgICAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgICAgIHRoaXMucmVhZE9ubHkgPSByZWFkT25seTtcbiAgICAgICAgdGhpcy5zaGEgPSAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoXCJzaGExXCIpLnVwZGF0ZShsdWEpLmRpZ2VzdChcImhleFwiKTtcbiAgICAgICAgY29uc3Qgc2hhID0gdGhpcy5zaGE7XG4gICAgICAgIGNvbnN0IHNvY2tldEhhc1NjcmlwdExvYWRlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHRoaXMuQ29tbWFuZCA9IGNsYXNzIEN1c3RvbVNjcmlwdENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kXzEuZGVmYXVsdCB7XG4gICAgICAgICAgICB0b1dyaXRhYmxlKHNvY2tldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdSZWplY3QgPSB0aGlzLnJlamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJOT1NDUklQVFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldEhhc1NjcmlwdExvYWRlZC5kZWxldGUoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnUmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghc29ja2V0SGFzU2NyaXB0TG9hZGVkLmhhcyhzb2NrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldEhhc1NjcmlwdExvYWRlZC5hZGQoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJldmFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1swXSA9IGx1YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImV2YWxcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBcImV2YWxzaGFcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzWzBdID0gc2hhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIudG9Xcml0YWJsZShzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleGVjdXRlKGNvbnRhaW5lciwgYXJncywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm51bWJlck9mS2V5cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMubnVtYmVyT2ZLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5rZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMua2V5UHJlZml4ID0gdGhpcy5rZXlQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2YWxzaGEgPSBuZXcgdGhpcy5Db21tYW5kKFwiZXZhbHNoYVwiLCBbdGhpcy5zaGEsIC4uLmFyZ3NdLCBvcHRpb25zKTtcbiAgICAgICAgZXZhbHNoYS5wcm9taXNlID0gZXZhbHNoYS5wcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwiTk9TQ1JJUFRcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZW5kIHRoZSBzYW1lIGN1c3RvbSBldmFsc2hhIGNvbW1hbmQgdGhhdCBnZXRzIHRyYW5zZm9ybWVkXG4gICAgICAgICAgICAvLyB0byBhbiBldmFsIGluIGNhc2UgaXQncyBub3QgbG9hZGVkIHlldCBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHJlc2VuZCA9IG5ldyB0aGlzLkNvbW1hbmQoXCJldmFsc2hhXCIsIFt0aGlzLnNoYSwgLi4uYXJnc10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gY29udGFpbmVyLmlzUGlwZWxpbmUgPyBjb250YWluZXIucmVkaXMgOiBjb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRDb21tYW5kKHJlc2VuZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShldmFsc2hhLnByb21pc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5zZW5kQ29tbWFuZChldmFsc2hhKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTY3JpcHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/SubscriptionSet.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/SubscriptionSet.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Tiny class to simplify dealing with subscription set\n */\nclass SubscriptionSet {\n    constructor() {\n        this.set = {\n            subscribe: {},\n            psubscribe: {},\n            ssubscribe: {},\n        };\n    }\n    add(set, channel) {\n        this.set[mapSet(set)][channel] = true;\n    }\n    del(set, channel) {\n        delete this.set[mapSet(set)][channel];\n    }\n    channels(set) {\n        return Object.keys(this.set[mapSet(set)]);\n    }\n    isEmpty() {\n        return (this.channels(\"subscribe\").length === 0 &&\n            this.channels(\"psubscribe\").length === 0 &&\n            this.channels(\"ssubscribe\").length === 0);\n    }\n}\nexports[\"default\"] = SubscriptionSet;\nfunction mapSet(set) {\n    if (set === \"unsubscribe\") {\n        return \"subscribe\";\n    }\n    if (set === \"punsubscribe\") {\n        return \"psubscribe\";\n    }\n    if (set === \"sunsubscribe\") {\n        return \"ssubscribe\";\n    }\n    return set;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TdWJzY3JpcHRpb25TZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU3Vic2NyaXB0aW9uU2V0LmpzP2IwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRpbnkgY2xhc3MgdG8gc2ltcGxpZnkgZGVhbGluZyB3aXRoIHN1YnNjcmlwdGlvbiBzZXRcbiAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmU6IHt9LFxuICAgICAgICAgICAgcHN1YnNjcmliZToge30sXG4gICAgICAgICAgICBzc3Vic2NyaWJlOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkKHNldCwgY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnNldFttYXBTZXQoc2V0KV1bY2hhbm5lbF0gPSB0cnVlO1xuICAgIH1cbiAgICBkZWwoc2V0LCBjaGFubmVsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNldFttYXBTZXQoc2V0KV1bY2hhbm5lbF07XG4gICAgfVxuICAgIGNoYW5uZWxzKHNldCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXRbbWFwU2V0KHNldCldKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNoYW5uZWxzKFwic3Vic2NyaWJlXCIpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5jaGFubmVscyhcInBzdWJzY3JpYmVcIikubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKS5sZW5ndGggPT09IDApO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFN1YnNjcmlwdGlvblNldDtcbmZ1bmN0aW9uIG1hcFNldChzZXQpIHtcbiAgICBpZiAoc2V0ID09PSBcInVuc3Vic2NyaWJlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3Vic2NyaWJlXCI7XG4gICAgfVxuICAgIGlmIChzZXQgPT09IFwicHVuc3Vic2NyaWJlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwicHN1YnNjcmliZVwiO1xuICAgIH1cbiAgICBpZiAoc2V0ID09PSBcInN1bnN1YnNjcmliZVwiKSB7XG4gICAgICAgIHJldHVybiBcInNzdWJzY3JpYmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/autoPipelining.js":
/*!******************************************************!*\
  !*** ./node_modules/ioredis/built/autoPipelining.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\n    \"auth\",\n    \"info\",\n    \"script\",\n    \"quit\",\n    \"cluster\",\n    \"pipeline\",\n    \"multi\",\n    \"subscribe\",\n    \"psubscribe\",\n    \"unsubscribe\",\n    \"unpsubscribe\",\n    \"select\",\n];\nfunction executeAutoPipeline(client, slotKey) {\n    /*\n      If a pipeline is already executing, keep queueing up commands\n      since ioredis won't serve two pipelines at the same time\n    */\n    if (client._runningAutoPipelines.has(slotKey)) {\n        return;\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        /*\n          Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n          call to executeAutoPipeline.\n         \n          Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n          e.g. if redis is disconnected?\n        */\n        return;\n    }\n    client._runningAutoPipelines.add(slotKey);\n    // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n    const pipeline = client._autoPipelines.get(slotKey);\n    client._autoPipelines.delete(slotKey);\n    const callbacks = pipeline[exports.kCallbacks];\n    // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n    // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n    // in Redis.Cluster\n    pipeline[exports.kCallbacks] = null;\n    // Perform the call\n    pipeline.exec(function (err, results) {\n        client._runningAutoPipelines.delete(slotKey);\n        /*\n          Invoke all callback in nextTick so the stack is cleared\n          and callbacks can throw errors without affecting other callbacks.\n        */\n        if (err) {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], err);\n            }\n        }\n        else {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], ...results[i]);\n            }\n        }\n        // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n        if (client._autoPipelines.has(slotKey)) {\n            executeAutoPipeline(client, slotKey);\n        }\n    });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n    return (functionName &&\n        client.options.enableAutoPipelining &&\n        !client.isPipeline &&\n        !exports.notAllowedAutoPipelineCommands.includes(commandName) &&\n        !client.options.autoPipeliningIgnoredCommands.includes(commandName));\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n            if (arg.length === 0) {\n                continue;\n            }\n            return arg[0];\n        }\n        const flattened = [arg].flat();\n        if (flattened.length > 0) {\n            return flattened[0];\n        }\n    }\n    return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n    // On cluster mode let's wait for slots to be available\n    if (client.isCluster && !client.slots.length) {\n        if (client.status === \"wait\")\n            client.connect().catch(lodash_1.noop);\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            client.delayUntilReady((err) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n            });\n        }), callback);\n    }\n    // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n    // Note that the first value in args may be a (possibly empty) array.\n    // ioredis will only flatten one level of the array, in the Command constructor.\n    const prefix = client.options.keyPrefix || \"\";\n    const slotKey = client.isCluster\n        ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\")\n        : \"main\";\n    if (!client._autoPipelines.has(slotKey)) {\n        const pipeline = client.pipeline();\n        pipeline[exports.kExec] = false;\n        pipeline[exports.kCallbacks] = [];\n        client._autoPipelines.set(slotKey, pipeline);\n    }\n    const pipeline = client._autoPipelines.get(slotKey);\n    /*\n      Mark the pipeline as scheduled.\n      The symbol will make sure that the pipeline is only scheduled once per tick.\n      New commands are appended to an already scheduled pipeline.\n    */\n    if (!pipeline[exports.kExec]) {\n        pipeline[exports.kExec] = true;\n        /*\n          Deferring with setImmediate so we have a chance to capture multiple\n          commands that can be scheduled by I/O events already in the event loop queue.\n        */\n        setImmediate(executeAutoPipeline, client, slotKey);\n    }\n    // Create the promise which will execute the command in the pipeline.\n    const autoPipelinePromise = new Promise(function (resolve, reject) {\n        pipeline[exports.kCallbacks].push(function (err, value) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(value);\n        });\n        if (functionName === \"call\") {\n            args.unshift(commandName);\n        }\n        pipeline[functionName](...args);\n    });\n    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRyxzQ0FBc0MsR0FBRyxrQkFBa0IsR0FBRyxhQUFhO0FBQ3pMLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFnQjtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDaEQsK0JBQStCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdELGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTyxFQUFFLG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcz9lY2MxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nID0gZXhwb3J0cy5nZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheSA9IGV4cG9ydHMuc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcgPSBleHBvcnRzLm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcyA9IGV4cG9ydHMua0NhbGxiYWNrcyA9IGV4cG9ydHMua0V4ZWMgPSB2b2lkIDA7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZGFzaFwiKTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5leHBvcnRzLmtFeGVjID0gU3ltYm9sKFwiZXhlY1wiKTtcbmV4cG9ydHMua0NhbGxiYWNrcyA9IFN5bWJvbChcImNhbGxiYWNrc1wiKTtcbmV4cG9ydHMubm90QWxsb3dlZEF1dG9QaXBlbGluZUNvbW1hbmRzID0gW1xuICAgIFwiYXV0aFwiLFxuICAgIFwiaW5mb1wiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCJxdWl0XCIsXG4gICAgXCJjbHVzdGVyXCIsXG4gICAgXCJwaXBlbGluZVwiLFxuICAgIFwibXVsdGlcIixcbiAgICBcInN1YnNjcmliZVwiLFxuICAgIFwicHN1YnNjcmliZVwiLFxuICAgIFwidW5zdWJzY3JpYmVcIixcbiAgICBcInVucHN1YnNjcmliZVwiLFxuICAgIFwic2VsZWN0XCIsXG5dO1xuZnVuY3Rpb24gZXhlY3V0ZUF1dG9QaXBlbGluZShjbGllbnQsIHNsb3RLZXkpIHtcbiAgICAvKlxuICAgICAgSWYgYSBwaXBlbGluZSBpcyBhbHJlYWR5IGV4ZWN1dGluZywga2VlcCBxdWV1ZWluZyB1cCBjb21tYW5kc1xuICAgICAgc2luY2UgaW9yZWRpcyB3b24ndCBzZXJ2ZSB0d28gcGlwZWxpbmVzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAqL1xuICAgIGlmIChjbGllbnQuX3J1bm5pbmdBdXRvUGlwZWxpbmVzLmhhcyhzbG90S2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmhhcyhzbG90S2V5KSkge1xuICAgICAgICAvKlxuICAgICAgICAgIFJhcmUgZWRnZSBjYXNlLiBTb21laG93LCBzb21ldGhpbmcgaGFzIGRlbGV0ZWQgdGhpcyBydW5uaW5nIGF1dG9waXBlbGluZSBpbiBhbiBpbW1lZGlhdGVcbiAgICAgICAgICBjYWxsIHRvIGV4ZWN1dGVBdXRvUGlwZWxpbmUuXG4gICAgICAgICBcbiAgICAgICAgICBNYXliZSB0aGUgY2FsbGJhY2sgaW4gdGhlIHBpcGVsaW5lLmV4ZWMgaXMgc29tZXRpbWVzIGNhbGxlZCBpbiB0aGUgc2FtZSB0aWNrLFxuICAgICAgICAgIGUuZy4gaWYgcmVkaXMgaXMgZGlzY29ubmVjdGVkP1xuICAgICAgICAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsaWVudC5fcnVubmluZ0F1dG9QaXBlbGluZXMuYWRkKHNsb3RLZXkpO1xuICAgIC8vIEdldCB0aGUgcGlwZWxpbmUgYW5kIGltbWVkaWF0ZWx5IGRlbGV0ZSBpdCBzbyB0aGF0IG5ldyBjb21tYW5kcyBhcmUgcXVldWVkIG9uIGEgbmV3IHBpcGVsaW5lXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQuX2F1dG9QaXBlbGluZXMuZ2V0KHNsb3RLZXkpO1xuICAgIGNsaWVudC5fYXV0b1BpcGVsaW5lcy5kZWxldGUoc2xvdEtleSk7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXTtcbiAgICAvLyBTdG9wIGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gY2FsbGJhY2tzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjYWxsYmFja3Mgc3RvcCBiZWluZyB1c2VkLlxuICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBHQyB0byByZWNsYWltIG9iamVjdHMgcmVmZXJlbmNlZCBieSBjYWxsYmFja3MsIGVzcGVjaWFsbHkgd2l0aCAxNjM4NCBzbG90c1xuICAgIC8vIGluIFJlZGlzLkNsdXN0ZXJcbiAgICBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdID0gbnVsbDtcbiAgICAvLyBQZXJmb3JtIHRoZSBjYWxsXG4gICAgcGlwZWxpbmUuZXhlYyhmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGNsaWVudC5fcnVubmluZ0F1dG9QaXBlbGluZXMuZGVsZXRlKHNsb3RLZXkpO1xuICAgICAgICAvKlxuICAgICAgICAgIEludm9rZSBhbGwgY2FsbGJhY2sgaW4gbmV4dFRpY2sgc28gdGhlIHN0YWNrIGlzIGNsZWFyZWRcbiAgICAgICAgICBhbmQgY2FsbGJhY2tzIGNhbiB0aHJvdyBlcnJvcnMgd2l0aG91dCBhZmZlY3Rpbmcgb3RoZXIgY2FsbGJhY2tzLlxuICAgICAgICAqL1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tzW2ldLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrc1tpXSwgLi4ucmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW5vdGhlciBwaXBlbGluZSBvbiB0aGUgc2FtZSBub2RlLCBpbW1lZGlhdGVseSBleGVjdXRlIGl0IHdpdGhvdXQgd2FpdGluZyBmb3IgbmV4dFRpY2tcbiAgICAgICAgaWYgKGNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgICAgIGV4ZWN1dGVBdXRvUGlwZWxpbmUoY2xpZW50LCBzbG90S2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcoY2xpZW50LCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbk5hbWUgJiZcbiAgICAgICAgY2xpZW50Lm9wdGlvbnMuZW5hYmxlQXV0b1BpcGVsaW5pbmcgJiZcbiAgICAgICAgIWNsaWVudC5pc1BpcGVsaW5lICYmXG4gICAgICAgICFleHBvcnRzLm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kTmFtZSkgJiZcbiAgICAgICAgIWNsaWVudC5vcHRpb25zLmF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzLmluY2x1ZGVzKGNvbW1hbmROYW1lKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nID0gc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmc7XG5mdW5jdGlvbiBnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheShhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fCAoMCwgbG9kYXNoXzEuaXNBcmd1bWVudHMpKGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFthcmddLmZsYXQoKTtcbiAgICAgICAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmdldEZpcnN0VmFsdWVJbkZsYXR0ZW5lZEFycmF5ID0gZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXk7XG5mdW5jdGlvbiBleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nKGNsaWVudCwgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgYXJncywgY2FsbGJhY2spIHtcbiAgICAvLyBPbiBjbHVzdGVyIG1vZGUgbGV0J3Mgd2FpdCBmb3Igc2xvdHMgdG8gYmUgYXZhaWxhYmxlXG4gICAgaWYgKGNsaWVudC5pc0NsdXN0ZXIgJiYgIWNsaWVudC5zbG90cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgPT09IFwid2FpdFwiKVxuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3QoKS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNsaWVudC5kZWxheVVudGlsUmVhZHkoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyhjbGllbnQsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIGFyZ3MsIG51bGwpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIHNsb3QgaW5mb3JtYXRpb24sIHdlIGNhbiBpbXByb3ZlIHJvdXRpbmcgYnkgZ3JvdXBpbmcgc2xvdHMgc2VydmVkIGJ5IHRoZSBzYW1lIHN1YnNldCBvZiBub2Rlc1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgZmlyc3QgdmFsdWUgaW4gYXJncyBtYXkgYmUgYSAocG9zc2libHkgZW1wdHkpIGFycmF5LlxuICAgIC8vIGlvcmVkaXMgd2lsbCBvbmx5IGZsYXR0ZW4gb25lIGxldmVsIG9mIHRoZSBhcnJheSwgaW4gdGhlIENvbW1hbmQgY29uc3RydWN0b3IuXG4gICAgY29uc3QgcHJlZml4ID0gY2xpZW50Lm9wdGlvbnMua2V5UHJlZml4IHx8IFwiXCI7XG4gICAgY29uc3Qgc2xvdEtleSA9IGNsaWVudC5pc0NsdXN0ZXJcbiAgICAgICAgPyBjbGllbnQuc2xvdHNbY2FsY3VsYXRlU2xvdChgJHtwcmVmaXh9JHtnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheShhcmdzKX1gKV0uam9pbihcIixcIilcbiAgICAgICAgOiBcIm1haW5cIjtcbiAgICBpZiAoIWNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rRXhlY10gPSBmYWxzZTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXSA9IFtdO1xuICAgICAgICBjbGllbnQuX2F1dG9QaXBlbGluZXMuc2V0KHNsb3RLZXksIHBpcGVsaW5lKTtcbiAgICB9XG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQuX2F1dG9QaXBlbGluZXMuZ2V0KHNsb3RLZXkpO1xuICAgIC8qXG4gICAgICBNYXJrIHRoZSBwaXBlbGluZSBhcyBzY2hlZHVsZWQuXG4gICAgICBUaGUgc3ltYm9sIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHBpcGVsaW5lIGlzIG9ubHkgc2NoZWR1bGVkIG9uY2UgcGVyIHRpY2suXG4gICAgICBOZXcgY29tbWFuZHMgYXJlIGFwcGVuZGVkIHRvIGFuIGFscmVhZHkgc2NoZWR1bGVkIHBpcGVsaW5lLlxuICAgICovXG4gICAgaWYgKCFwaXBlbGluZVtleHBvcnRzLmtFeGVjXSkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtFeGVjXSA9IHRydWU7XG4gICAgICAgIC8qXG4gICAgICAgICAgRGVmZXJyaW5nIHdpdGggc2V0SW1tZWRpYXRlIHNvIHdlIGhhdmUgYSBjaGFuY2UgdG8gY2FwdHVyZSBtdWx0aXBsZVxuICAgICAgICAgIGNvbW1hbmRzIHRoYXQgY2FuIGJlIHNjaGVkdWxlZCBieSBJL08gZXZlbnRzIGFscmVhZHkgaW4gdGhlIGV2ZW50IGxvb3AgcXVldWUuXG4gICAgICAgICovXG4gICAgICAgIHNldEltbWVkaWF0ZShleGVjdXRlQXV0b1BpcGVsaW5lLCBjbGllbnQsIHNsb3RLZXkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBleGVjdXRlIHRoZSBjb21tYW5kIGluIHRoZSBwaXBlbGluZS5cbiAgICBjb25zdCBhdXRvUGlwZWxpbmVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IFwiY2FsbFwiKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoY29tbWFuZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBpcGVsaW5lW2Z1bmN0aW9uTmFtZV0oLi4uYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKGF1dG9QaXBlbGluZVByb21pc2UsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyA9IGV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/autoPipelining.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterOptions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CLUSTER_OPTIONS = void 0;\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nexports.DEFAULT_CLUSTER_OPTIONS = {\n    clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    scaleReads: \"master\",\n    maxRedirections: 16,\n    retryDelayOnMoved: 0,\n    retryDelayOnFailover: 100,\n    retryDelayOnClusterDown: 100,\n    retryDelayOnTryAgain: 100,\n    slotsRefreshTimeout: 1000,\n    useSRVRecords: false,\n    resolveSrv: dns_1.resolveSrv,\n    dnsLookup: dns_1.lookup,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyT3B0aW9ucy5qcz9hMzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0NMVVNURVJfT1BUSU9OUyA9IHZvaWQgMDtcbmNvbnN0IGRuc18xID0gcmVxdWlyZShcImRuc1wiKTtcbmV4cG9ydHMuREVGQVVMVF9DTFVTVEVSX09QVElPTlMgPSB7XG4gICAgY2x1c3RlclJldHJ5U3RyYXRlZ3k6ICh0aW1lcykgPT4gTWF0aC5taW4oMTAwICsgdGltZXMgKiAyLCAyMDAwKSxcbiAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgZW5hYmxlUmVhZHlDaGVjazogdHJ1ZSxcbiAgICBzY2FsZVJlYWRzOiBcIm1hc3RlclwiLFxuICAgIG1heFJlZGlyZWN0aW9uczogMTYsXG4gICAgcmV0cnlEZWxheU9uTW92ZWQ6IDAsXG4gICAgcmV0cnlEZWxheU9uRmFpbG92ZXI6IDEwMCxcbiAgICByZXRyeURlbGF5T25DbHVzdGVyRG93bjogMTAwLFxuICAgIHJldHJ5RGVsYXlPblRyeUFnYWluOiAxMDAsXG4gICAgc2xvdHNSZWZyZXNoVGltZW91dDogMTAwMCxcbiAgICB1c2VTUlZSZWNvcmRzOiBmYWxzZSxcbiAgICByZXNvbHZlU3J2OiBkbnNfMS5yZXNvbHZlU3J2LFxuICAgIGRuc0xvb2t1cDogZG5zXzEubG9va3VwLFxuICAgIGVuYWJsZUF1dG9QaXBlbGluaW5nOiBmYWxzZSxcbiAgICBhdXRvUGlwZWxpbmluZ0lnbm9yZWRDb21tYW5kczogW10sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterSubscriber.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter) {\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.started = false;\n        this.subscriber = null;\n        this.onSubscriberEnd = () => {\n            if (!this.started) {\n                debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n                return;\n            }\n            // If the subscriber closes whilst it's still the active connection,\n            // we might as well try to connecting to a new node if possible to\n            // minimise the number of missed publishes.\n            debug(\"subscriber has disconnected, selecting a new one...\");\n            this.selectSubscriber();\n        };\n        // If the current node we're using as the subscriber disappears\n        // from the node pool for some reason, we will select a new one\n        // to connect to.\n        // Note that this event is only triggered if the connection to\n        // the node has been used; cluster subscriptions are setup with\n        // lazyConnect = true. It's possible for the subscriber node to\n        // disappear without this method being called!\n        // See https://github.com/luin/ioredis/pull/1589\n        this.connectionPool.on(\"-node\", (_, key) => {\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", () => {\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n        debug(\"stopped\");\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n            lastActiveSubscriber.disconnect();\n        }\n        if (this.subscriber) {\n            this.subscriber.off(\"end\", this.onSubscriberEnd);\n            this.subscriber.disconnect();\n        }\n        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */\n        this.subscriber = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: (0, util_1.getConnectionName)(\"subscriber\", options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            // Don't try to reconnect the subscriber connection. If the connection fails\n            // we will get an end event (handled below), at which point we'll pick a new\n            // node from the pool and try to connect to that as the subscriber connection.\n            retryStrategy: null,\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // The node we lost connection to may not come back up in a\n        // reasonable amount of time (e.g. a slave that's taken down\n        // for maintainence), we could potentially miss many published\n        // messages so we should reconnect as quickly as possible, to\n        // a different node if needed.\n        this.subscriber.once(\"end\", this.onSubscriberEnd);\n        // Re-subscribe previous channels\n        const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe =\n                    condition.subscriber.channels(\"psubscribe\");\n                previousChannels.ssubscribe =\n                    condition.subscriber.channels(\"ssubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length ||\n            previousChannels.psubscribe.length ||\n            previousChannels.ssubscribe.length) {\n            let pending = 0;\n            for (const type of [\"subscribe\", \"psubscribe\", \"ssubscribe\"]) {\n                const channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels)\n                        .then(() => {\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    })\n                        .catch(() => {\n                        // TODO: should probably disconnect the subscriber and try again.\n                        debug(\"failed to %s %d channels\", type, channels.length);\n                    });\n                }\n            }\n        }\n        else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\n            \"message\",\n            \"messageBuffer\",\n            \"smessage\",\n            \"smessageBuffer\",\n        ]) {\n            this.subscriber.on(event, (arg1, arg2) => {\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2, arg3) => {\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n    }\n}\nexports[\"default\"] = ClusterSubscriber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyxrRUFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyU3Vic2NyaWJlci5qcz83ZDc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uL1JlZGlzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOnN1YnNjcmliZXJcIik7XG5jbGFzcyBDbHVzdGVyU3Vic2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvblBvb2wsIGVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbCA9IGNvbm5lY3Rpb25Qb29sO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblN1YnNjcmliZXJFbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlciBoYXMgZGlzY29ubmVjdGVkLCBidXQgQ2x1c3RlclN1YnNjcmliZXIgaXMgbm90IHN0YXJ0ZWQsIHNvIG5vdCByZWNvbm5lY3RpbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBzdWJzY3JpYmVyIGNsb3NlcyB3aGlsc3QgaXQncyBzdGlsbCB0aGUgYWN0aXZlIGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBhcyB3ZWxsIHRyeSB0byBjb25uZWN0aW5nIHRvIGEgbmV3IG5vZGUgaWYgcG9zc2libGUgdG9cbiAgICAgICAgICAgIC8vIG1pbmltaXNlIHRoZSBudW1iZXIgb2YgbWlzc2VkIHB1Ymxpc2hlcy5cbiAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlciBoYXMgZGlzY29ubmVjdGVkLCBzZWxlY3RpbmcgYSBuZXcgb25lLi4uXCIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RTdWJzY3JpYmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgd2UncmUgdXNpbmcgYXMgdGhlIHN1YnNjcmliZXIgZGlzYXBwZWFyc1xuICAgICAgICAvLyBmcm9tIHRoZSBub2RlIHBvb2wgZm9yIHNvbWUgcmVhc29uLCB3ZSB3aWxsIHNlbGVjdCBhIG5ldyBvbmVcbiAgICAgICAgLy8gdG8gY29ubmVjdCB0by5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgZXZlbnQgaXMgb25seSB0cmlnZ2VyZWQgaWYgdGhlIGNvbm5lY3Rpb24gdG9cbiAgICAgICAgLy8gdGhlIG5vZGUgaGFzIGJlZW4gdXNlZDsgY2x1c3RlciBzdWJzY3JpcHRpb25zIGFyZSBzZXR1cCB3aXRoXG4gICAgICAgIC8vIGxhenlDb25uZWN0ID0gdHJ1ZS4gSXQncyBwb3NzaWJsZSBmb3IgdGhlIHN1YnNjcmliZXIgbm9kZSB0b1xuICAgICAgICAvLyBkaXNhcHBlYXIgd2l0aG91dCB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQhXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbHVpbi9pb3JlZGlzL3B1bGwvMTU4OVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiLW5vZGVcIiwgKF8sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQgfHwgIXRoaXMuc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmdldE5vZGVLZXkpKHRoaXMuc3Vic2NyaWJlci5vcHRpb25zKSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzdWJzY3JpYmVyIGhhcyBsZWZ0LCBzZWxlY3RpbmcgYSBuZXcgb25lLi4uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIitub2RlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8IHRoaXMuc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKFwiYSBuZXcgbm9kZSBpcyBkaXNjb3ZlcmVkIGFuZCB0aGVyZSBpcyBubyBzdWJzY3JpYmVyLCBzZWxlY3RpbmcgYSBuZXcgb25lLi4uXCIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RTdWJzY3JpYmVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICBkZWJ1ZyhcInN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInN0b3BwZWRcIik7XG4gICAgfVxuICAgIHNlbGVjdFN1YnNjcmliZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgcHJldmlvdXMgc3Vic2NyaWJlciBldmVuIGlmIHRoZXJlXG4gICAgICAgIC8vIHdpbGwgbm90IGJlIGEgbmV3IG9uZS5cbiAgICAgICAgaWYgKGxhc3RBY3RpdmVTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBsYXN0QWN0aXZlU3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZVN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1wbGVOb2RlID0gKDAsIHV0aWxzXzEuc2FtcGxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBpZiAoIXNhbXBsZU5vZGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VsZWN0aW5nIHN1YnNjcmliZXIgZmFpbGVkIHNpbmNlIHRoZXJlIGlzIG5vIG5vZGUgZGlzY292ZXJlZCBpbiB0aGUgY2x1c3RlciB5ZXRcIik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc2FtcGxlTm9kZTtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RlZCBhIHN1YnNjcmliZXIgJXM6JXNcIiwgb3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGUgYSBzcGVjaWFsaXplZCBSZWRpcyBjb25uZWN0aW9uIGZvciB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBOb3RlIHRoYXQgYXV0byByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZW5hYmxlUmVhZHlDaGVja2AgaXMgYWxzbyBlbmFibGVkIGJlY2F1c2UgYWx0aG91Z2ggc3Vic2NyaXB0aW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICogd2hpbGUgcmVkaXMgaXMgbG9hZGluZyBkYXRhIGZyb20gdGhlIGRpc2ssIHdlIGNhbiBjaGVjayBpZiB0aGUgcGFzc3dvcmRcbiAgICAgICAgICogcHJvdmlkZWQgZm9yIHRoZSBzdWJzY3JpYmVyIGlzIGNvcnJlY3QsIGFuZCBpZiBub3QsIHRoZSBjdXJyZW50IHN1YnNjcmliZXJcbiAgICAgICAgICogd2lsbCBiZSBkaXNjb25uZWN0ZWQgYW5kIGEgbmV3IHN1YnNjcmliZXIgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBSZWRpc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IHRydWUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoXCJzdWJzY3JpYmVyXCIsIG9wdGlvbnMuY29ubmVjdGlvbk5hbWUpLFxuICAgICAgICAgICAgbGF6eUNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICB0bHM6IG9wdGlvbnMudGxzLFxuICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIHJlY29ubmVjdCB0aGUgc3Vic2NyaWJlciBjb25uZWN0aW9uLiBJZiB0aGUgY29ubmVjdGlvbiBmYWlsc1xuICAgICAgICAgICAgLy8gd2Ugd2lsbCBnZXQgYW4gZW5kIGV2ZW50IChoYW5kbGVkIGJlbG93KSwgYXQgd2hpY2ggcG9pbnQgd2UnbGwgcGljayBhIG5ld1xuICAgICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSBwb29sIGFuZCB0cnkgdG8gY29ubmVjdCB0byB0aGF0IGFzIHRoZSBzdWJzY3JpYmVyIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBlcnJvcnMgc2luY2UgdGhleSdyZSBoYW5kbGVkIGluIHRoZSBjb25uZWN0aW9uIHBvb2wuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihcImVycm9yXCIsIHV0aWxzXzEubm9vcCk7XG4gICAgICAgIC8vIFRoZSBub2RlIHdlIGxvc3QgY29ubmVjdGlvbiB0byBtYXkgbm90IGNvbWUgYmFjayB1cCBpbiBhXG4gICAgICAgIC8vIHJlYXNvbmFibGUgYW1vdW50IG9mIHRpbWUgKGUuZy4gYSBzbGF2ZSB0aGF0J3MgdGFrZW4gZG93blxuICAgICAgICAvLyBmb3IgbWFpbnRhaW5lbmNlKSwgd2UgY291bGQgcG90ZW50aWFsbHkgbWlzcyBtYW55IHB1Ymxpc2hlZFxuICAgICAgICAvLyBtZXNzYWdlcyBzbyB3ZSBzaG91bGQgcmVjb25uZWN0IGFzIHF1aWNrbHkgYXMgcG9zc2libGUsIHRvXG4gICAgICAgIC8vIGEgZGlmZmVyZW50IG5vZGUgaWYgbmVlZGVkLlxuICAgICAgICB0aGlzLnN1YnNjcmliZXIub25jZShcImVuZFwiLCB0aGlzLm9uU3Vic2NyaWJlckVuZCk7XG4gICAgICAgIC8vIFJlLXN1YnNjcmliZSBwcmV2aW91cyBjaGFubmVsc1xuICAgICAgICBjb25zdCBwcmV2aW91c0NoYW5uZWxzID0geyBzdWJzY3JpYmU6IFtdLCBwc3Vic2NyaWJlOiBbXSwgc3N1YnNjcmliZTogW10gfTtcbiAgICAgICAgaWYgKGxhc3RBY3RpdmVTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBsYXN0QWN0aXZlU3Vic2NyaWJlci5jb25kaXRpb24gfHwgbGFzdEFjdGl2ZVN1YnNjcmliZXIucHJldkNvbmRpdGlvbjtcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgY29uZGl0aW9uLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnN1YnNjcmliZSA9IGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMucHN1YnNjcmliZSA9XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwicHN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnNzdWJzY3JpYmUgPVxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInNzdWJzY3JpYmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzQ2hhbm5lbHMuc3Vic2NyaWJlLmxlbmd0aCB8fFxuICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5wc3Vic2NyaWJlLmxlbmd0aCB8fFxuICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5zc3Vic2NyaWJlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFtcInN1YnNjcmliZVwiLCBcInBzdWJzY3JpYmVcIiwgXCJzc3Vic2NyaWJlXCJdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBwcmV2aW91c0NoYW5uZWxzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIiVzICVkIGNoYW5uZWxzXCIsIHR5cGUsIGNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlclt0eXBlXShjaGFubmVscylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlciA9IHRoaXMuc3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgcHJvYmFibHkgZGlzY29ubmVjdCB0aGUgc3Vic2NyaWJlciBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJmYWlsZWQgdG8gJXMgJWQgY2hhbm5lbHNcIiwgdHlwZSwgY2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlciA9IHRoaXMuc3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcbiAgICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgXCJtZXNzYWdlQnVmZmVyXCIsXG4gICAgICAgICAgICBcInNtZXNzYWdlXCIsXG4gICAgICAgICAgICBcInNtZXNzYWdlQnVmZmVyXCIsXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihldmVudCwgKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChldmVudCwgYXJnMSwgYXJnMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcInBtZXNzYWdlXCIsIFwicG1lc3NhZ2VCdWZmZXJcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihldmVudCwgKGFyZzEsIGFyZzIsIGFyZzMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChldmVudCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXJTdWJzY3JpYmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ConnectionPool.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions) {\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {},\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map((key) => nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = (0, utils_1.sample)(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Find or create a connection to the node\n     */\n    findOrCreate(node, readOnly = false) {\n        const key = (0, util_1.getNodeKey)(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        }\n        else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                }\n                else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        }\n        else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = new Redis_1.default((0, utils_1.defaults)({\n                // Never try to reconnect when a node is lose,\n                // instead, waiting for a `MOVED` error and\n                // fetch the slots again.\n                retryStrategy: null,\n                // Offline queue should be enabled so that\n                // we don't need to wait for the `ready` event\n                // before sending commands to the node.\n                enableOfflineQueue: true,\n                readOnly: readOnly,\n            }, node, this.redisOptions, { lazyConnect: true }));\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", () => {\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function (error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     */\n    reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach((node) => {\n            const key = (0, util_1.getNodeKey)(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach((key) => {\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach((key) => {\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n    /**\n     * Remove a node from the pool.\n     */\n    removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n}\nexports[\"default\"] = ConnectionPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFVO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxrRUFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QixtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzPzY3ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFJlZGlzXzEgPSByZXF1aXJlKFwiLi4vUmVkaXNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcImNsdXN0ZXI6Y29ubmVjdGlvblBvb2xcIik7XG5jbGFzcyBDb25uZWN0aW9uUG9vbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IocmVkaXNPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVkaXNPcHRpb25zID0gcmVkaXNPcHRpb25zO1xuICAgICAgICAvLyBtYXN0ZXIgKyBzbGF2ZSA9IGFsbFxuICAgICAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgICAgICAgYWxsOiB7fSxcbiAgICAgICAgICAgIG1hc3Rlcjoge30sXG4gICAgICAgICAgICBzbGF2ZToge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3BlY2lmaWVkT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBnZXROb2Rlcyhyb2xlID0gXCJhbGxcIikge1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMubm9kZXNbcm9sZV07XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhub2RlcykubWFwKChrZXkpID0+IG5vZGVzW2tleV0pO1xuICAgIH1cbiAgICBnZXRJbnN0YW5jZUJ5S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5hbGxba2V5XTtcbiAgICB9XG4gICAgZ2V0U2FtcGxlSW5zdGFuY2Uocm9sZSkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5ub2Rlc1tyb2xlXSk7XG4gICAgICAgIGNvbnN0IHNhbXBsZUtleSA9ICgwLCB1dGlsc18xLnNhbXBsZSkoa2V5cyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3JvbGVdW3NhbXBsZUtleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgb3IgY3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgbm9kZVxuICAgICAqL1xuICAgIGZpbmRPckNyZWF0ZShub2RlLCByZWFkT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZSk7XG4gICAgICAgIHJlYWRPbmx5ID0gQm9vbGVhbihyZWFkT25seSk7XG4gICAgICAgIGlmICh0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZGlzO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5hbGxba2V5XSkge1xuICAgICAgICAgICAgcmVkaXMgPSB0aGlzLm5vZGVzLmFsbFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlZGlzLm9wdGlvbnMucmVhZE9ubHkgIT09IHJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmVkaXMub3B0aW9ucy5yZWFkT25seSA9IHJlYWRPbmx5O1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ2hhbmdlIHJvbGUgb2YgJXMgdG8gJXNcIiwga2V5LCByZWFkT25seSA/IFwic2xhdmVcIiA6IFwibWFzdGVyXCIpO1xuICAgICAgICAgICAgICAgIHJlZGlzW3JlYWRPbmx5ID8gXCJyZWFkb25seVwiIDogXCJyZWFkd3JpdGVcIl0oKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5tYXN0ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLm1hc3RlcltrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJDb25uZWN0aW5nIHRvICVzIGFzICVzXCIsIGtleSwgcmVhZE9ubHkgPyBcInNsYXZlXCIgOiBcIm1hc3RlclwiKTtcbiAgICAgICAgICAgIHJlZGlzID0gbmV3IFJlZGlzXzEuZGVmYXVsdCgoMCwgdXRpbHNfMS5kZWZhdWx0cykoe1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHRyeSB0byByZWNvbm5lY3Qgd2hlbiBhIG5vZGUgaXMgbG9zZSxcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCB3YWl0aW5nIGZvciBhIGBNT1ZFRGAgZXJyb3IgYW5kXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2ggdGhlIHNsb3RzIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICAgICAgLy8gT2ZmbGluZSBxdWV1ZSBzaG91bGQgYmUgZW5hYmxlZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciB0aGUgYHJlYWR5YCBldmVudFxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBzZW5kaW5nIGNvbW1hbmRzIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgICAgICAgICB9LCBub2RlLCB0aGlzLnJlZGlzT3B0aW9ucywgeyBsYXp5Q29ubmVjdDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmFsbFtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW3JlYWRPbmx5ID8gXCJzbGF2ZVwiIDogXCJtYXN0ZXJcIl1ba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgcmVkaXMub25jZShcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiLW5vZGVcIiwgcmVkaXMsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm5vZGVzLmFsbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiK25vZGVcIiwgcmVkaXMsIGtleSk7XG4gICAgICAgICAgICByZWRpcy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vZGVFcnJvclwiLCBlcnJvciwga2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWRpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHBvb2wgd2l0aCBhIHNldCBvZiBub2Rlcy5cbiAgICAgKiBUaGUgb2xkIG5vZGUgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlc2V0KG5vZGVzKSB7XG4gICAgICAgIGRlYnVnKFwiUmVzZXQgd2l0aCAlT1wiLCBub2Rlcyk7XG4gICAgICAgIGNvbnN0IG5ld05vZGVzID0ge307XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZSk7XG4gICAgICAgICAgICAvLyBEb24ndCBvdmVycmlkZSB0aGUgZXhpc3RpbmcgKG1hc3Rlcikgbm9kZVxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgY3VycmVudCBvbmUgaXMgc2xhdmUuXG4gICAgICAgICAgICBpZiAoIShub2RlLnJlYWRPbmx5ICYmIG5ld05vZGVzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXNba2V5XSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm5vZGVzLmFsbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld05vZGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkRpc2Nvbm5lY3QgJXMgYmVjYXVzZSB0aGUgbm9kZSBkb2VzIG5vdCBob2xkIGFueSBzbG90XCIsIGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5hbGxba2V5XS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyhuZXdOb2RlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3Tm9kZXNba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZmluZE9yQ3JlYXRlKG5vZGUsIG5vZGUucmVhZE9ubHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBwb29sLlxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChub2Rlcy5hbGxba2V5XSkge1xuICAgICAgICAgICAgZGVidWcoXCJSZW1vdmUgJXMgZnJvbSB0aGUgcG9vbFwiLCBrZXkpO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGVzLmFsbFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBub2Rlcy5tYXN0ZXJba2V5XTtcbiAgICAgICAgZGVsZXRlIG5vZGVzLnNsYXZlW2tleV07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvblBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/DelayQueue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"delayqueue\");\n/**\n * Queue that runs items after specified duration\n */\nclass DelayQueue {\n    constructor() {\n        this.queues = {};\n        this.timeouts = {};\n    }\n    /**\n     * Add a new item to the queue\n     *\n     * @param bucket bucket name\n     * @param item function that will run later\n     * @param options\n     */\n    push(bucket, item, options) {\n        const callback = options.callback || process.nextTick;\n        if (!this.queues[bucket]) {\n            this.queues[bucket] = new Deque();\n        }\n        const queue = this.queues[bucket];\n        queue.push(item);\n        if (!this.timeouts[bucket]) {\n            this.timeouts[bucket] = setTimeout(() => {\n                callback(() => {\n                    this.timeouts[bucket] = null;\n                    this.execute(bucket);\n                });\n            }, options.timeout);\n        }\n    }\n    execute(bucket) {\n        const queue = this.queues[bucket];\n        if (!queue) {\n            return;\n        }\n        const { length } = queue;\n        if (!length) {\n            return;\n        }\n        debug(\"send %d commands in %s queue\", length, bucket);\n        this.queues[bucket] = null;\n        while (queue.length > 0) {\n            queue.shift()();\n        }\n    }\n}\nexports[\"default\"] = DelayQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0RlbGF5UXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVU7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLG9EQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0RlbGF5UXVldWUuanM/MDJhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBEZXF1ZSA9IHJlcXVpcmUoXCJkZW5xdWVcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcImRlbGF5cXVldWVcIik7XG4vKipcbiAqIFF1ZXVlIHRoYXQgcnVucyBpdGVtcyBhZnRlciBzcGVjaWZpZWQgZHVyYXRpb25cbiAqL1xuY2xhc3MgRGVsYXlRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucXVldWVzID0ge307XG4gICAgICAgIHRoaXMudGltZW91dHMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IGl0ZW0gdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVja2V0IGJ1Y2tldCBuYW1lXG4gICAgICogQHBhcmFtIGl0ZW0gZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBsYXRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHVzaChidWNrZXQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICghdGhpcy5xdWV1ZXNbYnVja2V0XSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZXNbYnVja2V0XSA9IG5ldyBEZXF1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbYnVja2V0XTtcbiAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVvdXRzW2J1Y2tldF0pIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dHNbYnVja2V0XSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0c1tidWNrZXRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlKGJ1Y2tldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGUoYnVja2V0KSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbYnVja2V0XTtcbiAgICAgICAgaWYgKCFxdWV1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBxdWV1ZTtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNlbmQgJWQgY29tbWFuZHMgaW4gJXMgcXVldWVcIiwgbGVuZ3RoLCBidWNrZXQpO1xuICAgICAgICB0aGlzLnF1ZXVlc1tidWNrZXRdID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlbGF5UXVldWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst ClusterAllFailedError_1 = __webpack_require__(/*! ../errors/ClusterAllFailedError */ \"(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst ScanStream_1 = __webpack_require__(/*! ../ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ../utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ../utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst ClusterOptions_1 = __webpack_require__(/*! ./ClusterOptions */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst DelayQueue_1 = __webpack_require__(/*! ./DelayQueue */ \"(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */\n        this._groupsIds = {};\n        /**\n         * @ignore\n         */\n        this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */\n        this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._refreshSlotsCacheCallbacks = [];\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */\n        this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.redisOptions &&\n            this.options.redisOptions.keyPrefix &&\n            !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis) => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch((err) => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */\n    connect() {\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then((nodes) => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                const readyHandler = () => {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = () => {\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler();\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler();\n                    }\n                };\n                closeListener = () => {\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err) => {\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n            })\n                .catch((err) => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */\n    delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */\n    refreshSlotsCache(callback) {\n        if (callback) {\n            this._refreshSlotsCacheCallbacks.push(callback);\n        }\n        if (this.isRefreshing) {\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error) => {\n            this.isRefreshing = false;\n            for (const callback of this._refreshSlotsCacheCallbacks) {\n                callback(error);\n            }\n            this._refreshSlotsCacheCallbacks = [];\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                ((0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this._groupsBySlot[slot] =\n                            _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    },\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    redis = _this.subscriber.getInstance();\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node,\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * @ignore\n     */\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), { timeout });\n            }\n            else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        }\n        else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain,\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(() => {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */\n    flushQueue(error) {\n        let item;\n        while ((item = this.offlineQueue.shift())) {\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while ((item = offlineQueue.shift())) {\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            const key = typeof nodeKey === \"string\"\n                ? nodeKey\n                : `${nodeKey.host}:${nodeKey.port}`;\n            const mapped = this.options.natMap[key];\n            if (mapped) {\n                debug(\"NAT mapping %s -> %O\", key, mapped);\n                return Object.assign({}, mapped);\n            }\n        }\n        return typeof nodeKey === \"string\"\n            ? (0, util_1.nodeKeyToRedisOptions)(nodeKey)\n            : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName),\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1],\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for (let i = 0; i < 16384; i++) {\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks) {\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */\n    readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res) => {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.resolveSrv(hostname, (err, records) => {\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host) => resolve({\n                        host,\n                        port: record.port,\n                    }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */\n    async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node) => {\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, { host: config });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports[\"default\"] = Cluster;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLGdGQUFtQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyx1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBYztBQUM3QywrQkFBK0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsaUVBQVk7QUFDdEMsZ0NBQWdDLG1CQUFPLENBQUMsMkdBQWlDO0FBQ3pFLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDLHFCQUFxQixtQkFBTyxDQUFDLHVFQUFlO0FBQzVDLHNCQUFzQixtQkFBTyxDQUFDLHlFQUFnQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsaUZBQW9CO0FBQ2hELHlCQUF5QixtQkFBTyxDQUFDLHNGQUFrQjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDekQseUJBQXlCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxrRUFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsb0RBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVksR0FBRyxZQUFZO0FBQzNFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkMsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxtQ0FBbUMsVUFBVSxjQUFjO0FBQzNELFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL2luZGV4LmpzP2YyMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIkBpb3JlZGlzL2NvbW1hbmRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgcmVkaXNfZXJyb3JzXzEgPSByZXF1aXJlKFwicmVkaXMtZXJyb3JzXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuLi9Db21tYW5kXCIpO1xuY29uc3QgQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL0NsdXN0ZXJBbGxGYWlsZWRFcnJvclwiKTtcbmNvbnN0IFJlZGlzXzEgPSByZXF1aXJlKFwiLi4vUmVkaXNcIik7XG5jb25zdCBTY2FuU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vU2NhblN0cmVhbVwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgYXBwbHlNaXhpbl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2FwcGx5TWl4aW5cIik7XG5jb25zdCBDb21tYW5kZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9Db21tYW5kZXJcIik7XG5jb25zdCBDbHVzdGVyT3B0aW9uc18xID0gcmVxdWlyZShcIi4vQ2x1c3Rlck9wdGlvbnNcIik7XG5jb25zdCBDbHVzdGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4vQ2x1c3RlclN1YnNjcmliZXJcIik7XG5jb25zdCBDb25uZWN0aW9uUG9vbF8xID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvb2xcIik7XG5jb25zdCBEZWxheVF1ZXVlXzEgPSByZXF1aXJlKFwiLi9EZWxheVF1ZXVlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IERlcXVlID0gcmVxdWlyZShcImRlbnF1ZVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlclwiKTtcbmNvbnN0IFJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUyA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIENsaWVudCBmb3IgdGhlIG9mZmljaWFsIFJlZGlzIENsdXN0ZXJcbiAqL1xuY2xhc3MgQ2x1c3RlciBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2x1c3Rlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGFydHVwTm9kZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNsb3RzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ncm91cHNJZHMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdCA9IEFycmF5KDE2Mzg0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5kZWxheVF1ZXVlID0gbmV3IERlbGF5UXVldWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub2ZmbGluZVF1ZXVlID0gbmV3IERlcXVlKCk7XG4gICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuX2F1dG9QaXBlbGluZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3J1bm5pbmdBdXRvUGlwZWxpbmVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZXJ5IHRpbWUgQ2x1c3RlciNjb25uZWN0KCkgaXMgY2FsbGVkLCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAgICAgICAgICogYXV0by1pbmNyZW1lbnRpbmcuIFRoZSBwdXJwb3NlIG9mIHRoaXMgdmFsdWUgaXMgdXNlZCBmb3JcbiAgICAgICAgICogZGlzY2FyZGluZyBwcmV2aW91cyBjb25uZWN0IGF0dGFtcHRzIHdoZW4gY3JlYXRpbmcgYSBuZXdcbiAgICAgICAgICogY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoID0gMDtcbiAgICAgICAgZXZlbnRzXzEuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3RhcnR1cE5vZGVzID0gc3RhcnR1cE5vZGVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgdXRpbHNfMS5kZWZhdWx0cykoe30sIG9wdGlvbnMsIENsdXN0ZXJPcHRpb25zXzEuREVGQVVMVF9DTFVTVEVSX09QVElPTlMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmtleVByZWZpeCAmJlxuICAgICAgICAgICAgIXRoaXMub3B0aW9ucy5rZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5rZXlQcmVmaXggPSB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmtleVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNjYWxlUmVhZHMgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgW1wiYWxsXCIsIFwibWFzdGVyXCIsIFwic2xhdmVcIl0uaW5kZXhPZih0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uIHNjYWxlUmVhZHMgXCInICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcyArXG4gICAgICAgICAgICAgICAgJ1wiLiBFeHBlY3RlZCBcImFsbFwiLCBcIm1hc3RlclwiLCBcInNsYXZlXCIgb3IgYSBjdXN0b20gZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sID0gbmV3IENvbm5lY3Rpb25Qb29sXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIi1ub2RlXCIsIChyZWRpcywga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCItbm9kZVwiLCByZWRpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiK25vZGVcIiwgKHJlZGlzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCIrbm9kZVwiLCByZWRpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCJub2RlRXJyb3JcIiwgKGVycm9yLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vZGUgZXJyb3JcIiwgZXJyb3IsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgQ2x1c3RlclN1YnNjcmliZXJfMS5kZWZhdWx0KHRoaXMuY29ubmVjdGlvblBvb2wsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjcmlwdHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5zY3JpcHRzKS5mb3JFYWNoKChbbmFtZSwgZGVmaW5pdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluZUNvbW1hbmQobmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhenlDb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcIndhaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW5nIGZhaWxlZDogJXNcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gYSBjbHVzdGVyXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlZGlzIGlzIGFscmVhZHkgY29ubmVjdGluZy9jb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVwb2NoID0gKyt0aGlzLmNvbm5lY3Rpb25FcG9jaDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVN0YXJ0dXBOb2RlSG9zdG5hbWVzKClcbiAgICAgICAgICAgICAgICAudGhlbigobm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uRXBvY2ggIT09IGVwb2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBjb25uZWN0aW5nIGFmdGVyIHJlc29sdmluZyBzdGFydHVwIG5vZGVzIGJlY2F1c2UgZXBvY2ggbm90IG1hdGNoOiAlZCAhPSAlZFwiLCBlcG9jaCwgdGhpcy5jb25uZWN0aW9uRXBvY2gpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLlJlZGlzRXJyb3IoXCJDb25uZWN0aW9uIGlzIGRpc2NhcmRlZCBiZWNhdXNlIGEgbmV3IGNvbm5lY3Rpb24gaXMgbWFkZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImRpc2NhcmQgY29ubmVjdGluZyBhZnRlciByZXNvbHZpbmcgc3RhcnR1cCBub2RlcyBiZWNhdXNlIHRoZSBzdGF0dXMgY2hhbmdlZCB0byAlc1wiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuUmVkaXNFcnJvcihcIkNvbm5lY3Rpb24gaXMgYWJvcnRlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChub2Rlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVPZmZsaW5lQ29tbWFuZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldE5vZGVzUmVmcmVzaEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBjbG9zZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3ModW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlUmVhZHlDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeUNoZWNrKChlcnIsIGZhaWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IGZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJSZWFkeSBjaGVjayBmYWlsZWQgKCVzKS4gUmVjb25uZWN0aW5nLi4uXCIsIGVyciB8fCBmYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbG9zZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIk5vbmUgb2Ygc3RhcnR1cCBub2RlcyBpcyBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJyZWZyZXNoXCIsIHJlZnJlc2hMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcInJlZnJlc2hcIiwgcmVmcmVzaExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCB0aGlzLmhhbmRsZUNsb3NlRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoU2xvdHNDYWNoZSgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IENsdXN0ZXJBbGxGYWlsZWRFcnJvcl8xLmRlZmF1bHQuZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZGlzXzEuZGVmYXVsdC5wcm90b3R5cGUuc2lsZW50RW1pdC5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wucmVzZXQoW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyhlcnIpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gZXZlcnkgbm9kZSBpbiB0aGUgY2x1c3Rlci5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KHJlY29ubmVjdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIGlmICghcmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCAmJiAhcmVjb25uZWN0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBkZWJ1ZyhcIkNhbmNlbGVkIHJlY29ubmVjdGluZyBhdHRlbXB0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTm9kZXNSZWZyZXNoSW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wucmVzZXQoW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aXQgdGhlIGNsdXN0ZXIgZ3JhY2VmdWxseS5cbiAgICAgKi9cbiAgICBxdWl0KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkoUHJvbWlzZS5yZXNvbHZlKFwiT0tcIiksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIHVzZSBzZXRJbW1lZGlhdGUgdG8gbWFrZSBzdXJlIFwiY2xvc2VcIiBldmVudFxuICAgICAgICAgICAgLy8gYmVpbmcgZW1pdHRlZCBhZnRlciBxdWl0KCkgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShQcm9taXNlLmFsbCh0aGlzLm5vZGVzKCkubWFwKChub2RlKSA9PiBub2RlLnF1aXQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9yIGNhdXNlZCBieSBkaXNjb25uZWN0aW5nIHNpbmNlXG4gICAgICAgICAgICAvLyB3ZSdyZSBkaXNjb25uZWN0aW5nLi4uXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09IHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiT0tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkpKS50aGVuKCgpID0+IFwiT0tcIiksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc3RhcnR1cCBub2RlcyBhbmQgb3B0aW9ucyBhcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGNsdXN0ZXIgPSBuZXcgUmVkaXMuQ2x1c3RlcihbeyBob3N0OiBcIjEyNy4wLjAuMVwiLCBwb3J0OiBcIjMwMDAxXCIgfV0pO1xuICAgICAqIHZhciBhbm90aGVyQ2x1c3RlciA9IGNsdXN0ZXIuZHVwbGljYXRlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZHVwbGljYXRlKG92ZXJyaWRlU3RhcnR1cE5vZGVzID0gW10sIG92ZXJyaWRlT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBOb2RlcyA9IG92ZXJyaWRlU3RhcnR1cE5vZGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gb3ZlcnJpZGVTdGFydHVwTm9kZXNcbiAgICAgICAgICAgIDogdGhpcy5zdGFydHVwTm9kZXMuc2xpY2UoMCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG92ZXJyaWRlT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgQ2x1c3RlcihzdGFydHVwTm9kZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbm9kZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGVcbiAgICAgKi9cbiAgICBub2Rlcyhyb2xlID0gXCJhbGxcIikge1xuICAgICAgICBpZiAocm9sZSAhPT0gXCJhbGxcIiAmJiByb2xlICE9PSBcIm1hc3RlclwiICYmIHJvbGUgIT09IFwic2xhdmVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvbGUgXCInICsgcm9sZSArICdcIi4gRXhwZWN0ZWQgXCJhbGxcIiwgXCJtYXN0ZXJcIiBvciBcInNsYXZlXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUG9vbC5nZXROb2Rlcyhyb2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBuZWVkZWQgaW4gb3JkZXIgbm90IHRvIGluc3RhbGwgYSBsaXN0ZW5lciBmb3IgZWFjaCBhdXRvIHBpcGVsaW5lXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZGVsYXlVbnRpbFJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5RGVsYXllZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgY29tbWFuZHMgcXVldWVkIGluIGF1dG9tYXRpYyBwaXBlbGluZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5vdCBhdmFpbGFibGUgKGFuZCByZXR1cm5zIDApIHVudGlsIHRoZSBjbHVzdGVyIGlzIGNvbm5lY3RlZCBhbmQgc2xvdHMgaW5mb3JtYXRpb24gaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIGdldCBhdXRvUGlwZWxpbmVRdWV1ZVNpemUoKSB7XG4gICAgICAgIGxldCBxdWV1ZWQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBpcGVsaW5lIG9mIHRoaXMuX2F1dG9QaXBlbGluZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHF1ZXVlZCArPSBwaXBlbGluZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaCB0aGUgc2xvdCBjYWNoZVxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJlZnJlc2hTbG90c0NhY2hlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWZyZXNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1JlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAoMCwgdXRpbHNfMS5zaHVmZmxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBsZXQgbGFzdE5vZGVFcnJvciA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHRyeU5vZGUoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEuZGVmYXVsdChDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMS5kZWZhdWx0LmRlZmF1bHRNZXNzYWdlLCBsYXN0Tm9kZUVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7bm9kZS5vcHRpb25zLmhvc3R9OiR7bm9kZS5vcHRpb25zLnBvcnR9YDtcbiAgICAgICAgICAgIGRlYnVnKFwiZ2V0dGluZyBzbG90IGNhY2hlIGZyb20gJXNcIiwga2V5KTtcbiAgICAgICAgICAgIF90aGlzLmdldEluZm9Gcm9tTm9kZShub2RlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyKG5ldyBFcnJvcihcIkNsdXN0ZXIgaXMgZGlzY29ubmVjdGVkLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNjb25uZWN0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcihuZXcgRXJyb3IoXCJDbHVzdGVyIGlzIGRpc2Nvbm5lY3RpbmcuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibm9kZSBlcnJvclwiLCBlcnIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIHRyeU5vZGUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWZyZXNoXCIpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5Tm9kZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQsIHN0cmVhbSwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0byA9IHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzO1xuICAgICAgICBpZiAodG8gIT09IFwibWFzdGVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tbWFuZFJlYWRPbmx5ID0gY29tbWFuZC5pc1JlYWRPbmx5IHx8XG4gICAgICAgICAgICAgICAgKCgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZC5uYW1lKSAmJiAoMCwgY29tbWFuZHNfMS5oYXNGbGFnKShjb21tYW5kLm5hbWUsIFwicmVhZG9ubHlcIikpO1xuICAgICAgICAgICAgaWYgKCFpc0NvbW1hbmRSZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHRvID0gXCJtYXN0ZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0U2xvdCA9IG5vZGUgPyBub2RlLnNsb3QgOiBjb21tYW5kLmdldFNsb3QoKTtcbiAgICAgICAgY29uc3QgdHRsID0ge307XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub2RlICYmICFSRUpFQ1RfT1ZFUldSSVRURU5fQ09NTUFORFMuaGFzKGNvbW1hbmQpKSB7XG4gICAgICAgICAgICBSRUpFQ1RfT1ZFUldSSVRURU5fQ09NTUFORFMuYWRkKGNvbW1hbmQpO1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gY29tbWFuZC5yZWplY3Q7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVHJ5ID0gdHJ5Q29ubmVjdGlvbi5iaW5kKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVyciwgdHRsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkOiBmdW5jdGlvbiAoc2xvdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbW1hbmQgJXMgaXMgbW92ZWQgdG8gJXNcIiwgY29tbWFuZC5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2xvdCA9IE51bWJlcihzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zbG90c1tzbG90XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNsb3RzW3Nsb3RdWzBdID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2xvdHNbc2xvdF0gPSBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ncm91cHNCeVNsb3Rbc2xvdF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ncm91cHNJZHNbX3RoaXMuc2xvdHNbc2xvdF0uam9pbihcIjtcIildO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvblBvb2wuZmluZE9yQ3JlYXRlKF90aGlzLm5hdE1hcHBlcihrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVmcmVzaGluZyBzbG90IGNhY2hlcy4uLiAodHJpZ2dlcmVkIGJ5IE1PVkVEIGVycm9yKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZnJlc2hTbG90c0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzazogZnVuY3Rpb24gKHNsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJjb21tYW5kICVzIGlzIHJlcXVpcmVkIHRvIGFzayAlczolc1wiLCBjb21tYW5kLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWQgPSBfdGhpcy5uYXRNYXBwZXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25Qb29sLmZpbmRPckNyZWF0ZShtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29ubmVjdGlvbihmYWxzZSwgYCR7bWFwcGVkLmhvc3R9OiR7bWFwcGVkLnBvcnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyeWFnYWluOiBwYXJ0aWFsVHJ5LFxuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyRG93bjogcGFydGlhbFRyeSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNsb3NlZDogcGFydGlhbFRyeSxcbiAgICAgICAgICAgICAgICAgICAgbWF4UmVkaXJlY3Rpb25zOiBmdW5jdGlvbiAocmVkaXJlY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoY29tbWFuZCwgcmVkaXJlY3Rpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChjb21tYW5kLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnlDb25uZWN0aW9uKCk7XG4gICAgICAgIGZ1bmN0aW9uIHRyeUNvbm5lY3Rpb24ocmFuZG9tLCBhc2tpbmcpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIkNsdXN0ZXIgaXMgZW5kZWQuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVkaXM7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBcInJlYWR5XCIgfHwgY29tbWFuZC5uYW1lID09PSBcImNsdXN0ZXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUucmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBub2RlLnJlZGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJFTlRFUl9TVUJTQ1JJQkVSX01PREVcIiwgY29tbWFuZC5uYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJFWElUX1NVQlNDUklCRVJfTU9ERVwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuc3Vic2NyaWJlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIk5vIHN1YnNjcmliZXIgZm9yIHRoZSBjbHVzdGVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0U2xvdCA9PT0gXCJudW1iZXJcIiAmJiBfdGhpcy5zbG90c1t0YXJnZXRTbG90XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVLZXlzID0gX3RoaXMuc2xvdHNbdGFyZ2V0U2xvdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gbm9kZUtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRJbnN0YW5jZUJ5S2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9IHRvKG5vZGVzLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVkaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9ICgwLCB1dGlsc18xLnNhbXBsZSkocmVkaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gbm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gKDAsIHV0aWxzXzEuc2FtcGxlKShub2RlS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IFwic2xhdmVcIiAmJiBub2RlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKG5vZGVLZXlzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGVLZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0SW5zdGFuY2VCeUtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9IF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldEluc3RhbmNlQnlLZXkoYXNraW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcy5hc2tpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiB0byA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldFNhbXBsZUluc3RhbmNlKHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0U2FtcGxlSW5zdGFuY2UoXCJhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUucmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWRpcyA9IHJlZGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWRpcykge1xuICAgICAgICAgICAgICAgIHJlZGlzLnNlbmRDb21tYW5kKGNvbW1hbmQsIHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5vcHRpb25zLmVuYWJsZU9mZmxpbmVRdWV1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZmxpbmVRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IoXCJDbHVzdGVyIGlzbid0IHJlYWR5IGFuZCBlbmFibGVPZmZsaW5lUXVldWUgb3B0aW9ucyBpcyBmYWxzZVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICB9XG4gICAgc3NjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzc2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgc3NjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzc2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaHNjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJoc2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaHNjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJoc2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgenNjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJ6c2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgenNjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJ6c2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGhhbmRsZUVycm9yKGVycm9yLCB0dGwsIGhhbmRsZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHRsLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0dGwudmFsdWUgPSB0aGlzLm9wdGlvbnMubWF4UmVkaXJlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHRsLnZhbHVlIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR0bC52YWx1ZSA8PSAwKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5tYXhSZWRpcmVjdGlvbnMobmV3IEVycm9yKFwiVG9vIG1hbnkgQ2x1c3RlciByZWRpcmVjdGlvbnMuIExhc3QgZXJyb3I6IFwiICsgZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJ2ID0gZXJyb3IubWVzc2FnZS5zcGxpdChcIiBcIik7XG4gICAgICAgIGlmIChlcnJ2WzBdID09PSBcIk1PVkVEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uTW92ZWQ7XG4gICAgICAgICAgICBpZiAodGltZW91dCAmJiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlRdWV1ZS5wdXNoKFwibW92ZWRcIiwgaGFuZGxlcnMubW92ZWQuYmluZChudWxsLCBlcnJ2WzFdLCBlcnJ2WzJdKSwgeyB0aW1lb3V0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMubW92ZWQoZXJydlsxXSwgZXJydlsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJydlswXSA9PT0gXCJBU0tcIikge1xuICAgICAgICAgICAgaGFuZGxlcnMuYXNrKGVycnZbMV0sIGVycnZbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycnZbMF0gPT09IFwiVFJZQUdBSU5cIikge1xuICAgICAgICAgICAgdGhpcy5kZWxheVF1ZXVlLnB1c2goXCJ0cnlhZ2FpblwiLCBoYW5kbGVycy50cnlhZ2Fpbiwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25UcnlBZ2FpbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycnZbMF0gPT09IFwiQ0xVU1RFUkRPV05cIiAmJlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPbkNsdXN0ZXJEb3duID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxheVF1ZXVlLnB1c2goXCJjbHVzdGVyZG93blwiLCBoYW5kbGVycy5jb25uZWN0aW9uQ2xvc2VkLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPbkNsdXN0ZXJEb3duLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLnJlZnJlc2hTbG90c0NhY2hlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvci5tZXNzYWdlID09PSB1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyAmJlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPbkZhaWxvdmVyID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwicmVhZHlcIikge1xuICAgICAgICAgICAgdGhpcy5kZWxheVF1ZXVlLnB1c2goXCJmYWlsb3ZlclwiLCBoYW5kbGVycy5jb25uZWN0aW9uQ2xvc2VkLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPbkZhaWxvdmVyLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLnJlZnJlc2hTbG90c0NhY2hlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmRlZmF1bHRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRPZmZsaW5lUXVldWUoKSB7XG4gICAgICAgIHRoaXMub2ZmbGluZVF1ZXVlID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICAgIGNsZWFyTm9kZXNSZWZyZXNoSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNsb3RzVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNsb3RzVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zbG90c1RpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldE5vZGVzUmVmcmVzaEludGVydmFsKCkge1xuICAgICAgICBpZiAodGhpcy5zbG90c1RpbWVyIHx8ICF0aGlzLm9wdGlvbnMuc2xvdHNSZWZyZXNoSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0Um91bmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNsb3RzVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygncmVmcmVzaGluZyBzbG90IGNhY2hlcy4uLiAodHJpZ2dlcmVkIGJ5IFwic2xvdHNSZWZyZXNoSW50ZXJ2YWxcIiBvcHRpb24pJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoU2xvdHNDYWNoZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRSb3VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNsb3RzUmVmcmVzaEludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dFJvdW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjbHVzdGVyIGluc3RhbmNlJ3Mgc3RhdHVzXG4gICAgICovXG4gICAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBkZWJ1ZyhcInN0YXR1czogJXMgLT4gJXNcIiwgdGhpcy5zdGF0dXMgfHwgXCJbZW1wdHldXCIsIHN0YXR1cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2xvc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSByZWNvbm5lY3Rpb24gc2hvdWxkIGJlIG1hZGVcbiAgICAgKi9cbiAgICBoYW5kbGVDbG9zZUV2ZW50KHJlYXNvbikge1xuICAgICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsb3NlZCBiZWNhdXNlICVzXCIsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5RGVsYXk7XG4gICAgICAgIGlmICghdGhpcy5tYW51YWxseUNsb3NpbmcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuY2x1c3RlclJldHJ5U3RyYXRlZ3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0cnlEZWxheSA9IHRoaXMub3B0aW9ucy5jbHVzdGVyUmV0cnlTdHJhdGVneS5jYWxsKHRoaXMsICsrdGhpcy5yZXRyeUF0dGVtcHRzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJyZWNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ2x1c3RlciBpcyBkaXNjb25uZWN0ZWQuIFJldHJ5aW5nIGFmdGVyICVkbXNcIiwgcmV0cnlEZWxheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIkdvdCBlcnJvciAlcyB3aGVuIHJlY29ubmVjdGluZy4gSWdub3JpbmcuLi5cIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHJldHJ5RGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJlbmRcIik7XG4gICAgICAgICAgICB0aGlzLmZsdXNoUXVldWUobmV3IEVycm9yKFwiTm9uZSBvZiBzdGFydHVwIG5vZGVzIGlzIGF2YWlsYWJsZVwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggb2ZmbGluZSBxdWV1ZSB3aXRoIGVycm9yLlxuICAgICAqL1xuICAgIGZsdXNoUXVldWUoZXJyb3IpIHtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIHdoaWxlICgoaXRlbSA9IHRoaXMub2ZmbGluZVF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlT2ZmbGluZUNvbW1hbmRzKCkge1xuICAgICAgICBpZiAodGhpcy5vZmZsaW5lUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlbmQgJWQgY29tbWFuZHMgaW4gb2ZmbGluZSBxdWV1ZVwiLCB0aGlzLm9mZmxpbmVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmbGluZVF1ZXVlID0gdGhpcy5vZmZsaW5lUXVldWU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0T2ZmbGluZVF1ZXVlKCk7XG4gICAgICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IG9mZmxpbmVRdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kLCBpdGVtLnN0cmVhbSwgaXRlbS5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXRNYXBwZXIobm9kZUtleSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdE1hcCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm5hdE1hcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5vZGVLZXkgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IG5vZGVLZXlcbiAgICAgICAgICAgICAgICA6IGAke25vZGVLZXkuaG9zdH06JHtub2RlS2V5LnBvcnR9YDtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRoaXMub3B0aW9ucy5uYXRNYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIk5BVCBtYXBwaW5nICVzIC0+ICVPXCIsIGtleSwgbWFwcGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWFwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGVLZXkgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gKDAsIHV0aWxfMS5ub2RlS2V5VG9SZWRpc09wdGlvbnMpKG5vZGVLZXkpXG4gICAgICAgICAgICA6IG5vZGVLZXk7XG4gICAgfVxuICAgIGdldEluZm9Gcm9tTm9kZShyZWRpcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFyZWRpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vZGUgaXMgZGlzY29ubmVjdGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYSBkdXBsaWNhdGlvbiBvZiB0aGUgY29ubmVjdGlvbiB0byBhdm9pZFxuICAgICAgICAvLyB0aW1lb3V0cyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBibG9ja2luZ1xuICAgICAgICAvLyBtb2RlIChlLmcuIHdhaXRpbmcgZm9yIEJMUE9QKS5cbiAgICAgICAgY29uc3QgZHVwbGljYXRlZENvbm5lY3Rpb24gPSByZWRpcy5kdXBsaWNhdGUoe1xuICAgICAgICAgICAgZW5hYmxlT2ZmbGluZVF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlUmVhZHlDaGVjazogZmFsc2UsXG4gICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiBudWxsLFxuICAgICAgICAgICAgY29ubmVjdGlvbk5hbWU6ICgwLCB1dGlsXzEuZ2V0Q29ubmVjdGlvbk5hbWUpKFwicmVmcmVzaGVyXCIsIHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlZGlzT3B0aW9ucy5jb25uZWN0aW9uTmFtZSksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3IgZXZlbnRzIHNpbmNlIHdlIHdpbGwgaGFuZGxlXG4gICAgICAgIC8vIGV4Y2VwdGlvbnMgZm9yIHRoZSBDTFVTVEVSIFNMT1RTIGNvbW1hbmQuXG4gICAgICAgIGR1cGxpY2F0ZWRDb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgdXRpbHNfMS5ub29wKTtcbiAgICAgICAgZHVwbGljYXRlZENvbm5lY3Rpb24uY2x1c3RlcihcIlNMT1RTXCIsICgwLCB1dGlsc18xLnRpbWVvdXQpKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgZHVwbGljYXRlZENvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImRpc2Nvbm5lY3RpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImNsb3NlXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlIENMVVNURVIuU0xPVFMgcmVzdWx0cyAoY291bnQ6ICVkKSBzaW5jZSBjbHVzdGVyIHN0YXR1cyBpcyAlc1wiLCByZXN1bHQubGVuZ3RoLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICAgICAgZGVidWcoXCJjbHVzdGVyIHNsb3RzIHJlc3VsdCBjb3VudDogJWRcIiwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gcmVzdWx0W2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3RSYW5nZVN0YXJ0ID0gaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdFJhbmdlRW5kID0gaXRlbXNbMV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tqXVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubmF0TWFwcGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGl0ZW1zW2pdWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogaXRlbXNbal1bMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlYWRPbmx5ID0gaiAhPT0gMjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKG5vZGUuaG9zdCArIFwiOlwiICsgbm9kZS5wb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjbHVzdGVyIHNsb3RzIHJlc3VsdCBbJWRdOiBzbG90cyAlZH4lZCBzZXJ2ZWQgYnkgJXNcIiwgaSwgc2xvdFJhbmdlU3RhcnQsIHNsb3RSYW5nZUVuZCwga2V5cyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2xvdCA9IHNsb3RSYW5nZVN0YXJ0OyBzbG90IDw9IHNsb3RSYW5nZUVuZDsgc2xvdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xvdHNbc2xvdF0gPSBrZXlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFzc2lnbiB0byBlYWNoIG5vZGUga2V5cyBhIG51bWVyaWMgdmFsdWUgdG8gbWFrZSBhdXRvcGlwZWxpbmUgY29tcGFyaXNvbiBmYXN0ZXIuXG4gICAgICAgICAgICB0aGlzLl9ncm91cHNJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjM4NDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKHRoaXMuc2xvdHNbaV0gfHwgW10pLmpvaW4oXCI7XCIpO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHNCeVNsb3RbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwc0lkc1t0YXJnZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0lkc1t0YXJnZXRdID0gKytqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHNCeVNsb3RbaV0gPSB0aGlzLl9ncm91cHNJZHNbdGFyZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wucmVzZXQobm9kZXMpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNsb3RzUmVmcmVzaFRpbWVvdXQpKTtcbiAgICB9XG4gICAgaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzKGVycikge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5fcmVhZHlEZWxheWVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGMsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVhZHlEZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgQ2x1c3RlciBpcyBhYmxlIHRvIHByb2Nlc3MgY29tbWFuZHNcbiAgICAgKi9cbiAgICByZWFkeUNoZWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlcihcIklORk9cIiwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSByZXMuc3BsaXQoXCJcXHJcXG5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1tpXS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSBcImNsdXN0ZXJfc3RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZmFpbFwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjbHVzdGVyIHN0YXRlIG5vdCBvayAoJXMpXCIsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZVNydihob3N0bmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlc29sdmVTcnYoaG9zdG5hbWUsIChlcnIsIHJlY29yZHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIGdyb3VwZWRSZWNvcmRzID0gKDAsIHV0aWxfMS5ncm91cFNydlJlY29yZHMpKHJlY29yZHMpLCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMoZ3JvdXBlZFJlY29yZHMpLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEpIC0gcGFyc2VJbnQoYikpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUZpcnN0T25lKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNvcnRlZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gc29ydGVkS2V5c1swXSwgZ3JvdXAgPSBncm91cGVkUmVjb3Jkc1trZXldLCByZWNvcmQgPSAoMCwgdXRpbF8xLndlaWdodFNydlJlY29yZHMpKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncm91cC5yZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkS2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG5zTG9va3VwKHJlY29yZC5uYW1lKS50aGVuKChob3N0KSA9PiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiByZWNvcmQucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSksIHRyeUZpcnN0T25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5Rmlyc3RPbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG5zTG9va3VwKGhvc3RuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZG5zTG9va3VwKGhvc3RuYW1lLCAoZXJyLCBhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byByZXNvbHZlIGhvc3RuYW1lICVzIHRvIElQOiAlc1wiLCBob3N0bmFtZSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVzb2x2ZWQgaG9zdG5hbWUgJXMgdG8gSVAgJXNcIiwgaG9zdG5hbWUsIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHN0YXJ0dXAgbm9kZXMsIGFuZCByZXNvbHZpbmcgaG9zdG5hbWVzIHRvIElQcy5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvY2VzcyBoYXBwZW5zIGV2ZXJ5IHRpbWUgd2hlbiAjY29ubmVjdCgpIGlzIGNhbGxlZCBzaW5jZVxuICAgICAqICNzdGFydHVwTm9kZXMgYW5kIEROUyByZWNvcmRzIG1heSBjaGFuYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc29sdmVTdGFydHVwTm9kZUhvc3RuYW1lcygpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuc3RhcnR1cE5vZGVzKSB8fCB0aGlzLnN0YXJ0dXBOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzdGFydHVwTm9kZXNgIHNob3VsZCBjb250YWluIGF0IGxlYXN0IG9uZSBub2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydHVwTm9kZXMgPSAoMCwgdXRpbF8xLm5vcm1hbGl6ZU5vZGVPcHRpb25zKSh0aGlzLnN0YXJ0dXBOb2Rlcyk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lcyA9ICgwLCB1dGlsXzEuZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMpKHN0YXJ0dXBOb2Rlcyk7XG4gICAgICAgIGlmIChob3N0bmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnR1cE5vZGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChob3N0bmFtZXMubWFwKCh0aGlzLm9wdGlvbnMudXNlU1JWUmVjb3JkcyA/IHRoaXMucmVzb2x2ZVNydiA6IHRoaXMuZG5zTG9va3VwKS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lVG9Db25maWcgPSAoMCwgdXRpbHNfMS56aXBNYXApKGhvc3RuYW1lcywgY29uZmlncyk7XG4gICAgICAgIHJldHVybiBzdGFydHVwTm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBob3N0bmFtZVRvQ29uZmlnLmdldChub2RlLmhvc3QpO1xuICAgICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlU1JWUmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgaG9zdDogY29uZmlnIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlU2NhblN0cmVhbShjb21tYW5kLCB7IGtleSwgb3B0aW9ucyA9IHt9IH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FuU3RyZWFtXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICByZWRpczogdGhpcyxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4oMCwgYXBwbHlNaXhpbl8xLmRlZmF1bHQpKENsdXN0ZXIsIGV2ZW50c18xLkV2ZW50RW1pdHRlcik7XG4oMCwgdHJhbnNhY3Rpb25fMS5hZGRUcmFuc2FjdGlvblN1cHBvcnQpKENsdXN0ZXIucHJvdG90eXBlKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/util.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/util.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = void 0;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction getNodeKey(node) {\n    node.port = node.port || 6379;\n    node.host = node.host || \"127.0.0.1\";\n    return node.host + \":\" + node.port;\n}\nexports.getNodeKey = getNodeKey;\nfunction nodeKeyToRedisOptions(nodeKey) {\n    const portIndex = nodeKey.lastIndexOf(\":\");\n    if (portIndex === -1) {\n        throw new Error(`Invalid node key ${nodeKey}`);\n    }\n    return {\n        host: nodeKey.slice(0, portIndex),\n        port: Number(nodeKey.slice(portIndex + 1)),\n    };\n}\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\nfunction normalizeNodeOptions(nodes) {\n    return nodes.map((node) => {\n        const options = {};\n        if (typeof node === \"object\") {\n            Object.assign(options, node);\n        }\n        else if (typeof node === \"string\") {\n            Object.assign(options, (0, utils_1.parseURL)(node));\n        }\n        else if (typeof node === \"number\") {\n            options.port = node;\n        }\n        else {\n            throw new Error(\"Invalid argument \" + node);\n        }\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        // Cluster mode only support db 0\n        delete options.db;\n        if (!options.port) {\n            options.port = 6379;\n        }\n        if (!options.host) {\n            options.host = \"127.0.0.1\";\n        }\n        return (0, utils_1.resolveTLSProfile)(options);\n    });\n}\nexports.normalizeNodeOptions = normalizeNodeOptions;\nfunction getUniqueHostnamesFromOptions(nodes) {\n    const uniqueHostsMap = {};\n    nodes.forEach((node) => {\n        uniqueHostsMap[node.host] = true;\n    });\n    return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));\n}\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;\nfunction groupSrvRecords(records) {\n    const recordsByPriority = {};\n    for (const record of records) {\n        if (!recordsByPriority.hasOwnProperty(record.priority)) {\n            recordsByPriority[record.priority] = {\n                totalWeight: record.weight,\n                records: [record],\n            };\n        }\n        else {\n            recordsByPriority[record.priority].totalWeight += record.weight;\n            recordsByPriority[record.priority].records.push(record);\n        }\n    }\n    return recordsByPriority;\n}\nexports.groupSrvRecords = groupSrvRecords;\nfunction weightSrvRecords(recordsGroup) {\n    if (recordsGroup.records.length === 1) {\n        recordsGroup.totalWeight = 0;\n        return recordsGroup.records.shift();\n    }\n    // + `recordsGroup.records.length` to support `weight` 0\n    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));\n    let total = 0;\n    for (const [i, record] of recordsGroup.records.entries()) {\n        total += 1 + record.weight;\n        if (total > random) {\n            recordsGroup.totalWeight -= record.weight;\n            recordsGroup.records.splice(i, 1);\n            return record;\n        }\n    }\n}\nexports.weightSrvRecords = weightSrvRecords;\nfunction getConnectionName(component, nodeConnectionName) {\n    const prefix = `ioredis-cluster(${component})`;\n    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;\n}\nexports.getConnectionName = getConnectionName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcscUNBQXFDLEdBQUcsNEJBQTRCLEdBQUcsNkJBQTZCLEdBQUcsa0JBQWtCO0FBQzFNLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFVO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQsbUNBQW1DLE9BQU8sR0FBRyxtQkFBbUI7QUFDaEU7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanM/NzYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbk5hbWUgPSBleHBvcnRzLndlaWdodFNydlJlY29yZHMgPSBleHBvcnRzLmdyb3VwU3J2UmVjb3JkcyA9IGV4cG9ydHMuZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMgPSBleHBvcnRzLm5vcm1hbGl6ZU5vZGVPcHRpb25zID0gZXhwb3J0cy5ub2RlS2V5VG9SZWRpc09wdGlvbnMgPSBleHBvcnRzLmdldE5vZGVLZXkgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gZ2V0Tm9kZUtleShub2RlKSB7XG4gICAgbm9kZS5wb3J0ID0gbm9kZS5wb3J0IHx8IDYzNzk7XG4gICAgbm9kZS5ob3N0ID0gbm9kZS5ob3N0IHx8IFwiMTI3LjAuMC4xXCI7XG4gICAgcmV0dXJuIG5vZGUuaG9zdCArIFwiOlwiICsgbm9kZS5wb3J0O1xufVxuZXhwb3J0cy5nZXROb2RlS2V5ID0gZ2V0Tm9kZUtleTtcbmZ1bmN0aW9uIG5vZGVLZXlUb1JlZGlzT3B0aW9ucyhub2RlS2V5KSB7XG4gICAgY29uc3QgcG9ydEluZGV4ID0gbm9kZUtleS5sYXN0SW5kZXhPZihcIjpcIik7XG4gICAgaWYgKHBvcnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5vZGUga2V5ICR7bm9kZUtleX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdDogbm9kZUtleS5zbGljZSgwLCBwb3J0SW5kZXgpLFxuICAgICAgICBwb3J0OiBOdW1iZXIobm9kZUtleS5zbGljZShwb3J0SW5kZXggKyAxKSksXG4gICAgfTtcbn1cbmV4cG9ydHMubm9kZUtleVRvUmVkaXNPcHRpb25zID0gbm9kZUtleVRvUmVkaXNPcHRpb25zO1xuZnVuY3Rpb24gbm9ybWFsaXplTm9kZU9wdGlvbnMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsICgwLCB1dGlsc18xLnBhcnNlVVJMKShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IFwiICsgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlSW50KG9wdGlvbnMucG9ydCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsdXN0ZXIgbW9kZSBvbmx5IHN1cHBvcnQgZGIgMFxuICAgICAgICBkZWxldGUgb3B0aW9ucy5kYjtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IDYzNzk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmhvc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IFwiMTI3LjAuMC4xXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnJlc29sdmVUTFNQcm9maWxlKShvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubm9ybWFsaXplTm9kZU9wdGlvbnMgPSBub3JtYWxpemVOb2RlT3B0aW9ucztcbmZ1bmN0aW9uIGdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zKG5vZGVzKSB7XG4gICAgY29uc3QgdW5pcXVlSG9zdHNNYXAgPSB7fTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHVuaXF1ZUhvc3RzTWFwW25vZGUuaG9zdF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh1bmlxdWVIb3N0c01hcCkuZmlsdGVyKChob3N0KSA9PiAhKDAsIG5ldF8xLmlzSVApKGhvc3QpKTtcbn1cbmV4cG9ydHMuZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMgPSBnZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucztcbmZ1bmN0aW9uIGdyb3VwU3J2UmVjb3JkcyhyZWNvcmRzKSB7XG4gICAgY29uc3QgcmVjb3Jkc0J5UHJpb3JpdHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgIGlmICghcmVjb3Jkc0J5UHJpb3JpdHkuaGFzT3duUHJvcGVydHkocmVjb3JkLnByaW9yaXR5KSkge1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XSA9IHtcbiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodDogcmVjb3JkLndlaWdodCxcbiAgICAgICAgICAgICAgICByZWNvcmRzOiBbcmVjb3JkXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRzQnlQcmlvcml0eVtyZWNvcmQucHJpb3JpdHldLnRvdGFsV2VpZ2h0ICs9IHJlY29yZC53ZWlnaHQ7XG4gICAgICAgICAgICByZWNvcmRzQnlQcmlvcml0eVtyZWNvcmQucHJpb3JpdHldLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzQnlQcmlvcml0eTtcbn1cbmV4cG9ydHMuZ3JvdXBTcnZSZWNvcmRzID0gZ3JvdXBTcnZSZWNvcmRzO1xuZnVuY3Rpb24gd2VpZ2h0U3J2UmVjb3JkcyhyZWNvcmRzR3JvdXApIHtcbiAgICBpZiAocmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlY29yZHNHcm91cC50b3RhbFdlaWdodCA9IDA7XG4gICAgICAgIHJldHVybiByZWNvcmRzR3JvdXAucmVjb3Jkcy5zaGlmdCgpO1xuICAgIH1cbiAgICAvLyArIGByZWNvcmRzR3JvdXAucmVjb3Jkcy5sZW5ndGhgIHRvIHN1cHBvcnQgYHdlaWdodGAgMFxuICAgIGNvbnN0IHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChyZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgKyByZWNvcmRzR3JvdXAucmVjb3Jkcy5sZW5ndGgpKTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgW2ksIHJlY29yZF0gb2YgcmVjb3Jkc0dyb3VwLnJlY29yZHMuZW50cmllcygpKSB7XG4gICAgICAgIHRvdGFsICs9IDEgKyByZWNvcmQud2VpZ2h0O1xuICAgICAgICBpZiAodG90YWwgPiByYW5kb20pIHtcbiAgICAgICAgICAgIHJlY29yZHNHcm91cC50b3RhbFdlaWdodCAtPSByZWNvcmQud2VpZ2h0O1xuICAgICAgICAgICAgcmVjb3Jkc0dyb3VwLnJlY29yZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMud2VpZ2h0U3J2UmVjb3JkcyA9IHdlaWdodFNydlJlY29yZHM7XG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uTmFtZShjb21wb25lbnQsIG5vZGVDb25uZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IGBpb3JlZGlzLWNsdXN0ZXIoJHtjb21wb25lbnR9KWA7XG4gICAgcmV0dXJuIG5vZGVDb25uZWN0aW9uTmFtZSA/IGAke3ByZWZpeH06JHtub2RlQ29ubmVjdGlvbk5hbWV9YCA6IHByZWZpeDtcbn1cbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbk5hbWUgPSBnZXRDb25uZWN0aW9uTmFtZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/AbstractConnector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"AbstractConnector\");\nclass AbstractConnector {\n    constructor(disconnectTimeout) {\n        this.connecting = false;\n        this.disconnectTimeout = disconnectTimeout;\n    }\n    check(info) {\n        return true;\n    }\n    disconnect() {\n        this.connecting = false;\n        if (this.stream) {\n            const stream = this.stream; // Make sure callbacks refer to the same instance\n            const timeout = setTimeout(() => {\n                debug(\"stream %s:%s still open, destroying it\", stream.remoteAddress, stream.remotePort);\n                stream.destroy();\n            }, this.disconnectTimeout);\n            stream.on(\"close\", () => clearTimeout(timeout));\n            stream.end();\n        }\n    }\n}\nexports[\"default\"] = AbstractConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL0Fic3RyYWN0Q29ubmVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLG1FQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9BYnN0cmFjdENvbm5lY3Rvci5qcz84MDZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IoZGlzY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFRpbWVvdXQgPSBkaXNjb25uZWN0VGltZW91dDtcbiAgICB9XG4gICAgY2hlY2soaW5mbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW07IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVmZXIgdG8gdGhlIHNhbWUgaW5zdGFuY2VcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN0cmVhbSAlczolcyBzdGlsbCBvcGVuLCBkZXN0cm95aW5nIGl0XCIsIHN0cmVhbS5yZW1vdGVBZGRyZXNzLCBzdHJlYW0ucmVtb3RlUG9ydCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0sIHRoaXMuZGlzY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgc3RyZWFtLm9uKFwiY2xvc2VcIiwgKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0Q29ubmVjdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FailoverDetector = void 0;\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"FailoverDetector\");\nconst CHANNEL_NAME = \"+switch-master\";\nclass FailoverDetector {\n    // sentinels can't be used for regular commands after this\n    constructor(connector, sentinels) {\n        this.isDisconnected = false;\n        this.connector = connector;\n        this.sentinels = sentinels;\n    }\n    cleanup() {\n        this.isDisconnected = true;\n        for (const sentinel of this.sentinels) {\n            sentinel.client.disconnect();\n        }\n    }\n    async subscribe() {\n        debug(\"Starting FailoverDetector\");\n        const promises = [];\n        for (const sentinel of this.sentinels) {\n            const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {\n                debug(\"Failed to subscribe to failover messages on sentinel %s:%s (%s)\", sentinel.address.host || \"127.0.0.1\", sentinel.address.port || 26739, err.message);\n            });\n            promises.push(promise);\n            sentinel.client.on(\"message\", (channel) => {\n                if (!this.isDisconnected && channel === CHANNEL_NAME) {\n                    this.disconnect();\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    disconnect() {\n        // Avoid disconnecting more than once per failover.\n        // A new FailoverDetector will be created after reconnecting.\n        this.isDisconnected = true;\n        debug(\"Failover detected, disconnecting\");\n        // Will call this.cleanup()\n        this.connector.disconnect();\n    }\n}\nexports.FailoverDetector = FailoverDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL0ZhaWxvdmVyRGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvRmFpbG92ZXJEZXRlY3Rvci5qcz84MmU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYWlsb3ZlckRldGVjdG9yID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiRmFpbG92ZXJEZXRlY3RvclwiKTtcbmNvbnN0IENIQU5ORUxfTkFNRSA9IFwiK3N3aXRjaC1tYXN0ZXJcIjtcbmNsYXNzIEZhaWxvdmVyRGV0ZWN0b3Ige1xuICAgIC8vIHNlbnRpbmVscyBjYW4ndCBiZSB1c2VkIGZvciByZWd1bGFyIGNvbW1hbmRzIGFmdGVyIHRoaXNcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0b3IsIHNlbnRpbmVscykge1xuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgICAgICB0aGlzLnNlbnRpbmVscyA9IHNlbnRpbmVscztcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgc2VudGluZWwgb2YgdGhpcy5zZW50aW5lbHMpIHtcbiAgICAgICAgICAgIHNlbnRpbmVsLmNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlKCkge1xuICAgICAgICBkZWJ1ZyhcIlN0YXJ0aW5nIEZhaWxvdmVyRGV0ZWN0b3JcIik7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VudGluZWwgb2YgdGhpcy5zZW50aW5lbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzZW50aW5lbC5jbGllbnQuc3Vic2NyaWJlKENIQU5ORUxfTkFNRSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiRmFpbGVkIHRvIHN1YnNjcmliZSB0byBmYWlsb3ZlciBtZXNzYWdlcyBvbiBzZW50aW5lbCAlczolcyAoJXMpXCIsIHNlbnRpbmVsLmFkZHJlc3MuaG9zdCB8fCBcIjEyNy4wLjAuMVwiLCBzZW50aW5lbC5hZGRyZXNzLnBvcnQgfHwgMjY3MzksIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIHNlbnRpbmVsLmNsaWVudC5vbihcIm1lc3NhZ2VcIiwgKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNjb25uZWN0ZWQgJiYgY2hhbm5lbCA9PT0gQ0hBTk5FTF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgLy8gQXZvaWQgZGlzY29ubmVjdGluZyBtb3JlIHRoYW4gb25jZSBwZXIgZmFpbG92ZXIuXG4gICAgICAgIC8vIEEgbmV3IEZhaWxvdmVyRGV0ZWN0b3Igd2lsbCBiZSBjcmVhdGVkIGFmdGVyIHJlY29ubmVjdGluZy5cbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGRlYnVnKFwiRmFpbG92ZXIgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIC8vIFdpbGwgY2FsbCB0aGlzLmNsZWFudXAoKVxuICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5GYWlsb3ZlckRldGVjdG9yID0gRmFpbG92ZXJEZXRlY3RvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction isSentinelEql(a, b) {\n    return ((a.host || \"127.0.0.1\") === (b.host || \"127.0.0.1\") &&\n        (a.port || 26379) === (b.port || 26379));\n}\nclass SentinelIterator {\n    constructor(sentinels) {\n        this.cursor = 0;\n        this.sentinels = sentinels.slice(0);\n    }\n    next() {\n        const done = this.cursor >= this.sentinels.length;\n        return { done, value: done ? undefined : this.sentinels[this.cursor++] };\n    }\n    reset(moveCurrentEndpointToFirst) {\n        if (moveCurrentEndpointToFirst &&\n            this.sentinels.length > 1 &&\n            this.cursor !== 1) {\n            this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));\n        }\n        this.cursor = 0;\n    }\n    add(sentinel) {\n        for (let i = 0; i < this.sentinels.length; i++) {\n            if (isSentinelEql(sentinel, this.sentinels[i])) {\n                return false;\n            }\n        }\n        this.sentinels.push(sentinel);\n        return true;\n    }\n    toString() {\n        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;\n    }\n}\nexports[\"default\"] = SentinelIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL1NlbnRpbmVsSXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0MsR0FBRyxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvU2VudGluZWxJdGVyYXRvci5qcz8wNDA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNTZW50aW5lbEVxbChhLCBiKSB7XG4gICAgcmV0dXJuICgoYS5ob3N0IHx8IFwiMTI3LjAuMC4xXCIpID09PSAoYi5ob3N0IHx8IFwiMTI3LjAuMC4xXCIpICYmXG4gICAgICAgIChhLnBvcnQgfHwgMjYzNzkpID09PSAoYi5wb3J0IHx8IDI2Mzc5KSk7XG59XG5jbGFzcyBTZW50aW5lbEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzZW50aW5lbHMpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICB0aGlzLnNlbnRpbmVscyA9IHNlbnRpbmVscy5zbGljZSgwKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IHRoaXMuY3Vyc29yID49IHRoaXMuc2VudGluZWxzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgZG9uZSwgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLnNlbnRpbmVsc1t0aGlzLmN1cnNvcisrXSB9O1xuICAgIH1cbiAgICByZXNldChtb3ZlQ3VycmVudEVuZHBvaW50VG9GaXJzdCkge1xuICAgICAgICBpZiAobW92ZUN1cnJlbnRFbmRwb2ludFRvRmlyc3QgJiZcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVscy51bnNoaWZ0KC4uLnRoaXMuc2VudGluZWxzLnNwbGljZSh0aGlzLmN1cnNvciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgfVxuICAgIGFkZChzZW50aW5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VudGluZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNTZW50aW5lbEVxbChzZW50aW5lbCwgdGhpcy5zZW50aW5lbHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudGluZWxzLnB1c2goc2VudGluZWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeSh0aGlzLnNlbnRpbmVscyl9IEAke3RoaXMuY3Vyc29yfWA7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2VudGluZWxJdGVyYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SentinelIterator = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst SentinelIterator_1 = __webpack_require__(/*! ./SentinelIterator */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = __webpack_require__(/*! ../AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nconst Redis_1 = __webpack_require__(/*! ../../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst FailoverDetector_1 = __webpack_require__(/*! ./FailoverDetector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n        this.emitter = null;\n        this.failoverDetector = null;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    disconnect() {\n        super.disconnect();\n        if (this.failoverDetector) {\n            this.failoverDetector.cleanup();\n        }\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = async () => {\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\"\n                    ? this.options.sentinelRetryStrategy(++this.retryAttempts)\n                    : null;\n                let errorMsg = typeof retryDelay !== \"number\"\n                    ? \"All sentinels are unreachable and retry is disabled.\"\n                    : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    eventEmitter(\"error\", error);\n                    await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                    return connectToNext();\n                }\n                else {\n                    throw error;\n                }\n            }\n            let resolved = null;\n            let err = null;\n            try {\n                resolved = await this.resolve(endpoint.value);\n            }\n            catch (error) {\n                err = error;\n            }\n            if (!this.connecting) {\n                throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n            }\n            const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n            if (resolved) {\n                debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n                if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                    Object.assign(resolved, this.options.tls);\n                    this.stream = (0, tls_1.connect)(resolved);\n                    this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n                }\n                else {\n                    this.stream = (0, net_1.createConnection)(resolved);\n                    this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                return this.stream;\n            }\n            else {\n                const errorMsg = err\n                    ? \"failed to connect to sentinel \" +\n                        endpointAddress +\n                        \" because \" +\n                        err.message\n                    : \"connected to sentinel \" +\n                        endpointAddress +\n                        \" successfully, but got an invalid reply: \" +\n                        resolved;\n                debug(errorMsg);\n                eventEmitter(\"sentinelError\", new Error(errorMsg));\n                if (err) {\n                    lastError = err;\n                }\n                return connectToNext();\n            }\n        };\n        return connectToNext();\n    }\n    async updateSentinels(client) {\n        if (!this.options.updateSentinels) {\n            return;\n        }\n        const result = await client.sentinel(\"sentinels\", this.options.name);\n        if (!Array.isArray(result)) {\n            return;\n        }\n        result\n            .map(utils_1.packObject)\n            .forEach((sentinel) => {\n            const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n            if (flags.indexOf(\"disconnected\") === -1 &&\n                sentinel.ip &&\n                sentinel.port) {\n                const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                if (this.sentinelIterator.add(endpoint)) {\n                    debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                }\n            }\n        });\n        debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n    }\n    async resolveMaster(client) {\n        const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n        await this.updateSentinels(client);\n        return this.sentinelNatResolve(Array.isArray(result)\n            ? { host: result[0], port: Number(result[1]) }\n            : null);\n    }\n    async resolveSlave(client) {\n        const result = await client.sentinel(\"slaves\", this.options.name);\n        if (!Array.isArray(result)) {\n            return null;\n        }\n        const availableSlaves = result\n            .map(utils_1.packObject)\n            .filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap)\n            return item;\n        return this.options.natMap[`${item.host}:${item.port}`] || item;\n    }\n    connectToSentinel(endpoint, options) {\n        const redis = new Redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            username: this.options.sentinelUsername || null,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family ||\n                // @ts-expect-error\n                (\"path\" in this.options && this.options.path\n                    ? undefined\n                    : // @ts-expect-error\n                        this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            commandTimeout: this.options.sentinelCommandTimeout,\n            ...options,\n        });\n        // @ts-expect-error\n        return redis;\n    }\n    async resolve(endpoint) {\n        const client = this.connectToSentinel(endpoint);\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        try {\n            if (this.options.role === \"slave\") {\n                return await this.resolveSlave(client);\n            }\n            else {\n                return await this.resolveMaster(client);\n            }\n        }\n        finally {\n            client.disconnect();\n        }\n    }\n    async initFailoverDetector() {\n        var _a;\n        if (!this.options.failoverDetector) {\n            return;\n        }\n        // Move the current sentinel to the first position\n        this.sentinelIterator.reset(true);\n        const sentinels = [];\n        // In case of a large amount of sentinels, limit the number of concurrent connections\n        while (sentinels.length < this.options.sentinelMaxConnections) {\n            const { done, value } = this.sentinelIterator.next();\n            if (done) {\n                break;\n            }\n            const client = this.connectToSentinel(value, {\n                lazyConnect: true,\n                retryStrategy: this.options.sentinelReconnectStrategy,\n            });\n            client.on(\"reconnecting\", () => {\n                var _a;\n                // Tests listen to this event\n                (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n            });\n            sentinels.push({ address: value, client });\n        }\n        this.sentinelIterator.reset(false);\n        if (this.failoverDetector) {\n            // Clean up previous detector\n            this.failoverDetector.cleanup();\n        }\n        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n        await this.failoverDetector.subscribe();\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n    }\n}\nexports[\"default\"] = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    }\n    else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves)\n            ? preferredSlaves\n            : [preferredSlaves];\n        // sort by priority\n        preferredSlavesArray.sort((a, b) => {\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for (let p = 0; p < preferredSlavesArray.length; p++) {\n            for (let a = 0; a < availableSlaves.length; a++) {\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = (0, utils_1.sample)(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return { host: input.ip, port: Number(input.port) };\n}\nfunction noop() { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDJCQUEyQixtQkFBTyxDQUFDLCtHQUFvQjtBQUN2RCx3QkFBd0I7QUFDeEIsNEJBQTRCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzFELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3JDLDJCQUEyQixtQkFBTyxDQUFDLCtHQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVc7QUFDL0Y7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pELDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9pbmRleC5qcz9kYjVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW50aW5lbEl0ZXJhdG9yID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IFNlbnRpbmVsSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1NlbnRpbmVsSXRlcmF0b3JcIik7XG5leHBvcnRzLlNlbnRpbmVsSXRlcmF0b3IgPSBTZW50aW5lbEl0ZXJhdG9yXzEuZGVmYXVsdDtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uLy4uL1JlZGlzXCIpO1xuY29uc3QgRmFpbG92ZXJEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4vRmFpbG92ZXJEZXRlY3RvclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiU2VudGluZWxDb25uZWN0b3JcIik7XG5jbGFzcyBTZW50aW5lbENvbm5lY3RvciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdG9yXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRpc2Nvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VudGluZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZXMgYXQgbGVhc3Qgb25lIHNlbnRpbmVsIHRvIGNvbm5lY3QgdG8uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVzIHRoZSBuYW1lIG9mIG1hc3Rlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yID0gbmV3IFNlbnRpbmVsSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3B0aW9ucy5zZW50aW5lbHMpO1xuICAgIH1cbiAgICBjaGVjayhpbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvbGVNYXRjaGVzID0gIWluZm8ucm9sZSB8fCB0aGlzLm9wdGlvbnMucm9sZSA9PT0gaW5mby5yb2xlO1xuICAgICAgICBpZiAoIXJvbGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJvbGUgaW52YWxpZCwgZXhwZWN0ZWQgJXMsIGJ1dCBnb3QgJXNcIiwgdGhpcy5vcHRpb25zLnJvbGUsIGluZm8ucm9sZSk7XG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGl0ZW0uXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYHJlc2V0YCB3aWxsIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIHNvIHdlIGFkdmFuY2UgdHdvIHN0ZXBzIGhlcmUuXG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9sZU1hdGNoZXM7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuZmFpbG92ZXJEZXRlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KGV2ZW50RW1pdHRlcikge1xuICAgICAgICB0aGlzLmNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICBjb25zdCBjb25uZWN0VG9OZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNlbnRpbmVsUmV0cnlTdHJhdGVneSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNlbnRpbmVsUmV0cnlTdHJhdGVneSgrK3RoaXMucmV0cnlBdHRlbXB0cylcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IHR5cGVvZiByZXRyeURlbGF5ICE9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gXCJBbGwgc2VudGluZWxzIGFyZSB1bnJlYWNoYWJsZSBhbmQgcmV0cnkgaXMgZGlzYWJsZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgOiBgQWxsIHNlbnRpbmVscyBhcmUgdW5yZWFjaGFibGUuIFJldHJ5aW5nIGZyb20gc2NyYXRjaCBhZnRlciAke3JldHJ5RGVsYXl9bXMuYDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9IGAgTGFzdCBlcnJvcjogJHtsYXN0RXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RUb05leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZXJyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLnJlc29sdmUoZW5kcG9pbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludEFkZHJlc3MgPSBlbmRwb2ludC52YWx1ZS5ob3N0ICsgXCI6XCIgKyBlbmRwb2ludC52YWx1ZS5wb3J0O1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJyZXNvbHZlZDogJXM6JXMgZnJvbSBzZW50aW5lbCAlc1wiLCByZXNvbHZlZC5ob3N0LCByZXNvbHZlZC5wb3J0LCBlbmRwb2ludEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlVExTRm9yU2VudGluZWxNb2RlICYmIHRoaXMub3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXNvbHZlZCwgdGhpcy5vcHRpb25zLnRscyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIHRsc18xLmNvbm5lY3QpKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcInNlY3VyZUNvbm5lY3RcIiwgdGhpcy5pbml0RmFpbG92ZXJEZXRlY3Rvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIG5ldF8xLmNyZWF0ZUNvbm5lY3Rpb24pKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcImNvbm5lY3RcIiwgdGhpcy5pbml0RmFpbG92ZXJEZXRlY3Rvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyXG4gICAgICAgICAgICAgICAgICAgID8gXCJmYWlsZWQgdG8gY29ubmVjdCB0byBzZW50aW5lbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICA6IFwiY29ubmVjdGVkIHRvIHNlbnRpbmVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBzdWNjZXNzZnVsbHksIGJ1dCBnb3QgYW4gaW52YWxpZCByZXBseTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgZGVidWcoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlcihcInNlbnRpbmVsRXJyb3JcIiwgbmV3IEVycm9yKGVycm9yTXNnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0VG9OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25uZWN0VG9OZXh0KCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVNlbnRpbmVscyhjbGllbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlU2VudGluZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbnRpbmVsKFwic2VudGluZWxzXCIsIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIC5tYXAodXRpbHNfMS5wYWNrT2JqZWN0KVxuICAgICAgICAgICAgLmZvckVhY2goKHNlbnRpbmVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHNlbnRpbmVsLmZsYWdzID8gc2VudGluZWwuZmxhZ3Muc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZihcImRpc2Nvbm5lY3RlZFwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBzZW50aW5lbC5pcCAmJlxuICAgICAgICAgICAgICAgIHNlbnRpbmVsLnBvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuc2VudGluZWxOYXRSZXNvbHZlKGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhzZW50aW5lbCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbnRpbmVsSXRlcmF0b3IuYWRkKGVuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImFkZGluZyBzZW50aW5lbCAlczolc1wiLCBlbmRwb2ludC5ob3N0LCBlbmRwb2ludC5wb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcIlVwZGF0ZWQgaW50ZXJuYWwgc2VudGluZWxzOiAlc1wiLCB0aGlzLnNlbnRpbmVsSXRlcmF0b3IpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTWFzdGVyKGNsaWVudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuc2VudGluZWwoXCJnZXQtbWFzdGVyLWFkZHItYnktbmFtZVwiLCB0aGlzLm9wdGlvbnMubmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlU2VudGluZWxzKGNsaWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbnRpbmVsTmF0UmVzb2x2ZShBcnJheS5pc0FycmF5KHJlc3VsdClcbiAgICAgICAgICAgID8geyBob3N0OiByZXN1bHRbMF0sIHBvcnQ6IE51bWJlcihyZXN1bHRbMV0pIH1cbiAgICAgICAgICAgIDogbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVTbGF2ZShjbGllbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbnRpbmVsKFwic2xhdmVzXCIsIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNsYXZlcyA9IHJlc3VsdFxuICAgICAgICAgICAgLm1hcCh1dGlsc18xLnBhY2tPYmplY3QpXG4gICAgICAgICAgICAuZmlsdGVyKChzbGF2ZSkgPT4gc2xhdmUuZmxhZ3MgJiYgIXNsYXZlLmZsYWdzLm1hdGNoKC8oZGlzY29ubmVjdGVkfHNfZG93bnxvX2Rvd24pLykpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW50aW5lbE5hdFJlc29sdmUoc2VsZWN0UHJlZmVycmVkU2VudGluZWwoYXZhaWxhYmxlU2xhdmVzLCB0aGlzLm9wdGlvbnMucHJlZmVycmVkU2xhdmVzKSk7XG4gICAgfVxuICAgIHNlbnRpbmVsTmF0UmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSB8fCAhdGhpcy5vcHRpb25zLm5hdE1hcClcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hdE1hcFtgJHtpdGVtLmhvc3R9OiR7aXRlbS5wb3J0fWBdIHx8IGl0ZW07XG4gICAgfVxuICAgIGNvbm5lY3RUb1NlbnRpbmVsKGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBwb3J0OiBlbmRwb2ludC5wb3J0IHx8IDI2Mzc5LFxuICAgICAgICAgICAgaG9zdDogZW5kcG9pbnQuaG9zdCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLm9wdGlvbnMuc2VudGluZWxVc2VybmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMub3B0aW9ucy5zZW50aW5lbFBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICBmYW1pbHk6IGVuZHBvaW50LmZhbWlseSB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAoXCJwYXRoXCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYXRoXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZhbWlseSksXG4gICAgICAgICAgICB0bHM6IHRoaXMub3B0aW9ucy5zZW50aW5lbFRMUyxcbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiB0aGlzLm9wdGlvbnMuY29ubmVjdFRpbWVvdXQsXG4gICAgICAgICAgICBjb21tYW5kVGltZW91dDogdGhpcy5vcHRpb25zLnNlbnRpbmVsQ29tbWFuZFRpbWVvdXQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm4gcmVkaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUoZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0VG9TZW50aW5lbChlbmRwb2ludCk7XG4gICAgICAgIC8vIGlnbm9yZSB0aGUgZXJyb3JzIHNpbmNlIHJlc29sdmUqIG1ldGhvZHMgd2lsbCBoYW5kbGUgdGhlbVxuICAgICAgICBjbGllbnQub24oXCJlcnJvclwiLCBub29wKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm9sZSA9PT0gXCJzbGF2ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZVNsYXZlKGNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXNvbHZlTWFzdGVyKGNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRGYWlsb3ZlckRldGVjdG9yKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZhaWxvdmVyRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlIHRoZSBjdXJyZW50IHNlbnRpbmVsIHRvIHRoZSBmaXJzdCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNlbnRpbmVscyA9IFtdO1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGEgbGFyZ2UgYW1vdW50IG9mIHNlbnRpbmVscywgbGltaXQgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IGNvbm5lY3Rpb25zXG4gICAgICAgIHdoaWxlIChzZW50aW5lbHMubGVuZ3RoIDwgdGhpcy5vcHRpb25zLnNlbnRpbmVsTWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHRoaXMuc2VudGluZWxJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0VG9TZW50aW5lbCh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIGxhenlDb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IHRoaXMub3B0aW9ucy5zZW50aW5lbFJlY29ubmVjdFN0cmF0ZWd5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGllbnQub24oXCJyZWNvbm5lY3RpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBUZXN0cyBsaXN0ZW4gdG8gdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZW1pdHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJzZW50aW5lbFJlY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VudGluZWxzLnB1c2goeyBhZGRyZXNzOiB2YWx1ZSwgY2xpZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmZhaWxvdmVyRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHByZXZpb3VzIGRldGVjdG9yXG4gICAgICAgICAgICB0aGlzLmZhaWxvdmVyRGV0ZWN0b3IuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFpbG92ZXJEZXRlY3RvciA9IG5ldyBGYWlsb3ZlckRldGVjdG9yXzEuRmFpbG92ZXJEZXRlY3Rvcih0aGlzLCBzZW50aW5lbHMpO1xuICAgICAgICBhd2FpdCB0aGlzLmZhaWxvdmVyRGV0ZWN0b3Iuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIFRlc3RzIGxpc3RlbiB0byB0aGlzIGV2ZW50XG4gICAgICAgIChfYSA9IHRoaXMuZW1pdHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJmYWlsb3ZlclN1YnNjcmliZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2VudGluZWxDb25uZWN0b3I7XG5mdW5jdGlvbiBzZWxlY3RQcmVmZXJyZWRTZW50aW5lbChhdmFpbGFibGVTbGF2ZXMsIHByZWZlcnJlZFNsYXZlcykge1xuICAgIGlmIChhdmFpbGFibGVTbGF2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRTbGF2ZTtcbiAgICBpZiAodHlwZW9mIHByZWZlcnJlZFNsYXZlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNlbGVjdGVkU2xhdmUgPSBwcmVmZXJyZWRTbGF2ZXMoYXZhaWxhYmxlU2xhdmVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlZmVycmVkU2xhdmVzICE9PSBudWxsICYmIHR5cGVvZiBwcmVmZXJyZWRTbGF2ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcHJlZmVycmVkU2xhdmVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByZWZlcnJlZFNsYXZlcylcbiAgICAgICAgICAgID8gcHJlZmVycmVkU2xhdmVzXG4gICAgICAgICAgICA6IFtwcmVmZXJyZWRTbGF2ZXNdO1xuICAgICAgICAvLyBzb3J0IGJ5IHByaW9yaXR5XG4gICAgICAgIHByZWZlcnJlZFNsYXZlc0FycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdGhlIHByaW9yaXR5IHRvIDFcbiAgICAgICAgICAgIGlmICghYS5wcmlvKSB7XG4gICAgICAgICAgICAgICAgYS5wcmlvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYi5wcmlvKSB7XG4gICAgICAgICAgICAgICAgYi5wcmlvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvd2VzdCBwcmlvcml0eSBmaXJzdFxuICAgICAgICAgICAgaWYgKGEucHJpbyA8IGIucHJpbykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLnByaW8gPiBiLnByaW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIHByZWZlcnJlZCBzbGF2ZXMgYW5kIHJldHVybiB0aGUgZmlyc3QgbWF0Y2hcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwcmVmZXJyZWRTbGF2ZXNBcnJheS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdmFpbGFibGVTbGF2ZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGF2ZSA9IGF2YWlsYWJsZVNsYXZlc1thXTtcbiAgICAgICAgICAgICAgICBpZiAoc2xhdmUuaXAgPT09IHByZWZlcnJlZFNsYXZlc0FycmF5W3BdLmlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGF2ZS5wb3J0ID09PSBwcmVmZXJyZWRTbGF2ZXNBcnJheVtwXS5wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFNsYXZlID0gc2xhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFNsYXZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm9uZSBvZiB0aGUgcHJlZmVycmVkIHNsYXZlcyBhcmUgYXZhaWxhYmxlLCBhIHJhbmRvbSBhdmFpbGFibGUgc2xhdmUgaXMgcmV0dXJuZWRcbiAgICBpZiAoIXNlbGVjdGVkU2xhdmUpIHtcbiAgICAgICAgc2VsZWN0ZWRTbGF2ZSA9ICgwLCB1dGlsc18xLnNhbXBsZSkoYXZhaWxhYmxlU2xhdmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhzZWxlY3RlZFNsYXZlKTtcbn1cbmZ1bmN0aW9uIGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhpbnB1dCkge1xuICAgIHJldHVybiB7IGhvc3Q6IGlucHV0LmlwLCBwb3J0OiBOdW1iZXIoaW5wdXQucG9ydCkgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/StandaloneConnector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst AbstractConnector_1 = __webpack_require__(/*! ./AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (\"path\" in options && options.path) {\n            connectionOptions = {\n                path: options.path,\n            };\n        }\n        else {\n            connectionOptions = {};\n            if (\"port\" in options && options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (\"host\" in options && options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (\"family\" in options && options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = (0, tls_1.connect)(connectionOptions);\n                    }\n                    else {\n                        this.stream = (0, net_1.createConnection)(connectionOptions);\n                    }\n                }\n                catch (err) {\n                    reject(err);\n                    return;\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports[\"default\"] = StandaloneConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1N0YW5kYWxvbmVDb25uZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQywrRkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU3RhbmRhbG9uZUNvbm5lY3Rvci5qcz8yNmMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENvbm5lY3RvclwiKTtcbmNsYXNzIFN0YW5kYWxvbmVDb25uZWN0b3IgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rvcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kaXNjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGNvbm5lY3QoXykge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIGxldCBjb25uZWN0aW9uT3B0aW9ucztcbiAgICAgICAgaWYgKFwicGF0aFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChcInBvcnRcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImhvc3RcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImZhbWlseVwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5mYW1pbHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmZhbWlseSA9IG9wdGlvbnMuZmFtaWx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRscykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uT3B0aW9ucywgb3B0aW9ucy50bHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIC8vIFdlIHVzZSBuYXRpdmUgUHJvbWlzZSBoZXJlIHNpbmNlIG90aGVyIFByb21pc2VcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gbWF5IHVzZSBkaWZmZXJlbnQgc2NoZWR1bGVycyB0aGF0XG4gICAgICAgIC8vIGNhdXNlIGlzc3VlIHdoZW4gdGhlIHN0cmVhbSBpcyByZXNvbHZlZCBpbiB0aGVcbiAgICAgICAgLy8gbmV4dCB0aWNrLlxuICAgICAgICAvLyBTaG91bGQgdXNlIHRoZSBwcm92aWRlZCBwcm9taXNlIGluIHRoZSBuZXh0IG1ham9yXG4gICAgICAgIC8vIHZlcnNpb24gYW5kIGRvIG5vdCBjb25uZWN0IGJlZm9yZSByZXNvbHZlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIHRsc18xLmNvbm5lY3QpKGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIG5ldF8xLmNyZWF0ZUNvbm5lY3Rpb24pKGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFsb25lQ29ubmVjdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SentinelConnector = exports.StandaloneConnector = void 0;\nconst StandaloneConnector_1 = __webpack_require__(/*! ./StandaloneConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\");\nexports.StandaloneConnector = StandaloneConnector_1.default;\nconst SentinelConnector_1 = __webpack_require__(/*! ./SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nexports.SentinelConnector = SentinelConnector_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDJCQUEyQjtBQUN2RCw4QkFBOEIsbUJBQU8sQ0FBQyxtR0FBdUI7QUFDN0QsMkJBQTJCO0FBQzNCLDRCQUE0QixtQkFBTyxDQUFDLHFHQUFxQjtBQUN6RCx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL2luZGV4LmpzP2RlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlbnRpbmVsQ29ubmVjdG9yID0gZXhwb3J0cy5TdGFuZGFsb25lQ29ubmVjdG9yID0gdm9pZCAwO1xuY29uc3QgU3RhbmRhbG9uZUNvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vU3RhbmRhbG9uZUNvbm5lY3RvclwiKTtcbmV4cG9ydHMuU3RhbmRhbG9uZUNvbm5lY3RvciA9IFN0YW5kYWxvbmVDb25uZWN0b3JfMS5kZWZhdWx0O1xuY29uc3QgU2VudGluZWxDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL1NlbnRpbmVsQ29ubmVjdG9yXCIpO1xuZXhwb3J0cy5TZW50aW5lbENvbm5lY3RvciA9IFNlbnRpbmVsQ29ubmVjdG9yXzEuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js":
/*!*************************************************************!*\
  !*** ./node_modules/ioredis/built/constants/TLSProfiles.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * TLS settings for Redis Cloud. Updated on 2022-08-19.\n */\nconst RedisCloudCA = `-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz\nTGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\naXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC\nVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz\nMS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw\nggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1\nG5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY\nDm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl\npp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT\nULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag\n54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ\nxeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC\nJpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K\n2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3\nStsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI\nSIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B\ncS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL\nyzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T\nAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg\nz5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu\nrYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3\n3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+\nhSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ\nD0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj\nTY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l\nFXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj\nmcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf\nybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji\nn8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F\nUhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM\nMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv\nYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y\nNTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu\nIG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy\nMDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf\n8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD\nBVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg\nofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK\ndZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh\ncounQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu\njE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG\nCCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj\nmove4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw\nMi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1\ncmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w\nK6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD\nVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC\nAQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/\n3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY\n0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX\ny+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3\n15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5\nZgKnO/Fx2hBgTxhOTMYaD312kg==\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\nA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\nZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\nMTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\nA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\nRgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\ngHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\nKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\nQQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\nXriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\nLkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\nRUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\njjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\nmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\nMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\nWD9f\n-----END CERTIFICATE-----`;\nconst TLSProfiles = {\n    RedisCloudFixed: { ca: RedisCloudCA },\n    RedisCloudFlexible: { ca: RedisCloudCA },\n};\nexports[\"default\"] = TLSProfiles;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25zdGFudHMvVExTUHJvZmlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NvbnN0YW50cy9UTFNQcm9maWxlcy5qcz82NGIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUTFMgc2V0dGluZ3MgZm9yIFJlZGlzIENsb3VkLiBVcGRhdGVkIG9uIDIwMjItMDgtMTkuXG4gKi9cbmNvbnN0IFJlZGlzQ2xvdWRDQSA9IGAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSURUekNDQWplZ0F3SUJBZ0lKQUtTVnBpRHN3TGN3TUEwR0NTcUdTSWIzRFFFQkJRVUFNRDR4RmpBVUJnTlZcbkJBb01EVWRoY21GdWRHbGhJRVJoZEdFeEpEQWlCZ05WQkFNTUcxTlRUQ0JEWlhKMGFXWnBZMkYwYVc5dUlFRjFcbmRHaHZjbWwwZVRBZUZ3MHhNekV3TURFeE1qRTBOVFZhRncweU16QTVNamt4TWpFME5UVmFNRDR4RmpBVUJnTlZcbkJBb01EVWRoY21GdWRHbGhJRVJoZEdFeEpEQWlCZ05WQkFNTUcxTlRUQ0JEWlhKMGFXWnBZMkYwYVc5dUlFRjFcbmRHaHZjbWwwZVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTFpxa2gvRGN6V1BcbkpueG5ITFE3UUwwVDRCNENES1dCS0NjaXNyaUdiQTZaZVBXVk5vNGhmS1FDNkpyemZSKzA4MU5lRDZWY1dVaXpcbnJtZCtqdFBoSVk0YytXVlFZbTVQS2FONkRUMWltWWR4UXc3YXFPNWoyS1VDRWgvY3pucEx4ZVNIb1R4bFIzNEVcblF3RjI4V2wzZWcydmM1Y3Q4TGpVM2VveldWazNnYjdhbHg5bVNBMlNnbXVYNWxFUWF3bCsrclNqc0JTdGVtWTJcbkJEd09wQU1YSXJkRXlQL2NWbjhta3ZpL0JEczVNNUcrMDlqMGdmaHlDelJXTVE3SG43MXUxZW9sUnh3VnhnaTNcblRNbisvdlRhRlNxeEtqZ2NrNnp1QVlqQlJQYUhlN3FMeEhOcjFTby9NYzluUHkrM3dIZWJGd2JJY25Vb2p3YnBcbjRuY3RrV2JqYjJjQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZQMXdodGNyeWRtVzNaSmV1U29LWklLanplM3dcbk1COEdBMVVkSXdRWU1CYUFGUDF3aHRjcnlkbVczWkpldVNvS1pJS2p6ZTN3TUF3R0ExVWRFd1FGTUFNQkFmOHdcbkRRWUpLb1pJaHZjTkFRRUZCUUFEZ2dFQkFHMmVyWGh3UkFhNytaT0JzMEI2WDU3SHd5ZDFSNGtmbVhjczBydGFcbmxiUHB2Z1VMU2lCK1RDYmYzRWJoSm5IR3l2ZENZMXR2bGZmTGpkQTdISjBQQ09uK1lZTEJBMHBUVS9keXZyTjZcblN1OE51UzV5dWJudDltYjEzbkRHWW8xcm50MFlSZnhOKzhETTNmWElWcjAzOEEzMFVsUFgyT3UxRXhGSlQwTVpcbnVGS1k2WnZMZEk2LzFjYmdtZ3VNbEFoTStEaEt5VjZTcjU2OTlMTTN6cWVJODE2cFptbFJFRVRZa0dyOTFxN2tcbkJwWEp1L2R0SGFHeGcxWkd1NncvUENzWUdVY0VDV0VOWUQ0VlFQZDhOMzJKak9mdTZ2RWdvRUF3ZlBQKzNvR3Bcblo0bTNld0FDY1dPQWVucWZsYitjUVlDNFBzRjdxYlhEbVJhV3JiS250T2xaM24wPVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlHTVRDQ0JCbWdBd0lCQWdJQ0VBQXdEUVlKS29aSWh2Y05BUUVMQlFBd2FqRUxNQWtHQTFVRUJoTUNWVk14XG5DekFKQmdOVkJBZ01Ba05CTVFzd0NRWURWUVFIREFKRFFURVNNQkFHQTFVRUNnd0pVbVZrYVhOTVlXSnpNUzB3XG5Ld1lEVlFRRERDUlNaV1JwYzB4aFluTWdVbTl2ZENCRFpYSjBhV1pwWTJGMFpTQkJkWFJvYjNKcGRIa3dIaGNOXG5NVGd3TWpJMU1UVXpOek0zV2hjTk1qZ3dNakl6TVRVek56TTNXakJmTVFzd0NRWURWUVFHRXdKVlV6RUxNQWtHXG5BMVVFQ0F3Q1EwRXhFakFRQmdOVkJBb01DVkpsWkdselRHRmljekV2TUMwR0ExVUVBd3dtVWtOUUlFbHVkR1Z5XG5iV1ZrYVdGMFpTQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3Z2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBXG5BNElDRHdBd2dnSUtBb0lDQVFEZjlkcWJ4YzhCcTdDdHE5cldjeHJHTktLSGl2cUxBRnBQcTAyeUxQeDZmc092XG5UcTdHc0RDaEFZQkJjNHY3WTJBcDlSRDVWczNkSWhFQU5jbm9sZjI3UXdyRzlSTW5udnprOHBDdnAxbzZ6U1U0XG5WdU9FMVc2Ni9PMS83ZTJyVnh5cm5UY1A3VWdLNDN6TklYdTcrdGlBcVdzTzkydVNudU1vR1BHcGVhVW0xanltXG5oaldLdGtBd0RGU3F2SFkrWEw1cURWQkVqZVVlK1dIa1lVZzQwY0FYanVzQXFnbTJoWnQyOWMyd25WcnhXMjVXXG5QMG1lTmx6SEdGZEEyQUM1ejU0aVJpcWo1N2RUZkJUa0hvQmN6UXhjeXc2aGh6eFpRNGU1STV6T0tqWFhFaFpOXG5yMHRBM1lDMTRDVGFiS1J1cy9KbVppZXlaelJnRXkyb3RpNjR0bUxZVHFTbEFENzhwUkw0MFZOb2FTWWV0WEx3XG5oaE5zWENIZ1dhWTZkNWJMT2MvYUlRTUFWNW9MdlpRS3Z1WEFGMUlEbWhQQStiWmJwV2lwcDB6YWdmMVAxSDNzXG5VenNNZG4yS00wZWp6Z290YnRObGo1VGNyVndwbXZFM2t0dlVBdUEraGkzRmtWeDFVUysyR3NwNXg0WU96Sjd1XG5QMVdQazZTaEYwSmduSkgySUxkajZrdHRUV3dGekgxN2tlU0ZJQ1dEZkgvK2tNK2s3WTF2M0VYTVFYRTd5MFQ5XG5NanZKc2t6NmQvbnYrc1FoWTA0eHQ2NHhGTUdUblpqbEpNemZRTmk3eldGTFRabkREMGxQb3dxN2wzWWlQb1RUXG50NVhreTgzbHUwS1pzWkJvMFdsV2FERzAwZ0xWZHRSZ1ZiY3VTV3hwaTVCZExiMWtSYWI2NkpwdFdqeHdYUUlEXG5BUUFCbzRIck1JSG9NRG9HQTFVZEh3UXpNREV3TDZBdG9DdUdLV2gwZEhCek9pOHZjbXd0WTJFdGMyVnlkbVZ5XG5MbkpsWkdsemJHRmljeTVqYjIwdmRqRXZZM0pzTUVZR0NDc0dBUVVGQndFQkJEb3dPREEyQmdnckJnRUZCUWN3XG5BWVlxYUhSMGNITTZMeTl5YkMxallTMXpaWEoyWlhJdWNtVmthWE5zWVdKekxtTnZiUzkyTVM5dlkzTndNQjBHXG5BMVVkRGdRV0JCUUhhcjVPS3ZRVXBQMnFXdDZtY2t6VG9lQ09IREFmQmdOVkhTTUVHREFXZ0JRaTQyd0g2aE00XG5MMnN1akV2TE0wL3U4bFJYVHpBU0JnTlZIUk1CQWY4RUNEQUdBUUgvQWdFQU1BNEdBMVVkRHdFQi93UUVBd0lCXG5oakFOQmdrcWhraUc5dzBCQVFzRkFBT0NBZ0VBaXJFbi9pVHNBS3loZCtwdTJXM1o1TmpDa280TlBVMEVZVWJyXG5BUDcrUE9LMnJ6aklySk8zbkZZUS9MTHVDN0tDWEcrMnF3YW4yU0FPR21xV3N0MTNZK1dIcDQ0S2FlMGthQ2hXXG52Y1lMWFhTb0dRR0M4UXVGU05VZGFlZzNSYk1EWUZUMDRkT2txdWZlV1ZjY29IVnh5VFNnOWVEOExadUhuNWp3XG43UURMaUVFQ0JtSUpIazVFZW8yVEFacng0WXg2dWZTVVg1SGVWamxBenF3dEFxZHQ5OXVDSi9FTDhiZ3BXYmUrXG5Yb1NwdlV2MFNFQzFJMWRDQWhDS0F2UmxJT0E2VkJjbXpnNUFtMTJLemtxVHVsMTIvVkVGSWd6cXUwWnkySmJjXG5BVVByWVZ1Lyt0T0dYUWFpank3WWd3SDhQOG4zczdaZVVhMVZBQkpIY3hyeFlkdURESkJMWmkrTWpoZVVEYVoxXG5qUVJIWWV2STJ0bHFlU0JxZFBLRzR6Qlk1bFMwR2lBbG11emU1b0VOdDBQM1hib0hvWlBIaXFjSzNWRUNnVFZoXG4vQmtKY3V1ZEVUU0pjWkRtUThZZm9LZkJ6UlFOZzJzdi9od3ZVdjczU3M1MVNjbzhHRXQybEQ4dUVkaWIxUTZ6XG56RFQ1bFhKb3dTek9ENVpBOU9HRGpuU1JMKzJyaU50S1dLRXF2dEVHM1ZCSm9CenU5R294YkFjN3dJWkx4bWxpXG5pRjVhL1pmNVgrVVhEM3M0VE1teTZDNFFaSnBBQTJlZ3NTUUNucmFXTzJVTGhoN2lYTXlzU2tGL256VmZabjQzXG5pcXBhQjgrKzlhMzdoV3ExNFptT3YwVEpJRHovL2IyK0tDNFZGWFdRNVc1UUM2d2hzalQrT2xHNHA1WllHMGpvXG42MTZweHFvPVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlGdWpDQ0E2S2dBd0lCQWdJSkFKMWFUVDFsdTJTY01BMEdDU3FHU0liM0RRRUJDd1VBTUdveEN6QUpCZ05WXG5CQVlUQWxWVE1Rc3dDUVlEVlFRSURBSkRRVEVMTUFrR0ExVUVCd3dDUTBFeEVqQVFCZ05WQkFvTUNWSmxaR2x6XG5UR0ZpY3pFdE1Dc0dBMVVFQXd3a1VtVmthWE5NWVdKeklGSnZiM1FnUTJWeWRHbG1hV05oZEdVZ1FYVjBhRzl5XG5hWFI1TUI0WERURTRNREl5TlRFMU1qQTBNbG9YRFRNNE1ESXlNREUxTWpBME1sb3dhakVMTUFrR0ExVUVCaE1DXG5WVk14Q3pBSkJnTlZCQWdNQWtOQk1Rc3dDUVlEVlFRSERBSkRRVEVTTUJBR0ExVUVDZ3dKVW1Wa2FYTk1ZV0p6XG5NUzB3S3dZRFZRUUREQ1JTWldScGMweGhZbk1nVW05dmRDQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3XG5nZ0lpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElDRHdBd2dnSUtBb0lDQVFETEVqWHk3WXJiTjVXYWF1NWNkNmcxXG5HNUMydE1tZVRwWjBkdUZBUHhOVTRvRTNSSFM1Z0dpb2szNDZmVVh1VXhiWjZRa3V6ZU4yLzJaK1JtUmNKaFFZXG5EbTBaZ2RHNHg1OUFuMVRKZm56S0tvV2o4SVNtb0hTL1RHTkJkRnpYVjdGWU5MQnVxWm91cWVQSTZSZUM2UWhsXG5wcDQ1aHVWMzJRM2E2SURycnZ4N1dvNVpjekVRZUZOYkNlQ09RWU5EZFRtQ3lFa0hxYzJBR284ZW9JbFNUdXRUXG5VTE9DN1I1Z3pKVlRTMGUxaGVzUTdqbXFIamJPK1ZRUzFOQUw0LzVLNmN1VEVxVWwrWGhWaFBkTFdCWEpRNWFnXG41NHFoWDR2K29qTHplVTFSL1ZjNk5qTXZWdHB0V1k2SmlocGdwbHByTjBZaDI1NTZld2NYTWV0dXJjS2dYZkdKXG54ZVl6c2p6WGVyRWpyVm9jWDVWOEJOcmc2NE5saWZ6VE1LTk9PdjRmVlpzenExU0lIUjhGOVJPcnFpT2RoOGlDXG5KcFViTHBYSDloV0NTRU82VlJNQjJ4Sm9LdTNjZ2w2M2tGMzBzNzd4N3dMRk1FSGl3c1FSS3hvb0UxVWhnUzlLXG4yc080VGxRMWVXVXZGdkhTVFZEUURsR1E2enU0cWpiT3BiM1E4YlF3b0srYWkyYWxrWFZSNEx0eGU5UWxnWUszXG5TdHNuUGhydXpaR0Ewd2JYZHB3MGJuTStZZGxFbTVmZlNUcE5JZmdIZWFhN0R0YjgwMUZ0QTcxWmxIN0E2VGFJXG5TSVF1VVNUOUVLbXY3eHJKeXgwVzFwR29QT0x3NVQwMjlhVGpuSUNTTGR0VjliTHd5c3JMaElZRzViblBxNzhCXG5jUytqWkhGR3pEN1BVVkdRRDAxbk9RSURBUUFCbzJNd1lUQWRCZ05WSFE0RUZnUVVJdU5zQitvVE9DOXJMb3hMXG55ek5QN3ZKVVYwOHdId1lEVlIwakJCZ3dGb0FVSXVOc0Irb1RPQzlyTG94THl6TlA3dkpVVjA4d0R3WURWUjBUXG5BUUgvQkFVd0F3RUIvekFPQmdOVkhROEJBZjhFQkFNQ0FZWXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnSUJBSGZnXG56NXBNTlVBS2RNeksxYVMxRURkSzl5S3o0cWljSUx6NWN6U0xqMW1DN0hLRFJ5OGNWQURVeEVJQ2lzKytDc0N1XG5yWU92eUNWZXJnSFFMUkVjeFBxNHJjNU5xMXVqNko2NjQ5TkVlaDRXYXpPT2pMNFpmUTFqVnpuTWJHeStmSm0zXG4zSG9lbHY2aldSRzlpcWVKWmphNy8xczZZQzZiV3ltSS9PWTFlNHdVS2VOSEFvK1ZnZXI3TWxIVitSdWFiYVgrXG5oU0o4YkpBTTU5TkNNN0FnTVRRcEpDbmNyY2RMZWNlWW5pR3k1US9xdDJiNW1Ka1FWa0lkeTRUUEdHQitBWERKXG5EMHEzSS9KRFJrRFVGTkZkZVcwanM3Zkhkc3ZDUjdPM3RKeTV6SWdFVi9vL0JDa21KVnR1d1BZT3J3L3lPbEtqXG5UWS9VN0FUQXg5VkZGNi92WUVPTVlTbXJabEZYKzk4TDZuSnR3RHFmTEI1VlRsdHFaNEgvS0J4R0UzSVJTdDlsXG5GWHk0MFUrTG5YemhoVys3VkJBdnlZWDhHRVhoSGtLVThHcWsxeGl0cnFmQlhZNzR4S2d5VVNUb2xGU2ZGVmdqXG5tY00vWDRLNDVia2ErcXBrajdLZnYvOEQ0ajZhWmVrd2hOMmx5NmhoQzFTbVE4cWpNanBHL21yV09TU0haRm1mXG55YnU5aUQyQVlIZUlPa3NoSWw2eFlJYSsrUS8wMC92czQ2SXpBYlF5cmlPaTBYeGxTTU1WdFB4MFEzaXNwK2ppXG5uOE1xOWVPdXhZT0VRNG9mOHR3VWtVRGQ1Mjhpd0d0RWR3ZjBRMDFVeVQ4NFM2Mk44QXlTbDFaQktYSno2VzRGXG5VaFdmYS9IUVlPQVBEZEVqTmduVndMSTIzYjh0MFRvenlDV3c3cThoXG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG5cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRWp6Q0NBM2VnQXdJQkFnSVFlNTVCL0FMQ0tKRFp0ZE5UOGtENmhUQU5CZ2txaGtpRzl3MEJBUXNGQURCTVxuTVNBd0hnWURWUVFMRXhkSGJHOWlZV3hUYVdkdUlGSnZiM1FnUTBFZ0xTQlNNekVUTUJFR0ExVUVDaE1LUjJ4dlxuWW1Gc1UybG5iakVUTUJFR0ExVUVBeE1LUjJ4dlltRnNVMmxuYmpBZUZ3MHlNakF4TWpZeE1qQXdNREJhRncweVxuTlRBeE1qWXdNREF3TURCYU1GZ3hDekFKQmdOVkJBWVRBa0pGTVJrd0Z3WURWUVFLRXhCSGJHOWlZV3hUYVdkdVxuSUc1MkxYTmhNUzR3TEFZRFZRUURFeVZIYkc5aVlXeFRhV2R1SUVGMGJHRnpJRkl6SUU5V0lGUk1VeUJEUVNBeVxuTURJeUlGRXlNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQW1HbWcxTFc5YjdMZlxuOHpERDgzeUJEVEVrdCtGT3hLSlpxRjR2ZVdjNUtac1FqOUhmblVTMmU1bmovRStKSW1sR1BzUXVvaW9zTHVYRFxuQlZCTkFNY1VGYTExYnVGTUdNZUVNd2lUbUNYb1hSclhRbUgwcWpwT2ZLZ1ljNWdIRzNCc1JHYVJyZjdWUjRlZ1xub2ZOTUc5d1VCdzQvZy9UVDcrYlFKZEE0TmZFN1k0ZDVnRXJ5WmlCR0Ivc3dhWDZKcC84TUY0VGdVbU9XbWFsS1xuZFpDS3liNHNQR1FGUlR0RWxrNjdGN3ZVK3dkR2NyY094MXREY0lCMG5jakxQTW5hRmljYWdsK2RhV0dzS3FUaFxuY291blFiNlFKdFlIYTkxS3ZDZktXb2NNeFE3T0liQjVVQVJMUG1DNENKMS9mOFlGbTM1ZWJmekFlVUxZZEdYdVxuakU5Q0xvcjBPd0lEQVFBQm80SUJYekNDQVZzd0RnWURWUjBQQVFIL0JBUURBZ0dHTUIwR0ExVWRKUVFXTUJRR1xuQ0NzR0FRVUZCd01CQmdnckJnRUZCUWNEQWpBU0JnTlZIUk1CQWY4RUNEQUdBUUgvQWdFQU1CMEdBMVVkRGdRV1xuQkJTSDVacTdhN0IvdDk1R2ZKV2tEQnBBOEhIcWRqQWZCZ05WSFNNRUdEQVdnQlNQOEV0L3FDNUZKSzVOVVBwalxubW92ZTR0MGJ2REI3QmdnckJnRUZCUWNCQVFSdk1HMHdMZ1lJS3dZQkJRVUhNQUdHSW1oMGRIQTZMeTl2WTNOd1xuTWk1bmJHOWlZV3h6YVdkdUxtTnZiUzl5YjI5MGNqTXdPd1lJS3dZQkJRVUhNQUtHTDJoMGRIQTZMeTl6WldOMVxuY21VdVoyeHZZbUZzYzJsbmJpNWpiMjB2WTJGalpYSjBMM0p2YjNRdGNqTXVZM0owTURZR0ExVWRId1F2TUMwd1xuSzZBcG9DZUdKV2gwZEhBNkx5OWpjbXd1WjJ4dlltRnNjMmxuYmk1amIyMHZjbTl2ZEMxeU15NWpjbXd3SVFZRFxuVlIwZ0JCb3dHREFJQmdabmdRd0JBZ0l3REFZS0t3WUJCQUdnTWdvQkFqQU5CZ2txaGtpRzl3MEJBUXNGQUFPQ1xuQVFFQUtSaWM5L2Yrbm1oUVUvd3owNEFQWkxqZ0c1T2dzdVVPeVVFWmpLVmhOR0R3eEdUdktoeVhHR0FNVzJCL1xuM2JSaSthRWxwWHdveHUzcEw2ZmtFbGJYM0IwQmVTNUxvRHR4a3lpVkVCTVo4bStzWGJvY3dsUHl4clBiWDZtWVxuMHJWSXZudVVlQkg4WDBMNUl3ZnBOVnZLbkJJaWxUYmNlYmZIeVhrUGV6R3d6N0UxeWhVVUxqSkZtMmJ0MFNkWFxueSs0WC9XZWlpWUl2K2ZUVmdaWmdsKy8yTUtJc3UvcWRCSmMzZjNUdko4bnorRWF4MXpnWm13dytSU1FXZU9qM1xuMTVJdzZaNUZYK053elkvQWIrOVBvc1I1VW9zU2VxKzlIaHRheFp0dFhHMW5WaCthdllQR1lkZFdtaU1UOTBKNVxuWmdLbk8vRngyaEJnVHhoT1RNWWFEMzEya2c9PVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuXG4tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSURYekNDQWtlZ0F3SUJBZ0lMQkFBQUFBQUJJVmhUQ0tJd0RRWUpLb1pJaHZjTkFRRUxCUUF3VERFZ01CNEdcbkExVUVDeE1YUjJ4dlltRnNVMmxuYmlCU2IyOTBJRU5CSUMwZ1VqTXhFekFSQmdOVkJBb1RDa2RzYjJKaGJGTnBcbloyNHhFekFSQmdOVkJBTVRDa2RzYjJKaGJGTnBaMjR3SGhjTk1Ea3dNekU0TVRBd01EQXdXaGNOTWprd016RTRcbk1UQXdNREF3V2pCTU1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUdcbkExVUVDaE1LUjJ4dlltRnNVMmxuYmpFVE1CRUdBMVVFQXhNS1IyeHZZbUZzVTJsbmJqQ0NBU0l3RFFZSktvWklcbmh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTXdsZHBCNUJuZ2lGdlhBZzdhRXlpaWUvUVYyRWNXdGlITDhcblJnSkR4N0tLblFSZkpNc3VTK0ZnZ2tiaFVxc01nVWR3Yk4xazBldjFMS01QZ2owTUs2NlgxN1lVaGhCNXV6c1RcbmdIZU1DT0ZKMG1waUx4OWUrcFpvMzRrbmxUaWZCdGMreWNzbVdRMXozckRJNlNZT2d4WEc3MXVMMGdSZ3lrbW1cbktQWnBPL2JMeUNpUjVaMktZVmMzckhRVTNIVGdPdTV5THk2Yys5Qzd2L1U5QU9FR00raUNLNjVUcGpvV2M0emRcblFRNGdPc0MwcDZIcHNrK1FMakpnNlZmTHVRU1NhR2psT0NaZ2RiS2ZkLytSRk8rdUlFbjhyVUFWU05FQ01XRVpcblhyaVg3NjEzdDJTYWVyOWZ3UlB2bTJMN0RXemdWR2tXcVFQYWJ1bURrM0YyeG1tRmdoY0NBd0VBQWFOQ01FQXdcbkRnWURWUjBQQVFIL0JBUURBZ0VHTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3SFFZRFZSME9CQllFRkkvd1MzK29cbkxrVWtyazFRK21PYWk5N2kzUnU4TUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCTFFOdkFVS3IreUF6djk1WlVcblJVbTdsZ0FKUWF5ekU0YUdLQWN6eW12bWRMbTZBQzJ1cEFyVDlmSHhENHEvYzJkS2c4ZEVlM2pncjI1c2J3TXBcbmpqTTVSY09PNUxsWGJLcjhFcGJzVThZdDVDUnN1WlJqKzl4VGFHZFdQb080enpVaHc4bG8vczdhd2xPcXpKQ0tcbjZmQmRSb3lWM1hwWUtCb3ZIZDdOQURkQmorMUViZGRUS0pkKzgyY0VIaFhYaXBhMDA5NU1KNlJNRzNOemR2UVhcbm1jSWZlZzdqTFFpdENod3MvenlyVlE0UGtYNDI2OE5YU2I3aExpMThZSXZEUVZFVEk1M085ekpybEFHb21lY3Ncbk14ODZPeVhTaGtET095eUdlTWxoTHhTNjd0dFZiOStFN2dVSlRiMG8ySExPMDJKUVpSN3JrcGVETWRtenRjcEhcbldEOWZcbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1gO1xuY29uc3QgVExTUHJvZmlsZXMgPSB7XG4gICAgUmVkaXNDbG91ZEZpeGVkOiB7IGNhOiBSZWRpc0Nsb3VkQ0EgfSxcbiAgICBSZWRpc0Nsb3VkRmxleGlibGU6IHsgY2E6IFJlZGlzQ2xvdWRDQSB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRMU1Byb2ZpbGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/ClusterAllFailedError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass ClusterAllFailedError extends redis_errors_1.RedisError {\n    constructor(message, lastNodeError) {\n        super(message);\n        this.lastNodeError = lastNodeError;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = ClusterAllFailedError;\nClusterAllFailedError.defaultMessage = \"Failed to refresh slots cache.\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLGdFQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Vycm9ycy9DbHVzdGVyQWxsRmFpbGVkRXJyb3IuanM/ZTNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNsYXNzIENsdXN0ZXJBbGxGYWlsZWRFcnJvciBleHRlbmRzIHJlZGlzX2Vycm9yc18xLlJlZGlzRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxhc3ROb2RlRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubGFzdE5vZGVFcnJvciA9IGxhc3ROb2RlRXJyb3I7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDbHVzdGVyQWxsRmFpbGVkRXJyb3I7XG5DbHVzdGVyQWxsRmFpbGVkRXJyb3IuZGVmYXVsdE1lc3NhZ2UgPSBcIkZhaWxlZCB0byByZWZyZXNoIHNsb3RzIGNhY2hlLlwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass MaxRetriesPerRequestError extends redis_errors_1.AbortError {\n    constructor(maxRetriesPerRequest) {\n        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to \"maxRetriesPerRequest\" option for details.`;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = MaxRetriesPerRequestError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBYztBQUM3QztBQUNBO0FBQ0EsK0VBQStFLHFCQUFxQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IuanM/ODlmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNsYXNzIE1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IgZXh0ZW5kcyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhSZXRyaWVzUGVyUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFJlYWNoZWQgdGhlIG1heCByZXRyaWVzIHBlciByZXF1ZXN0IGxpbWl0ICh3aGljaCBpcyAke21heFJldHJpZXNQZXJSZXF1ZXN0fSkuIFJlZmVyIHRvIFwibWF4UmV0cmllc1BlclJlcXVlc3RcIiBvcHRpb24gZm9yIGRldGFpbHMuYDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MaxRetriesPerRequestError = void 0;\nconst MaxRetriesPerRequestError_1 = __webpack_require__(/*! ./MaxRetriesPerRequestError */ \"(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\");\nexports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLG9DQUFvQyxtQkFBTyxDQUFDLDJHQUE2QjtBQUN6RSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanM/ZTIxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvciA9IHZvaWQgMDtcbmNvbnN0IE1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JfMSA9IHJlcXVpcmUoXCIuL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JcIik7XG5leHBvcnRzLk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IgPSBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yXzEuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/index.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports[\"default\"] = void 0;\nexports = module.exports = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\")[\"default\"];\nvar Redis_1 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return Redis_1.default; } }));\nvar Redis_2 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"Redis\", ({ enumerable: true, get: function () { return Redis_2.default; } }));\nvar cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nObject.defineProperty(exports, \"Cluster\", ({ enumerable: true, get: function () { return cluster_1.default; } }));\n/**\n * @ignore\n */\nvar Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nObject.defineProperty(exports, \"Command\", ({ enumerable: true, get: function () { return Command_1.default; } }));\n/**\n * @ignore\n */\nvar ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nObject.defineProperty(exports, \"ScanStream\", ({ enumerable: true, get: function () { return ScanStream_1.default; } }));\n/**\n * @ignore\n */\nvar Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nObject.defineProperty(exports, \"Pipeline\", ({ enumerable: true, get: function () { return Pipeline_1.default; } }));\n/**\n * @ignore\n */\nvar AbstractConnector_1 = __webpack_require__(/*! ./connectors/AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nObject.defineProperty(exports, \"AbstractConnector\", ({ enumerable: true, get: function () { return AbstractConnector_1.default; } }));\n/**\n * @ignore\n */\nvar SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nObject.defineProperty(exports, \"SentinelConnector\", ({ enumerable: true, get: function () { return SentinelConnector_1.default; } }));\nObject.defineProperty(exports, \"SentinelIterator\", ({ enumerable: true, get: function () { return SentinelConnector_1.SentinelIterator; } }));\n// No TS typings\nexports.ReplyError = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\").ReplyError;\n/**\n * @ignore\n */\nObject.defineProperty(exports, \"Promise\", ({\n    get() {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n        return Promise;\n    },\n    set(_lib) {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n    },\n}));\n/**\n * @ignore\n */\nfunction print(err, reply) {\n    if (err) {\n        console.log(\"Error: \" + err);\n    }\n    else {\n        console.log(\"Reply: \" + reply);\n    }\n}\nexports.print = print;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsa0JBQWU7QUFDbk8sVUFBVSw2R0FBMkM7QUFDckQsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLDJDQUEwQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM3RyxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IseUNBQXdDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzNHLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFXO0FBQ25DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWM7QUFDekMsOENBQTZDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywwR0FBZ0M7QUFDbEUscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFnQztBQUNsRSxxREFBb0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbkksb0RBQW1ELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFDO0FBQzNJO0FBQ0EscUhBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2luZGV4LmpzPzQxOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByaW50ID0gZXhwb3J0cy5SZXBseUVycm9yID0gZXhwb3J0cy5TZW50aW5lbEl0ZXJhdG9yID0gZXhwb3J0cy5TZW50aW5lbENvbm5lY3RvciA9IGV4cG9ydHMuQWJzdHJhY3RDb25uZWN0b3IgPSBleHBvcnRzLlBpcGVsaW5lID0gZXhwb3J0cy5TY2FuU3RyZWFtID0gZXhwb3J0cy5Db21tYW5kID0gZXhwb3J0cy5DbHVzdGVyID0gZXhwb3J0cy5SZWRpcyA9IGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL1JlZGlzXCIpLmRlZmF1bHQ7XG52YXIgUmVkaXNfMSA9IHJlcXVpcmUoXCIuL1JlZGlzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVkaXNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJlZGlzXzIgPSByZXF1aXJlKFwiLi9SZWRpc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZGlzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWRpc18yLmRlZmF1bHQ7IH0gfSk7XG52YXIgY2x1c3Rlcl8xID0gcmVxdWlyZShcIi4vY2x1c3RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsdXN0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tbWFuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29tbWFuZF8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIFNjYW5TdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1NjYW5TdHJlYW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY2FuU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTY2FuU3RyZWFtXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgUGlwZWxpbmVfMSA9IHJlcXVpcmUoXCIuL1BpcGVsaW5lXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGlwZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBpcGVsaW5lXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgQWJzdHJhY3RDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnMvQWJzdHJhY3RDb25uZWN0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdENvbm5lY3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQWJzdHJhY3RDb25uZWN0b3JfMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBTZW50aW5lbENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3RvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbnRpbmVsQ29ubmVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTZW50aW5lbENvbm5lY3Rvcl8xLmRlZmF1bHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW50aW5lbEl0ZXJhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTZW50aW5lbENvbm5lY3Rvcl8xLlNlbnRpbmVsSXRlcmF0b3I7IH0gfSk7XG4vLyBObyBUUyB0eXBpbmdzXG5leHBvcnRzLlJlcGx5RXJyb3IgPSByZXF1aXJlKFwicmVkaXMtZXJyb3JzXCIpLlJlcGx5RXJyb3I7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvbWlzZVwiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJpb3JlZGlzIHY1IGRvZXMgbm90IHN1cHBvcnQgcGx1Z2dpbmcgdGhpcmQtcGFydHkgUHJvbWlzZSBsaWJyYXJ5IGFueW1vcmUuIE5hdGl2ZSBQcm9taXNlIHdpbGwgYmUgdXNlZC5cIik7XG4gICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgIH0sXG4gICAgc2V0KF9saWIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW9yZWRpcyB2NSBkb2VzIG5vdCBzdXBwb3J0IHBsdWdnaW5nIHRoaXJkLXBhcnR5IFByb21pc2UgbGlicmFyeSBhbnltb3JlLiBOYXRpdmUgUHJvbWlzZSB3aWxsIGJlIHVzZWQuXCIpO1xuICAgIH0sXG59KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBwcmludChlcnIsIHJlcGx5KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiArIGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlcGx5OiBcIiArIHJlcGx5KTtcbiAgICB9XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/RedisOptions.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_REDIS_OPTIONS = void 0;\nexports.DEFAULT_REDIS_OPTIONS = {\n    // Connection\n    port: 6379,\n    host: \"localhost\",\n    family: 4,\n    connectTimeout: 10000,\n    disconnectTimeout: 2000,\n    retryStrategy: function (times) {\n        return Math.min(times * 50, 2000);\n    },\n    keepAlive: 0,\n    noDelay: true,\n    connectionName: null,\n    // Sentinel\n    sentinels: null,\n    name: null,\n    role: \"master\",\n    sentinelRetryStrategy: function (times) {\n        return Math.min(times * 10, 1000);\n    },\n    sentinelReconnectStrategy: function () {\n        // This strategy only applies when sentinels are used for detecting\n        // a failover, not during initial master resolution.\n        // The deployment can still function when some of the sentinels are down\n        // for a long period of time, so we may not want to attempt reconnection\n        // very often. Therefore the default interval is fairly long (1 minute).\n        return 60000;\n    },\n    natMap: null,\n    enableTLSForSentinelMode: false,\n    updateSentinels: true,\n    failoverDetector: false,\n    // Status\n    username: null,\n    password: null,\n    db: 0,\n    // Others\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    autoResubscribe: true,\n    autoResendUnfulfilledCommands: true,\n    lazyConnect: false,\n    keyPrefix: \"\",\n    reconnectOnError: null,\n    readOnly: false,\n    stringNumbers: false,\n    maxRetriesPerRequest: 20,\n    maxLoadingRetryTime: 10000,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    sentinelMaxConnections: 10,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9SZWRpc09wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9SZWRpc09wdGlvbnMuanM/MzgxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9SRURJU19PUFRJT05TID0gdm9pZCAwO1xuZXhwb3J0cy5ERUZBVUxUX1JFRElTX09QVElPTlMgPSB7XG4gICAgLy8gQ29ubmVjdGlvblxuICAgIHBvcnQ6IDYzNzksXG4gICAgaG9zdDogXCJsb2NhbGhvc3RcIixcbiAgICBmYW1pbHk6IDQsXG4gICAgY29ubmVjdFRpbWVvdXQ6IDEwMDAwLFxuICAgIGRpc2Nvbm5lY3RUaW1lb3V0OiAyMDAwLFxuICAgIHJldHJ5U3RyYXRlZ3k6IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGltZXMgKiA1MCwgMjAwMCk7XG4gICAgfSxcbiAgICBrZWVwQWxpdmU6IDAsXG4gICAgbm9EZWxheTogdHJ1ZSxcbiAgICBjb25uZWN0aW9uTmFtZTogbnVsbCxcbiAgICAvLyBTZW50aW5lbFxuICAgIHNlbnRpbmVsczogbnVsbCxcbiAgICBuYW1lOiBudWxsLFxuICAgIHJvbGU6IFwibWFzdGVyXCIsXG4gICAgc2VudGluZWxSZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRpbWVzICogMTAsIDEwMDApO1xuICAgIH0sXG4gICAgc2VudGluZWxSZWNvbm5lY3RTdHJhdGVneTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIHN0cmF0ZWd5IG9ubHkgYXBwbGllcyB3aGVuIHNlbnRpbmVscyBhcmUgdXNlZCBmb3IgZGV0ZWN0aW5nXG4gICAgICAgIC8vIGEgZmFpbG92ZXIsIG5vdCBkdXJpbmcgaW5pdGlhbCBtYXN0ZXIgcmVzb2x1dGlvbi5cbiAgICAgICAgLy8gVGhlIGRlcGxveW1lbnQgY2FuIHN0aWxsIGZ1bmN0aW9uIHdoZW4gc29tZSBvZiB0aGUgc2VudGluZWxzIGFyZSBkb3duXG4gICAgICAgIC8vIGZvciBhIGxvbmcgcGVyaW9kIG9mIHRpbWUsIHNvIHdlIG1heSBub3Qgd2FudCB0byBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICAvLyB2ZXJ5IG9mdGVuLiBUaGVyZWZvcmUgdGhlIGRlZmF1bHQgaW50ZXJ2YWwgaXMgZmFpcmx5IGxvbmcgKDEgbWludXRlKS5cbiAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgIH0sXG4gICAgbmF0TWFwOiBudWxsLFxuICAgIGVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZTogZmFsc2UsXG4gICAgdXBkYXRlU2VudGluZWxzOiB0cnVlLFxuICAgIGZhaWxvdmVyRGV0ZWN0b3I6IGZhbHNlLFxuICAgIC8vIFN0YXR1c1xuICAgIHVzZXJuYW1lOiBudWxsLFxuICAgIHBhc3N3b3JkOiBudWxsLFxuICAgIGRiOiAwLFxuICAgIC8vIE90aGVyc1xuICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICBlbmFibGVSZWFkeUNoZWNrOiB0cnVlLFxuICAgIGF1dG9SZXN1YnNjcmliZTogdHJ1ZSxcbiAgICBhdXRvUmVzZW5kVW5mdWxmaWxsZWRDb21tYW5kczogdHJ1ZSxcbiAgICBsYXp5Q29ubmVjdDogZmFsc2UsXG4gICAga2V5UHJlZml4OiBcIlwiLFxuICAgIHJlY29ubmVjdE9uRXJyb3I6IG51bGwsXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgIHN0cmluZ051bWJlcnM6IGZhbHNlLFxuICAgIG1heFJldHJpZXNQZXJSZXF1ZXN0OiAyMCxcbiAgICBtYXhMb2FkaW5nUmV0cnlUaW1lOiAxMDAwMCxcbiAgICBlbmFibGVBdXRvUGlwZWxpbmluZzogZmFsc2UsXG4gICAgYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHM6IFtdLFxuICAgIHNlbnRpbmVsTWF4Q29ubmVjdGlvbnM6IDEwLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/event_handler.js":
/*!***********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/event_handler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/ioredis/built/errors/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst DataHandler_1 = __webpack_require__(/*! ../DataHandler */ \"(rsc)/./node_modules/ioredis/built/DataHandler.js\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n    return function () {\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function (err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") !== -1) {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    }\n                    else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n                        console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n                    }\n                    else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n                        console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n                    }\n                    else {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select).catch((err) => {\n                // If the node is in cluster mode, select is disallowed.\n                // In this case, reconnect won't help.\n                self.silentEmit(\"error\", err);\n            });\n        }\n        if (!self.options.enableReadyCheck) {\n            exports.readyHandler(self)();\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */\n        new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers,\n        });\n        if (self.options.enableReadyCheck) {\n            self._readyCheck(function (err, info) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (!flushed) {\n                        self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                    }\n                }\n                else {\n                    if (self.connector.check(info)) {\n                        exports.readyHandler(self)();\n                    }\n                    else {\n                        self.disconnect(true);\n                    }\n                }\n            });\n        }\n    };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n    const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n    err.command = {\n        name: command.name,\n        args: command.args,\n    };\n    return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n    var _a;\n    let expectedIndex = 0;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        const pipelineIndex = command.pipelineIndex;\n        if (pipelineIndex === undefined || pipelineIndex === 0) {\n            expectedIndex = 0;\n        }\n        if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            continue;\n        }\n        i++;\n    }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n    var _a;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        if (command.name === \"multi\") {\n            break;\n        }\n        if (command.name === \"exec\") {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            break;\n        }\n        if (command.inTransaction) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n        }\n        else {\n            i++;\n        }\n    }\n}\nfunction closeHandler(self) {\n    return function () {\n        const prevStatus = self.status;\n        self.setStatus(\"close\");\n        if (self.commandQueue.length) {\n            abortIncompletePipelines(self.commandQueue);\n        }\n        if (self.offlineQueue.length) {\n            abortTransactionFragments(self.offlineQueue);\n        }\n        if (prevStatus === \"ready\") {\n            if (!self.prevCondition) {\n                self.prevCondition = self.condition;\n            }\n            if (self.commandQueue.length) {\n                self.prevCommandQueue = self.commandQueue;\n            }\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function () {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            }\n            else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function (error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function () {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\").then(() => self.setStatus(\"monitoring\"), (error) => self.emit(\"error\", error));\n            const { sendCommand } = self;\n            self.sendCommand = function (command) {\n                if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function () {\n                delete self.sendCommand;\n            });\n            return;\n        }\n        const finalSelect = self.prevCondition\n            ? self.prevCondition.select\n            : self.condition.select;\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n        }\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n                const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n                if (ssubscribeChannels.length) {\n                    debug(\"ssubscribe %d channels\", ssubscribeChannels.length);\n                    self.ssubscribe(ssubscribeChannels);\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while (self.prevCommandQueue.length > 0) {\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select &&\n                        item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            }\n            else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select &&\n                    item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9ldmVudF9oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLHNCQUFzQjtBQUMzRix1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBYztBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRUFBWTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBVztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvZXZlbnRfaGFuZGxlci5qcz9iNjY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWFkeUhhbmRsZXIgPSBleHBvcnRzLmVycm9ySGFuZGxlciA9IGV4cG9ydHMuY2xvc2VIYW5kbGVyID0gZXhwb3J0cy5jb25uZWN0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuLi9Db21tYW5kXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IERhdGFIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vRGF0YUhhbmRsZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcImNvbm5lY3Rpb25cIik7XG5mdW5jdGlvbiBjb25uZWN0SGFuZGxlcihzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJjb25uZWN0XCIpO1xuICAgICAgICBzZWxmLnJlc2V0Q29tbWFuZFF1ZXVlKCk7XG4gICAgICAgIC8vIEFVVEggY29tbWFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkIGJlZm9yZSBhbnkgb3RoZXIgY29tbWFuZHNcbiAgICAgICAgbGV0IGZsdXNoZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uRXBvY2ggfSA9IHNlbGY7XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbi5hdXRoKSB7XG4gICAgICAgICAgICBzZWxmLmF1dGgoc2VsZi5jb25kaXRpb24uYXV0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uRXBvY2ggIT09IHNlbGYuY29ubmVjdGlvbkVwb2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIm5vIHBhc3N3b3JkIGlzIHNldFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBSZWRpcyBzZXJ2ZXIgZG9lcyBub3QgcmVxdWlyZSBhIHBhc3N3b3JkLCBidXQgYSBwYXNzd29yZCB3YXMgc3VwcGxpZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJ3aXRob3V0IGFueSBwYXNzd29yZCBjb25maWd1cmVkIGZvciB0aGUgZGVmYXVsdCB1c2VyXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5dIFRoaXMgUmVkaXMgc2VydmVyJ3MgYGRlZmF1bHRgIHVzZXIgZG9lcyBub3QgcmVxdWlyZSBhIHBhc3N3b3JkLCBidXQgYSBwYXNzd29yZCB3YXMgc3VwcGxpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yICdhdXRoJyBjb21tYW5kXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbRVJST1JdIFRoZSBzZXJ2ZXIgcmV0dXJuZWQgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAnYXV0aCcgY29tbWFuZFwiLiBZb3UgYXJlIHByb2JhYmx5IHBhc3NpbmcgYm90aCB1c2VybmFtZSBhbmQgcGFzc3dvcmQgdG8gUmVkaXMgdmVyc2lvbiA1IG9yIGJlbG93LiBZb3Ugc2hvdWxkIG9ubHkgcGFzcyB0aGUgJ3Bhc3N3b3JkJyBvcHRpb24gZm9yIFJlZGlzIHZlcnNpb24gNSBhbmQgdW5kZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb3ZlckZyb21GYXRhbEVycm9yKGVyciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbi5zZWxlY3QpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KHNlbGYuY29uZGl0aW9uLnNlbGVjdCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGluIGNsdXN0ZXIgbW9kZSwgc2VsZWN0IGlzIGRpc2FsbG93ZWQuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCByZWNvbm5lY3Qgd29uJ3QgaGVscC5cbiAgICAgICAgICAgICAgICBzZWxmLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuZW5hYmxlUmVhZHlDaGVjaykge1xuICAgICAgICAgICAgZXhwb3J0cy5yZWFkeUhhbmRsZXIoc2VsZikoKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgIE5vIG5lZWQgdG8ga2VlcCB0aGUgcmVmZXJlbmNlIG9mIERhdGFIYW5kbGVyIGhlcmVcbiAgICAgICAgICBiZWNhdXNlIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhlIGNsZWFudXAuXG4gICAgICAgICAgYFN0cmVhbSNlbmQoKWAgd2lsbCByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdXMuXG4gICAgICAgICovXG4gICAgICAgIG5ldyBEYXRhSGFuZGxlcl8xLmRlZmF1bHQoc2VsZiwge1xuICAgICAgICAgICAgc3RyaW5nTnVtYmVyczogc2VsZi5vcHRpb25zLnN0cmluZ051bWJlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuYWJsZVJlYWR5Q2hlY2spIHtcbiAgICAgICAgICAgIHNlbGYuX3JlYWR5Q2hlY2soZnVuY3Rpb24gKGVyciwgaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uRXBvY2ggIT09IHNlbGYuY29ubmVjdGlvbkVwb2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb3ZlckZyb21GYXRhbEVycm9yKG5ldyBFcnJvcihcIlJlYWR5IGNoZWNrIGZhaWxlZDogXCIgKyBlcnIubWVzc2FnZSksIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbm5lY3Rvci5jaGVjayhpbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5yZWFkeUhhbmRsZXIoc2VsZikoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuY29ubmVjdEhhbmRsZXIgPSBjb25uZWN0SGFuZGxlcjtcbmZ1bmN0aW9uIGFib3J0RXJyb3IoY29tbWFuZCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yKFwiQ29tbWFuZCBhYm9ydGVkIGR1ZSB0byBjb25uZWN0aW9uIGNsb3NlXCIpO1xuICAgIGVyci5jb21tYW5kID0ge1xuICAgICAgICBuYW1lOiBjb21tYW5kLm5hbWUsXG4gICAgICAgIGFyZ3M6IGNvbW1hbmQuYXJncyxcbiAgICB9O1xuICAgIHJldHVybiBlcnI7XG59XG4vLyBJZiBhIGNvbnRpZ3VvdXMgc2V0IG9mIHBpcGVsaW5lIGNvbW1hbmRzIHN0YXJ0cyBmcm9tIGluZGV4IHplcm8gdGhlbiB0aGV5XG4vLyBjYW4gYmUgc2FmZWx5IHJlYXR0ZW1wdGVkLiBJZiBob3dldmVyIHdlIGhhdmUgYSBjaGFpbiBvZiBwaXBlbGluZWQgY29tbWFuZHNcbi8vIHN0YXJ0aW5nIGF0IGluZGV4IDEgb3IgbW9yZSBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHBhcnRpYWwgcmVzcG9uc2UgYmVmb3JlXG4vLyB0aGUgY29ubmVjdGlvbiBjbG9zZSBhbmQgdGhvc2UgcGlwZWxpbmVkIGNvbW1hbmRzIG11c3QgYmUgYWJvcnRlZC4gRm9yXG4vLyBleGFtcGxlLCBpZiB0aGUgcXVldWUgbG9va3MgbGlrZSB0aGlzOiBbMiwgMywgNCwgMCwgMSwgMl0gdGhlbiBhZnRlclxuLy8gYWJvcnRpbmcgYW5kIHB1cmdpbmcgd2UnbGwgaGF2ZSBhIHF1ZXVlIHRoYXQgbG9va3MgbGlrZSB0aGlzOiBbMCwgMSwgMl1cbmZ1bmN0aW9uIGFib3J0SW5jb21wbGV0ZVBpcGVsaW5lcyhjb21tYW5kUXVldWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGV4cGVjdGVkSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZFF1ZXVlLmxlbmd0aDspIHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IChfYSA9IGNvbW1hbmRRdWV1ZS5wZWVrQXQoaSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21tYW5kO1xuICAgICAgICBjb25zdCBwaXBlbGluZUluZGV4ID0gY29tbWFuZC5waXBlbGluZUluZGV4O1xuICAgICAgICBpZiAocGlwZWxpbmVJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHBpcGVsaW5lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGV4cGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXBlbGluZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgcGlwZWxpbmVJbmRleCAhPT0gZXhwZWN0ZWRJbmRleCsrKSB7XG4gICAgICAgICAgICBjb21tYW5kUXVldWUucmVtb3ZlKGksIDEpO1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QoYWJvcnRFcnJvcihjb21tYW5kKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxufVxuLy8gSWYgb25seSBhIHBhcnRpYWwgdHJhbnNhY3Rpb24gcmVzdWx0IHdhcyByZWNlaXZlZCBiZWZvcmUgY29ubmVjdGlvbiBjbG9zZSxcbi8vIHdlIGhhdmUgdG8gYWJvcnQgYW55IHRyYW5zYWN0aW9uIGZyYWdtZW50cyB0aGF0IG1heSBoYXZlIGVuZGVkIHVwIGluIHRoZVxuLy8gb2ZmbGluZSBxdWV1ZVxuZnVuY3Rpb24gYWJvcnRUcmFuc2FjdGlvbkZyYWdtZW50cyhjb21tYW5kUXVldWUpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kUXVldWUubGVuZ3RoOykge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gKF9hID0gY29tbWFuZFF1ZXVlLnBlZWtBdChpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbW1hbmQ7XG4gICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwibXVsdGlcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQubmFtZSA9PT0gXCJleGVjXCIpIHtcbiAgICAgICAgICAgIGNvbW1hbmRRdWV1ZS5yZW1vdmUoaSwgMSk7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChhYm9ydEVycm9yKGNvbW1hbmQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLmluVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbW1hbmRRdWV1ZS5yZW1vdmUoaSwgMSk7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChhYm9ydEVycm9yKGNvbW1hbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlSGFuZGxlcihzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcHJldlN0YXR1cyA9IHNlbGYuc3RhdHVzO1xuICAgICAgICBzZWxmLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICBpZiAoc2VsZi5jb21tYW5kUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhYm9ydEluY29tcGxldGVQaXBlbGluZXMoc2VsZi5jb21tYW5kUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb25GcmFnbWVudHMoc2VsZi5vZmZsaW5lUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5wcmV2Q29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2Q29uZGl0aW9uID0gc2VsZi5jb25kaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb21tYW5kUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2Q29tbWFuZFF1ZXVlID0gc2VsZi5jb21tYW5kUXVldWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWFudWFsbHlDbG9zaW5nKSB7XG4gICAgICAgICAgICBzZWxmLm1hbnVhbGx5Q2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZGVidWcoXCJza2lwIHJlY29ubmVjdGluZyBzaW5jZSB0aGUgY29ubmVjdGlvbiBpcyBtYW51YWxseSBjbG9zZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMucmV0cnlTdHJhdGVneSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNraXAgcmVjb25uZWN0aW5nIGJlY2F1c2UgYHJldHJ5U3RyYXRlZ3lgIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cnlEZWxheSA9IHNlbGYub3B0aW9ucy5yZXRyeVN0cmF0ZWd5KCsrc2VsZi5yZXRyeUF0dGVtcHRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRyeURlbGF5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNraXAgcmVjb25uZWN0aW5nIGJlY2F1c2UgYHJldHJ5U3RyYXRlZ3lgIGRvZXNuJ3QgcmV0dXJuIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJyZWNvbm5lY3QgaW4gJXNtc1wiLCByZXRyeURlbGF5KTtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJyZWNvbm5lY3RpbmdcIiwgcmV0cnlEZWxheSk7XG4gICAgICAgIHNlbGYucmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuY29ubmVjdCgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIH0sIHJldHJ5RGVsYXkpO1xuICAgICAgICBjb25zdCB7IG1heFJldHJpZXNQZXJSZXF1ZXN0IH0gPSBzZWxmLm9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4UmV0cmllc1BlclJlcXVlc3QgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChtYXhSZXRyaWVzUGVyUmVxdWVzdCA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIm1heFJldHJpZXNQZXJSZXF1ZXN0IGlzIG5lZ2F0aXZlLCBpZ25vcmluZy4uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IHNlbGYucmV0cnlBdHRlbXB0cyAlIChtYXhSZXRyaWVzUGVyUmVxdWVzdCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWFjaCBtYXhSZXRyaWVzUGVyUmVxdWVzdCBsaW1pdGF0aW9uLCBmbHVzaGluZyBjb21tYW5kIHF1ZXVlLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZsdXNoUXVldWUobmV3IGVycm9yc18xLk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IobWF4UmV0cmllc1BlclJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBzZWxmLnNldFN0YXR1cyhcImVuZFwiKTtcbiAgICAgICAgc2VsZi5mbHVzaFF1ZXVlKG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRykpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2xvc2VIYW5kbGVyID0gY2xvc2VIYW5kbGVyO1xuZnVuY3Rpb24gZXJyb3JIYW5kbGVyKHNlbGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGRlYnVnKFwiZXJyb3I6ICVzXCIsIGVycm9yKTtcbiAgICAgICAgc2VsZi5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgIH07XG59XG5leHBvcnRzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbmZ1bmN0aW9uIHJlYWR5SGFuZGxlcihzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJyZWFkeVwiKTtcbiAgICAgICAgc2VsZi5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5tb25pdG9yKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGwoXCJtb25pdG9yXCIpLnRoZW4oKCkgPT4gc2VsZi5zZXRTdGF0dXMoXCJtb25pdG9yaW5nXCIpLCAoZXJyb3IpID0+IHNlbGYuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICAgICAgICBjb25zdCB7IHNlbmRDb21tYW5kIH0gPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi5zZW5kQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIlZBTElEX0lOX01PTklUT1JfTU9ERVwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kQ29tbWFuZC5jYWxsKHNlbGYsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGlzIGluIG1vbml0b3JpbmcgbW9kZSwgY2FuJ3QgcHJvY2VzcyBjb21tYW5kcy5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLnNlbmRDb21tYW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxTZWxlY3QgPSBzZWxmLnByZXZDb25kaXRpb25cbiAgICAgICAgICAgID8gc2VsZi5wcmV2Q29uZGl0aW9uLnNlbGVjdFxuICAgICAgICAgICAgOiBzZWxmLmNvbmRpdGlvbi5zZWxlY3Q7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2V0IHRoZSBjb25uZWN0aW9uIG5hbWUgWyVzXVwiLCBzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgc2VsZi5jbGllbnQoXCJzZXRuYW1lXCIsIHNlbGYub3B0aW9ucy5jb25uZWN0aW9uTmFtZSkuY2F0Y2godXRpbHNfMS5ub29wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNldCB0aGUgY29ubmVjdGlvbiB0byByZWFkb25seSBtb2RlXCIpO1xuICAgICAgICAgICAgc2VsZi5yZWFkb25seSgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYucHJldkNvbmRpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gc2VsZi5wcmV2Q29uZGl0aW9uO1xuICAgICAgICAgICAgc2VsZi5wcmV2Q29uZGl0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24uc3Vic2NyaWJlciAmJiBzZWxmLm9wdGlvbnMuYXV0b1Jlc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmUtc2VsZWN0IHRoZSBwcmV2aW91cyBkYiBmaXJzdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIGBTRUxFQ1RgIGNvbW1hbmQgaXMgbm90IHZhbGlkIGluIHN1YiBtb2RlLlxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbi5zZWxlY3QgIT09IGZpbmFsU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCB0byBkYiBbJWRdXCIsIGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3QoZmluYWxTZWxlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVDaGFubmVscyA9IGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVDaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzdWJzY3JpYmUgJWQgY2hhbm5lbHNcIiwgc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdWJzY3JpYmUoc3Vic2NyaWJlQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwc3Vic2NyaWJlQ2hhbm5lbHMgPSBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInBzdWJzY3JpYmVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBzdWJzY3JpYmVDaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJwc3Vic2NyaWJlICVkIGNoYW5uZWxzXCIsIHBzdWJzY3JpYmVDaGFubmVscy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBzdWJzY3JpYmUocHN1YnNjcmliZUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3N1YnNjcmliZUNoYW5uZWxzID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJzc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic3N1YnNjcmliZSAlZCBjaGFubmVsc1wiLCBzc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zc3Vic2NyaWJlKHNzdWJzY3JpYmVDaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnByZXZDb21tYW5kUXVldWUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuYXV0b1Jlc2VuZFVuZnVsZmlsbGVkQ29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlc2VuZCAlZCB1bmZ1bGZpbGxlZCBjb21tYW5kc1wiLCBzZWxmLnByZXZDb21tYW5kUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VsZi5wcmV2Q29tbWFuZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNlbGYucHJldkNvbW1hbmRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QgIT09IHNlbGYuY29uZGl0aW9uLnNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLm5hbWUgIT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KGl0ZW0uc2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmRDb21tYW5kKGl0ZW0uY29tbWFuZCwgaXRlbS5zdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldkNvbW1hbmRRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub2ZmbGluZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoXCJzZW5kICVkIGNvbW1hbmRzIGluIG9mZmxpbmUgcXVldWVcIiwgc2VsZi5vZmZsaW5lUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmxpbmVRdWV1ZSA9IHNlbGYub2ZmbGluZVF1ZXVlO1xuICAgICAgICAgICAgc2VsZi5yZXNldE9mZmxpbmVRdWV1ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKG9mZmxpbmVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG9mZmxpbmVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdCAhPT0gc2VsZi5jb25kaXRpb24uc2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5uYW1lICE9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KGl0ZW0uc2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0ICE9PSBmaW5hbFNlbGVjdCkge1xuICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0IHRvIGRiIFslZF1cIiwgZmluYWxTZWxlY3QpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3QoZmluYWxTZWxlY3QpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/event_handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addTransactionSupport = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nfunction addTransactionSupport(redis) {\n    redis.pipeline = function (commands) {\n        const pipeline = new Pipeline_1.default(this);\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        return pipeline;\n    };\n    const { multi } = redis;\n    redis.multi = function (commands, options) {\n        if (typeof options === \"undefined\" && !Array.isArray(commands)) {\n            options = commands;\n            commands = null;\n        }\n        if (options && options.pipeline === false) {\n            return multi.call(this);\n        }\n        const pipeline = new Pipeline_1.default(this);\n        // @ts-expect-error\n        pipeline.multi();\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        const exec = pipeline.exec;\n        pipeline.exec = function (callback) {\n            // Wait for the cluster to be connected, since we need nodes information before continuing\n            if (this.isCluster && !this.redis.slots.length) {\n                if (this.redis.status === \"wait\")\n                    this.redis.connect().catch(utils_1.noop);\n                return (0, standard_as_callback_1.default)(new Promise((resolve, reject) => {\n                    this.redis.delayUntilReady((err) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        this.exec(pipeline).then(resolve, reject);\n                    });\n                }), callback);\n            }\n            if (this._transactions > 0) {\n                exec.call(pipeline);\n            }\n            // Returns directly when the pipeline\n            // has been called multiple times (retries).\n            if (this.nodeifiedPromise) {\n                return exec.call(pipeline);\n            }\n            const promise = exec.call(pipeline);\n            return (0, standard_as_callback_1.default)(promise.then(function (result) {\n                const execResult = result[result.length - 1];\n                if (typeof execResult === \"undefined\") {\n                    throw new Error(\"Pipeline cannot be used to send any commands when the `exec()` has been called on it.\");\n                }\n                if (execResult[0]) {\n                    execResult[0].previousErrors = [];\n                    for (let i = 0; i < result.length - 1; ++i) {\n                        if (result[i][0]) {\n                            execResult[0].previousErrors.push(result[i][0]);\n                        }\n                    }\n                    throw execResult[0];\n                }\n                return (0, utils_1.wrapMultiResult)(execResult[1]);\n            }), callback);\n        };\n        // @ts-expect-error\n        const { execBuffer } = pipeline;\n        // @ts-expect-error\n        pipeline.execBuffer = function (callback) {\n            if (this._transactions > 0) {\n                execBuffer.call(pipeline);\n            }\n            return pipeline.exec(callback);\n        };\n        return pipeline;\n    };\n    const { exec } = redis;\n    redis.exec = function (callback) {\n        return (0, standard_as_callback_1.default)(exec.call(this).then(function (results) {\n            if (Array.isArray(results)) {\n                results = (0, utils_1.wrapMultiResult)(results);\n            }\n            return results;\n        }), callback);\n    };\n}\nexports.addTransactionSupport = addTransactionSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVM7QUFDakMsK0JBQStCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLGtFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdHJhbnNhY3Rpb24uanM/YjY3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkVHJhbnNhY3Rpb25TdXBwb3J0ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IFBpcGVsaW5lXzEgPSByZXF1aXJlKFwiLi9QaXBlbGluZVwiKTtcbmZ1bmN0aW9uIGFkZFRyYW5zYWN0aW9uU3VwcG9ydChyZWRpcykge1xuICAgIHJlZGlzLnBpcGVsaW5lID0gZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gbmV3IFBpcGVsaW5lXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICBwaXBlbGluZS5hZGRCYXRjaChjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lO1xuICAgIH07XG4gICAgY29uc3QgeyBtdWx0aSB9ID0gcmVkaXM7XG4gICAgcmVkaXMubXVsdGkgPSBmdW5jdGlvbiAoY29tbWFuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiICYmICFBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbW1hbmRzO1xuICAgICAgICAgICAgY29tbWFuZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGlwZWxpbmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXBlbGluZSA9IG5ldyBQaXBlbGluZV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcGlwZWxpbmUubXVsdGkoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICBwaXBlbGluZS5hZGRCYXRjaChjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlYyA9IHBpcGVsaW5lLmV4ZWM7XG4gICAgICAgIHBpcGVsaW5lLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIGNvbm5lY3RlZCwgc2luY2Ugd2UgbmVlZCBub2RlcyBpbmZvcm1hdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyICYmICF0aGlzLnJlZGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29ubmVjdCgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5kZWxheVVudGlsUmVhZHkoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlYyhwaXBlbGluZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgICBleGVjLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJucyBkaXJlY3RseSB3aGVuIHRoZSBwaXBlbGluZVxuICAgICAgICAgICAgLy8gaGFzIGJlZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIChyZXRyaWVzKS5cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVpZmllZFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBleGVjLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY1Jlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGVjUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBpcGVsaW5lIGNhbm5vdCBiZSB1c2VkIHRvIHNlbmQgYW55IGNvbW1hbmRzIHdoZW4gdGhlIGBleGVjKClgIGhhcyBiZWVuIGNhbGxlZCBvbiBpdC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleGVjUmVzdWx0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbMF0ucHJldmlvdXNFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1Jlc3VsdFswXS5wcmV2aW91c0Vycm9ycy5wdXNoKHJlc3VsdFtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXhlY1Jlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLndyYXBNdWx0aVJlc3VsdCkoZXhlY1Jlc3VsdFsxXSk7XG4gICAgICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHsgZXhlY0J1ZmZlciB9ID0gcGlwZWxpbmU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcGlwZWxpbmUuZXhlY0J1ZmZlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgICBleGVjQnVmZmVyLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpcGVsaW5lLmV4ZWMoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGlwZWxpbmU7XG4gICAgfTtcbiAgICBjb25zdCB7IGV4ZWMgfSA9IHJlZGlzO1xuICAgIHJlZGlzLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKGV4ZWMuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSAoMCwgdXRpbHNfMS53cmFwTXVsdGlSZXN1bHQpKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYWRkVHJhbnNhY3Rpb25TdXBwb3J0ID0gYWRkVHJhbnNhY3Rpb25TdXBwb3J0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/Commander.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/utils/Commander.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst autoPipelining_1 = __webpack_require__(/*! ../autoPipelining */ \"(rsc)/./node_modules/ioredis/built/autoPipelining.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst Script_1 = __webpack_require__(/*! ../Script */ \"(rsc)/./node_modules/ioredis/built/Script.js\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass Commander {\n    constructor() {\n        this.options = {};\n        /**\n         * @ignore\n         */\n        this.scriptsSet = {};\n        /**\n         * @ignore\n         */\n        this.addedBuiltinSet = new Set();\n    }\n    /**\n     * Return supported builtin commands\n     */\n    getBuiltinCommands() {\n        return commands.slice(0);\n    }\n    /**\n     * Create a builtin command\n     */\n    createBuiltinCommand(commandName) {\n        return {\n            string: generateFunction(null, commandName, \"utf8\"),\n            buffer: generateFunction(null, commandName, null),\n        };\n    }\n    /**\n     * Create add builtin command\n     */\n    addBuiltinCommand(commandName) {\n        this.addedBuiltinSet.add(commandName);\n        this[commandName] = generateFunction(commandName, commandName, \"utf8\");\n        this[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n    }\n    /**\n     * Define a custom command using lua script\n     */\n    defineCommand(name, definition) {\n        const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);\n        this.scriptsSet[name] = script;\n        this[name] = generateScriptingFunction(name, name, script, \"utf8\");\n        this[name + \"Buffer\"] = generateScriptingFunction(name + \"Buffer\", name, script, null);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        throw new Error('\"sendCommand\" is not implemented');\n    }\n}\nconst commands = commands_1.list.filter((command) => command !== \"monitor\");\ncommands.push(\"sentinel\");\ncommands.forEach(function (commandName) {\n    Commander.prototype[commandName] = generateFunction(commandName, commandName, \"utf8\");\n    Commander.prototype[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n});\nCommander.prototype.call = generateFunction(\"call\", \"utf8\");\nCommander.prototype.callBuffer = generateFunction(\"callBuffer\", null);\n// @ts-expect-error\nCommander.prototype.send_command = Commander.prototype.call;\nfunction generateFunction(functionName, _commandName, _encoding) {\n    if (typeof _encoding === \"undefined\") {\n        _encoding = _commandName;\n        _commandName = null;\n    }\n    return function (...args) {\n        const commandName = (_commandName || args.shift());\n        let callback = args[args.length - 1];\n        if (typeof callback === \"function\") {\n            args.pop();\n        }\n        else {\n            callback = undefined;\n        }\n        const options = {\n            errorStack: this.options.showFriendlyErrorStack ? new Error() : undefined,\n            keyPrefix: this.options.keyPrefix,\n            replyEncoding: _encoding,\n        };\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return this.sendCommand(\n            // @ts-expect-error\n            new Command_1.default(commandName, args, options, callback));\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, \n        // @ts-expect-error\n        args, callback);\n    };\n}\nfunction generateScriptingFunction(functionName, commandName, script, encoding) {\n    return function (...args) {\n        const callback = typeof args[args.length - 1] === \"function\" ? args.pop() : undefined;\n        const options = {\n            replyEncoding: encoding,\n        };\n        if (this.options.showFriendlyErrorStack) {\n            options.errorStack = new Error();\n        }\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return script.execute(this, args, options, callback);\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);\n    };\n}\nexports[\"default\"] = Commander;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9Db21tYW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLCtFQUFtQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRUFBWTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQywrREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3V0aWxzL0NvbW1hbmRlci5qcz9mNjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IGF1dG9QaXBlbGluaW5nXzEgPSByZXF1aXJlKFwiLi4vYXV0b1BpcGVsaW5pbmdcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi4vQ29tbWFuZFwiKTtcbmNvbnN0IFNjcmlwdF8xID0gcmVxdWlyZShcIi4uL1NjcmlwdFwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmNsYXNzIENvbW1hbmRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JpcHRzU2V0ID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZGVkQnVpbHRpblNldCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHN1cHBvcnRlZCBidWlsdGluIGNvbW1hbmRzXG4gICAgICovXG4gICAgZ2V0QnVpbHRpbkNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2xpY2UoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGJ1aWx0aW4gY29tbWFuZFxuICAgICAqL1xuICAgIGNyZWF0ZUJ1aWx0aW5Db21tYW5kKGNvbW1hbmROYW1lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJpbmc6IGdlbmVyYXRlRnVuY3Rpb24obnVsbCwgY29tbWFuZE5hbWUsIFwidXRmOFwiKSxcbiAgICAgICAgICAgIGJ1ZmZlcjogZ2VuZXJhdGVGdW5jdGlvbihudWxsLCBjb21tYW5kTmFtZSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhZGQgYnVpbHRpbiBjb21tYW5kXG4gICAgICovXG4gICAgYWRkQnVpbHRpbkNvbW1hbmQoY29tbWFuZE5hbWUpIHtcbiAgICAgICAgdGhpcy5hZGRlZEJ1aWx0aW5TZXQuYWRkKGNvbW1hbmROYW1lKTtcbiAgICAgICAgdGhpc1tjb21tYW5kTmFtZV0gPSBnZW5lcmF0ZUZ1bmN0aW9uKGNvbW1hbmROYW1lLCBjb21tYW5kTmFtZSwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzW2NvbW1hbmROYW1lICsgXCJCdWZmZXJcIl0gPSBnZW5lcmF0ZUZ1bmN0aW9uKGNvbW1hbmROYW1lICsgXCJCdWZmZXJcIiwgY29tbWFuZE5hbWUsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBjdXN0b20gY29tbWFuZCB1c2luZyBsdWEgc2NyaXB0XG4gICAgICovXG4gICAgZGVmaW5lQ29tbWFuZChuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IG5ldyBTY3JpcHRfMS5kZWZhdWx0KGRlZmluaXRpb24ubHVhLCBkZWZpbml0aW9uLm51bWJlck9mS2V5cywgdGhpcy5vcHRpb25zLmtleVByZWZpeCwgZGVmaW5pdGlvbi5yZWFkT25seSk7XG4gICAgICAgIHRoaXMuc2NyaXB0c1NldFtuYW1lXSA9IHNjcmlwdDtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGdlbmVyYXRlU2NyaXB0aW5nRnVuY3Rpb24obmFtZSwgbmFtZSwgc2NyaXB0LCBcInV0ZjhcIik7XG4gICAgICAgIHRoaXNbbmFtZSArIFwiQnVmZmVyXCJdID0gZ2VuZXJhdGVTY3JpcHRpbmdGdW5jdGlvbihuYW1lICsgXCJCdWZmZXJcIiwgbmFtZSwgc2NyaXB0LCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQsIHN0cmVhbSwgbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2VuZENvbW1hbmRcIiBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5jb25zdCBjb21tYW5kcyA9IGNvbW1hbmRzXzEubGlzdC5maWx0ZXIoKGNvbW1hbmQpID0+IGNvbW1hbmQgIT09IFwibW9uaXRvclwiKTtcbmNvbW1hbmRzLnB1c2goXCJzZW50aW5lbFwiKTtcbmNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmROYW1lKSB7XG4gICAgQ29tbWFuZGVyLnByb3RvdHlwZVtjb21tYW5kTmFtZV0gPSBnZW5lcmF0ZUZ1bmN0aW9uKGNvbW1hbmROYW1lLCBjb21tYW5kTmFtZSwgXCJ1dGY4XCIpO1xuICAgIENvbW1hbmRlci5wcm90b3R5cGVbY29tbWFuZE5hbWUgKyBcIkJ1ZmZlclwiXSA9IGdlbmVyYXRlRnVuY3Rpb24oY29tbWFuZE5hbWUgKyBcIkJ1ZmZlclwiLCBjb21tYW5kTmFtZSwgbnVsbCk7XG59KTtcbkNvbW1hbmRlci5wcm90b3R5cGUuY2FsbCA9IGdlbmVyYXRlRnVuY3Rpb24oXCJjYWxsXCIsIFwidXRmOFwiKTtcbkNvbW1hbmRlci5wcm90b3R5cGUuY2FsbEJ1ZmZlciA9IGdlbmVyYXRlRnVuY3Rpb24oXCJjYWxsQnVmZmVyXCIsIG51bGwpO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuQ29tbWFuZGVyLnByb3RvdHlwZS5zZW5kX2NvbW1hbmQgPSBDb21tYW5kZXIucHJvdG90eXBlLmNhbGw7XG5mdW5jdGlvbiBnZW5lcmF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgX2NvbW1hbmROYW1lLCBfZW5jb2RpbmcpIHtcbiAgICBpZiAodHlwZW9mIF9lbmNvZGluZyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBfZW5jb2RpbmcgPSBfY29tbWFuZE5hbWU7XG4gICAgICAgIF9jb21tYW5kTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBjb21tYW5kTmFtZSA9IChfY29tbWFuZE5hbWUgfHwgYXJncy5zaGlmdCgpKTtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZXJyb3JTdGFjazogdGhpcy5vcHRpb25zLnNob3dGcmllbmRseUVycm9yU3RhY2sgPyBuZXcgRXJyb3IoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleVByZWZpeDogdGhpcy5vcHRpb25zLmtleVByZWZpeCxcbiAgICAgICAgICAgIHJlcGx5RW5jb2Rpbmc6IF9lbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm8gYXV0byBwaXBlbGluZSwgdXNlIHJlZ3VsYXIgY29tbWFuZCBzZW5kaW5nXG4gICAgICAgIGlmICghKDAsIGF1dG9QaXBlbGluaW5nXzEuc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcpKHRoaXMsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQ29tbWFuZChcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIG5ldyBDb21tYW5kXzEuZGVmYXVsdChjb21tYW5kTmFtZSwgYXJncywgb3B0aW9ucywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGlwZWxpbmUgYW5kIG1ha2Ugc3VyZSBpdCdzIHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gKDAsIGF1dG9QaXBlbGluaW5nXzEuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZykodGhpcywgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNjcmlwdGluZ0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIHNjcmlwdCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIgPyBhcmdzLnBvcCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVwbHlFbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0ZyaWVuZGx5RXJyb3JTdGFjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5lcnJvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gYXV0byBwaXBlbGluZSwgdXNlIHJlZ3VsYXIgY29tbWFuZCBzZW5kaW5nXG4gICAgICAgIGlmICghKDAsIGF1dG9QaXBlbGluaW5nXzEuc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcpKHRoaXMsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LmV4ZWN1dGUodGhpcywgYXJncywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwaXBlbGluZSBhbmQgbWFrZSBzdXJlIGl0J3Mgc2NoZWR1bGVkXG4gICAgICAgIHJldHVybiAoMCwgYXV0b1BpcGVsaW5pbmdfMS5leGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBhcmdzLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1hbmRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/Commander.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/applyMixin.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/utils/applyMixin.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction applyMixin(derivedConstructor, mixinConstructor) {\n    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {\n        Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));\n    });\n}\nexports[\"default\"] = applyMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9hcHBseU1peGluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvYXBwbHlNaXhpbi5qcz85NmMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gYXBwbHlNaXhpbihkZXJpdmVkQ29uc3RydWN0b3IsIG1peGluQ29uc3RydWN0b3IpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtaXhpbkNvbnN0cnVjdG9yLnByb3RvdHlwZSkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZSwgbmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtaXhpbkNvbnN0cnVjdG9yLnByb3RvdHlwZSwgbmFtZSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYXBwbHlNaXhpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/debug.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/debug.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\nconst MAX_ARGUMENT_LENGTH = 200;\nexports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;\nconst NAMESPACE_PREFIX = \"ioredis\";\n/**\n * helper function that tried to get a string value for\n * arbitrary \"debug\" arg\n */\nfunction getStringValue(v) {\n    if (v === null) {\n        return;\n    }\n    switch (typeof v) {\n        case \"boolean\":\n            return;\n        case \"number\":\n            return;\n        case \"object\":\n            if (Buffer.isBuffer(v)) {\n                return v.toString(\"hex\");\n            }\n            if (Array.isArray(v)) {\n                return v.join(\",\");\n            }\n            try {\n                return JSON.stringify(v);\n            }\n            catch (e) {\n                return;\n            }\n        case \"string\":\n            return v;\n    }\n}\nexports.getStringValue = getStringValue;\n/**\n * helper function that redacts a string representation of a \"debug\" arg\n */\nfunction genRedactedString(str, maxLen) {\n    const { length } = str;\n    return length <= maxLen\n        ? str\n        : str.slice(0, maxLen) + ' ... <REDACTED full-length=\"' + length + '\">';\n}\nexports.genRedactedString = genRedactedString;\n/**\n * a wrapper for the `debug` module, used to generate\n * \"debug functions\" that trim the values in their output\n */\nfunction genDebugFunction(namespace) {\n    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);\n    function wrappedDebug(...args) {\n        if (!fn.enabled) {\n            return; // no-op\n        }\n        // we skip the first arg because that is the message\n        for (let i = 1; i < args.length; i++) {\n            const str = getStringValue(args[i]);\n            if (typeof str === \"string\" && str.length > MAX_ARGUMENT_LENGTH) {\n                args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);\n            }\n        }\n        return fn.apply(null, args);\n    }\n    Object.defineProperties(wrappedDebug, {\n        namespace: {\n            get() {\n                return fn.namespace;\n            },\n        },\n        enabled: {\n            get() {\n                return fn.enabled;\n            },\n        },\n        destroy: {\n            get() {\n                return fn.destroy;\n            },\n        },\n        log: {\n            get() {\n                return fn.log;\n            },\n            set(l) {\n                fn.log = l;\n            },\n        },\n    });\n    return wrappedDebug;\n}\nexports[\"default\"] = genDebugFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkI7QUFDaEYsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQU87QUFDL0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUIsR0FBRyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvZGVidWcuanM/NzgzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuUmVkYWN0ZWRTdHJpbmcgPSBleHBvcnRzLmdldFN0cmluZ1ZhbHVlID0gZXhwb3J0cy5NQVhfQVJHVU1FTlRfTEVOR1RIID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IE1BWF9BUkdVTUVOVF9MRU5HVEggPSAyMDA7XG5leHBvcnRzLk1BWF9BUkdVTUVOVF9MRU5HVEggPSBNQVhfQVJHVU1FTlRfTEVOR1RIO1xuY29uc3QgTkFNRVNQQUNFX1BSRUZJWCA9IFwiaW9yZWRpc1wiO1xuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdGhhdCB0cmllZCB0byBnZXQgYSBzdHJpbmcgdmFsdWUgZm9yXG4gKiBhcmJpdHJhcnkgXCJkZWJ1Z1wiIGFyZ1xuICovXG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh2KSB7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZTtcbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmVkYWN0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFwiZGVidWdcIiBhcmdcbiAqL1xuZnVuY3Rpb24gZ2VuUmVkYWN0ZWRTdHJpbmcoc3RyLCBtYXhMZW4pIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RyO1xuICAgIHJldHVybiBsZW5ndGggPD0gbWF4TGVuXG4gICAgICAgID8gc3RyXG4gICAgICAgIDogc3RyLnNsaWNlKDAsIG1heExlbikgKyAnIC4uLiA8UkVEQUNURUQgZnVsbC1sZW5ndGg9XCInICsgbGVuZ3RoICsgJ1wiPic7XG59XG5leHBvcnRzLmdlblJlZGFjdGVkU3RyaW5nID0gZ2VuUmVkYWN0ZWRTdHJpbmc7XG4vKipcbiAqIGEgd3JhcHBlciBmb3IgdGhlIGBkZWJ1Z2AgbW9kdWxlLCB1c2VkIHRvIGdlbmVyYXRlXG4gKiBcImRlYnVnIGZ1bmN0aW9uc1wiIHRoYXQgdHJpbSB0aGUgdmFsdWVzIGluIHRoZWlyIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZW5EZWJ1Z0Z1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IGZuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TkFNRVNQQUNFX1BSRUZJWH06JHtuYW1lc3BhY2V9YCk7XG4gICAgZnVuY3Rpb24gd3JhcHBlZERlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFmbi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vLW9wXG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugc2tpcCB0aGUgZmlyc3QgYXJnIGJlY2F1c2UgdGhhdCBpcyB0aGUgbWVzc2FnZVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGdldFN0cmluZ1ZhbHVlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgc3RyLmxlbmd0aCA+IE1BWF9BUkdVTUVOVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gZ2VuUmVkYWN0ZWRTdHJpbmcoc3RyLCBNQVhfQVJHVU1FTlRfTEVOR1RIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWREZWJ1Zywge1xuICAgICAgICBuYW1lc3BhY2U6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmFtZXNwYWNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5lbmFibGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5kZXN0cm95O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbG9nOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmxvZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQobCkge1xuICAgICAgICAgICAgICAgIGZuLmxvZyA9IGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkRGVidWc7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZW5EZWJ1Z0Z1bmN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = void 0;\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst lodash_1 = __webpack_require__(/*! ./lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nObject.defineProperty(exports, \"defaults\", ({ enumerable: true, get: function () { return lodash_1.defaults; } }));\nObject.defineProperty(exports, \"noop\", ({ enumerable: true, get: function () { return lodash_1.noop; } }));\nconst debug_1 = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/ioredis/built/utils/debug.js\");\nexports.Debug = debug_1.default;\nconst TLSProfiles_1 = __webpack_require__(/*! ../constants/TLSProfiles */ \"(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\");\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @example\n * ```js\n * const input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * const res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n */\nfunction convertBufferToString(value, encoding) {\n    if (value instanceof Buffer) {\n        return value.toString(encoding);\n    }\n    if (Array.isArray(value)) {\n        const length = value.length;\n        const res = Array(length);\n        for (let i = 0; i < length; ++i) {\n            res[i] =\n                value[i] instanceof Buffer && encoding === \"utf8\"\n                    ? value[i].toString()\n                    : convertBufferToString(value[i], encoding);\n        }\n        return res;\n    }\n    return value;\n}\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @example\n * ```js\n * const input = ['a', 'b', new Error('c'), 'd']\n * const output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n */\nfunction wrapMultiResult(arr) {\n    // When using WATCH/EXEC transactions, the EXEC will return\n    // a null instead of an array\n    if (!arr) {\n        return null;\n    }\n    const result = [];\n    const length = arr.length;\n    for (let i = 0; i < length; ++i) {\n        const item = arr[i];\n        if (item instanceof Error) {\n            result.push([item]);\n        }\n        else {\n            result.push([null, item]);\n        }\n    }\n    return result;\n}\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect if the argument is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n */\nfunction isInt(value) {\n    const x = parseFloat(value);\n    return !isNaN(value) && (x | 0) === x;\n}\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */\nfunction packObject(array) {\n    const result = {};\n    const length = array.length;\n    for (let i = 1; i < length; i += 2) {\n        result[array[i - 1]] = array[i];\n    }\n    return result;\n}\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n */\nfunction timeout(callback, timeout) {\n    let timer = null;\n    const run = function () {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            callback.apply(this, arguments);\n        }\n    };\n    timer = setTimeout(run, timeout, new Error(\"timeout\"));\n    return run;\n}\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */\nfunction convertObjectToArray(obj) {\n    const result = [];\n    const keys = Object.keys(obj); // Object.entries requires node 7+\n    for (let i = 0, l = keys.length; i < l; i++) {\n        result.push(keys[i], obj[keys[i]]);\n    }\n    return result;\n}\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n * @example\n * ```js\n * > convertMapToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */\nfunction convertMapToArray(map) {\n    const result = [];\n    let pos = 0;\n    map.forEach(function (value, key) {\n        result[pos] = key;\n        result[pos + 1] = value;\n        pos += 2;\n    });\n    return result;\n}\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n */\nfunction toArg(arg) {\n    if (arg === null || typeof arg === \"undefined\") {\n        return \"\";\n    }\n    return String(arg);\n}\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param error actually error\n * @param friendlyStack the stack that more meaningful\n * @param filterPath only show stacks with the specified path\n */\nfunction optimizeErrorStack(error, friendlyStack, filterPath) {\n    const stacks = friendlyStack.split(\"\\n\");\n    let lines = \"\";\n    let i;\n    for (i = 1; i < stacks.length; ++i) {\n        if (stacks[i].indexOf(filterPath) === -1) {\n            break;\n        }\n    }\n    for (let j = i; j < stacks.length; ++j) {\n        lines += \"\\n\" + stacks[j];\n    }\n    if (error.stack) {\n        const pos = error.stack.indexOf(\"\\n\");\n        error.stack = error.stack.slice(0, pos) + lines;\n    }\n    return error;\n}\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n */\nfunction parseURL(url) {\n    if (isInt(url)) {\n        return { port: url };\n    }\n    let parsed = (0, url_1.parse)(url, true, true);\n    if (!parsed.slashes && url[0] !== \"/\") {\n        url = \"//\" + url;\n        parsed = (0, url_1.parse)(url, true, true);\n    }\n    const options = parsed.query || {};\n    const result = {};\n    if (parsed.auth) {\n        const index = parsed.auth.indexOf(\":\");\n        result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);\n        result.password = index === -1 ? \"\" : parsed.auth.slice(index + 1);\n    }\n    if (parsed.pathname) {\n        if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n            if (parsed.pathname.length > 1) {\n                result.db = parsed.pathname.slice(1);\n            }\n        }\n        else {\n            result.path = parsed.pathname;\n        }\n    }\n    if (parsed.host) {\n        result.host = parsed.hostname;\n    }\n    if (parsed.port) {\n        result.port = parsed.port;\n    }\n    if (typeof options.family === \"string\") {\n        const intFamily = Number.parseInt(options.family, 10);\n        if (!Number.isNaN(intFamily)) {\n            result.family = intFamily;\n        }\n    }\n    (0, lodash_1.defaults)(result, options);\n    return result;\n}\nexports.parseURL = parseURL;\n/**\n * Resolve TLS profile shortcut in connection options\n */\nfunction resolveTLSProfile(options) {\n    let tls = options === null || options === void 0 ? void 0 : options.tls;\n    if (typeof tls === \"string\")\n        tls = { profile: tls };\n    const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];\n    if (profile) {\n        tls = Object.assign({}, profile, tls);\n        delete tls.profile;\n        options = Object.assign({}, options, { tls });\n    }\n    return options;\n}\nexports.resolveTLSProfile = resolveTLSProfile;\n/**\n * Get a random element from `array`\n */\nfunction sample(array, from = 0) {\n    const length = array.length;\n    if (from >= length) {\n        return null;\n    }\n    return array[from + Math.floor(Math.random() * (length - from))];\n}\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n */\nfunction shuffle(array) {\n    let counter = array.length;\n    // While there are elements in the array\n    while (counter > 0) {\n        // Pick a random index\n        const index = Math.floor(Math.random() * counter);\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        [array[counter], array[index]] = [array[index], array[counter]];\n    }\n    return array;\n}\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */\nexports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\nfunction zipMap(keys, values) {\n    const map = new Map();\n    keys.forEach((key, index) => {\n        map.set(key, values[index]);\n    });\n    return map;\n}\nexports.zipMap = zipMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxtQ0FBbUMsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLHlCQUF5QixHQUFHLGdCQUFnQixHQUFHLDBCQUEwQixHQUFHLGFBQWEsR0FBRyx5QkFBeUIsR0FBRyw0QkFBNEIsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsYUFBYSxHQUFHLHVCQUF1QixHQUFHLDZCQUE2QjtBQUNqWixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVU7QUFDbkMsNENBQTJDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2hILHdDQUF1QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN4RyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQyxhQUFhO0FBQ2Isc0JBQXNCLG1CQUFPLENBQUMsNkZBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGtDQUFrQyxhQUFhLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvaW5kZXguanM/ZWNhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9vcCA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLkRlYnVnID0gZXhwb3J0cy56aXBNYXAgPSBleHBvcnRzLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyA9IGV4cG9ydHMuc2h1ZmZsZSA9IGV4cG9ydHMuc2FtcGxlID0gZXhwb3J0cy5yZXNvbHZlVExTUHJvZmlsZSA9IGV4cG9ydHMucGFyc2VVUkwgPSBleHBvcnRzLm9wdGltaXplRXJyb3JTdGFjayA9IGV4cG9ydHMudG9BcmcgPSBleHBvcnRzLmNvbnZlcnRNYXBUb0FycmF5ID0gZXhwb3J0cy5jb252ZXJ0T2JqZWN0VG9BcnJheSA9IGV4cG9ydHMudGltZW91dCA9IGV4cG9ydHMucGFja09iamVjdCA9IGV4cG9ydHMuaXNJbnQgPSBleHBvcnRzLndyYXBNdWx0aVJlc3VsdCA9IGV4cG9ydHMuY29udmVydEJ1ZmZlclRvU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgbG9kYXNoXzEgPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9kYXNoXzEuZGVmYXVsdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub29wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2Rhc2hfMS5ub29wOyB9IH0pO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCIuL2RlYnVnXCIpO1xuZXhwb3J0cy5EZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdDtcbmNvbnN0IFRMU1Byb2ZpbGVzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzL1RMU1Byb2ZpbGVzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnVmZmVyIHRvIHN0cmluZywgc3VwcG9ydHMgYnVmZmVyIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBpbnB1dCA9IFtCdWZmZXIuZnJvbSgnZm9vJyksIFtCdWZmZXIuZnJvbSgnYmFyJyldXVxuICogY29uc3QgcmVzID0gY29udmVydEJ1ZmZlclRvU3RyaW5nKGlucHV0LCAndXRmOCcpXG4gKiBleHBlY3QocmVzKS50by5lcWwoWydmb28nLCBbJ2JhciddXSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjb252ZXJ0QnVmZmVyVG9TdHJpbmcodmFsdWUsIGVuY29kaW5nKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gaW5zdGFuY2VvZiBCdWZmZXIgJiYgZW5jb2RpbmcgPT09IFwidXRmOFwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVbaV0udG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnZlcnRCdWZmZXJUb1N0cmluZyh2YWx1ZVtpXSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuY29udmVydEJ1ZmZlclRvU3RyaW5nID0gY29udmVydEJ1ZmZlclRvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgbGlzdCBvZiByZXN1bHRzIHRvIG5vZGUtc3R5bGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGlucHV0ID0gWydhJywgJ2InLCBuZXcgRXJyb3IoJ2MnKSwgJ2QnXVxuICogY29uc3Qgb3V0cHV0ID0gZXhwb3J0cy53cmFwTXVsdGlSZXN1bHQoaW5wdXQpXG4gKiBleHBlY3Qob3V0cHV0KS50by5lcWwoW1tudWxsLCAnYSddLCBbbnVsbCwgJ2InXSwgW25ldyBFcnJvcignYycpXSwgW251bGwsICdkJ10pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gd3JhcE11bHRpUmVzdWx0KGFycikge1xuICAgIC8vIFdoZW4gdXNpbmcgV0FUQ0gvRVhFQyB0cmFuc2FjdGlvbnMsIHRoZSBFWEVDIHdpbGwgcmV0dXJuXG4gICAgLy8gYSBudWxsIGluc3RlYWQgb2YgYW4gYXJyYXlcbiAgICBpZiAoIWFycikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJbaV07XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtpdGVtXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbnVsbCwgaXRlbV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLndyYXBNdWx0aVJlc3VsdCA9IHdyYXBNdWx0aVJlc3VsdDtcbi8qKlxuICogRGV0ZWN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIGludFxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiA+IGlzSW50KCcxMjMnKVxuICogdHJ1ZVxuICogPiBpc0ludCgnMTIzLjMnKVxuICogZmFsc2VcbiAqID4gaXNJbnQoJzF4JylcbiAqIGZhbHNlXG4gKiA+IGlzSW50KDEyMylcbiAqIHRydWVcbiAqID4gaXNJbnQodHJ1ZSlcbiAqIGZhbHNlXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gaXNJbnQodmFsdWUpIHtcbiAgICBjb25zdCB4ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgcmV0dXJuICFpc05hTih2YWx1ZSkgJiYgKHggfCAwKSA9PT0geDtcbn1cbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbi8qKlxuICogUGFjayBhbiBhcnJheSB0byBhbiBPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gcGFja09iamVjdChbJ2EnLCAnYicsICdjJywgJ2QnXSlcbiAqIHsgYTogJ2InLCBjOiAnZCcgfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHBhY2tPYmplY3QoYXJyYXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICByZXN1bHRbYXJyYXlbaSAtIDFdXSA9IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYWNrT2JqZWN0ID0gcGFja09iamVjdDtcbi8qKlxuICogUmV0dXJuIGEgY2FsbGJhY2sgd2l0aCB0aW1lb3V0XG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgIGNvbnN0IHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KHJ1biwgdGltZW91dCwgbmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFuIGFycmF5XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gY29udmVydE9iamVjdFRvQXJyYXkoeyBhOiAnMScgfSlcbiAqIFsnYScsICcxJ11cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0VG9BcnJheShvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTsgLy8gT2JqZWN0LmVudHJpZXMgcmVxdWlyZXMgbm9kZSA3K1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29udmVydE9iamVjdFRvQXJyYXkgPSBjb252ZXJ0T2JqZWN0VG9BcnJheTtcbi8qKlxuICogQ29udmVydCBhIG1hcCB0byBhbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiA+IGNvbnZlcnRNYXBUb0FycmF5KG5ldyBNYXAoW1sxLCAnMiddXSkpXG4gKiBbMSwgJzInXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRNYXBUb0FycmF5KG1hcCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtwb3NdID0ga2V5O1xuICAgICAgICByZXN1bHRbcG9zICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29udmVydE1hcFRvQXJyYXkgPSBjb252ZXJ0TWFwVG9BcnJheTtcbi8qKlxuICogQ29udmVydCBhIG5vbi1zdHJpbmcgYXJnIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHRvQXJnKGFyZykge1xuICAgIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhcmcpO1xufVxuZXhwb3J0cy50b0FyZyA9IHRvQXJnO1xuLyoqXG4gKiBPcHRpbWl6ZSBlcnJvciBzdGFja1xuICpcbiAqIEBwYXJhbSBlcnJvciBhY3R1YWxseSBlcnJvclxuICogQHBhcmFtIGZyaWVuZGx5U3RhY2sgdGhlIHN0YWNrIHRoYXQgbW9yZSBtZWFuaW5nZnVsXG4gKiBAcGFyYW0gZmlsdGVyUGF0aCBvbmx5IHNob3cgc3RhY2tzIHdpdGggdGhlIHNwZWNpZmllZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplRXJyb3JTdGFjayhlcnJvciwgZnJpZW5kbHlTdGFjaywgZmlsdGVyUGF0aCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IGZyaWVuZGx5U3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgbGV0IGxpbmVzID0gXCJcIjtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdGFja3NbaV0uaW5kZXhPZihmaWx0ZXJQYXRoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqIDwgc3RhY2tzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGxpbmVzICs9IFwiXFxuXCIgKyBzdGFja3Nbal07XG4gICAgfVxuICAgIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICBjb25zdCBwb3MgPSBlcnJvci5zdGFjay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnNsaWNlKDAsIHBvcykgKyBsaW5lcztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5vcHRpbWl6ZUVycm9yU3RhY2sgPSBvcHRpbWl6ZUVycm9yU3RhY2s7XG4vKipcbiAqIFBhcnNlIHRoZSByZWRpcyBwcm90b2NvbCB1cmxcbiAqL1xuZnVuY3Rpb24gcGFyc2VVUkwodXJsKSB7XG4gICAgaWYgKGlzSW50KHVybCkpIHtcbiAgICAgICAgcmV0dXJuIHsgcG9ydDogdXJsIH07XG4gICAgfVxuICAgIGxldCBwYXJzZWQgPSAoMCwgdXJsXzEucGFyc2UpKHVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKCFwYXJzZWQuc2xhc2hlcyAmJiB1cmxbMF0gIT09IFwiL1wiKSB7XG4gICAgICAgIHVybCA9IFwiLy9cIiArIHVybDtcbiAgICAgICAgcGFyc2VkID0gKDAsIHVybF8xLnBhcnNlKSh1cmwsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gcGFyc2VkLnF1ZXJ5IHx8IHt9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChwYXJzZWQuYXV0aCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlZC5hdXRoLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICByZXN1bHQudXNlcm5hbWUgPSBpbmRleCA9PT0gLTEgPyBwYXJzZWQuYXV0aCA6IHBhcnNlZC5hdXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgcmVzdWx0LnBhc3N3b3JkID0gaW5kZXggPT09IC0xID8gXCJcIiA6IHBhcnNlZC5hdXRoLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhcnNlZC5wcm90b2NvbCA9PT0gXCJyZWRpczpcIiB8fCBwYXJzZWQucHJvdG9jb2wgPT09IFwicmVkaXNzOlwiKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGIgPSBwYXJzZWQucGF0aG5hbWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGF0aCA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSBwYXJzZWQuaG9zdG5hbWU7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucG9ydCkge1xuICAgICAgICByZXN1bHQucG9ydCA9IHBhcnNlZC5wb3J0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmFtaWx5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGludEZhbWlseSA9IE51bWJlci5wYXJzZUludChvcHRpb25zLmZhbWlseSwgMTApO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihpbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gaW50RmFtaWx5O1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykocmVzdWx0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVVSTCA9IHBhcnNlVVJMO1xuLyoqXG4gKiBSZXNvbHZlIFRMUyBwcm9maWxlIHNob3J0Y3V0IGluIGNvbm5lY3Rpb24gb3B0aW9uc1xuICovXG5mdW5jdGlvbiByZXNvbHZlVExTUHJvZmlsZShvcHRpb25zKSB7XG4gICAgbGV0IHRscyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50bHM7XG4gICAgaWYgKHR5cGVvZiB0bHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHRscyA9IHsgcHJvZmlsZTogdGxzIH07XG4gICAgY29uc3QgcHJvZmlsZSA9IFRMU1Byb2ZpbGVzXzEuZGVmYXVsdFt0bHMgPT09IG51bGwgfHwgdGxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0bHMucHJvZmlsZV07XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgdGxzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvZmlsZSwgdGxzKTtcbiAgICAgICAgZGVsZXRlIHRscy5wcm9maWxlO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bHMgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5yZXNvbHZlVExTUHJvZmlsZSA9IHJlc29sdmVUTFNQcm9maWxlO1xuLyoqXG4gKiBHZXQgYSByYW5kb20gZWxlbWVudCBmcm9tIGBhcnJheWBcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGFycmF5LCBmcm9tID0gMCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtmcm9tICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGxlbmd0aCAtIGZyb20pKV07XG59XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcbi8qKlxuICogU2h1ZmZsZSB0aGUgYXJyYXkgdXNpbmcgdGhlIEZpc2hlci1ZYXRlcyBTaHVmZmxlLlxuICogVGhpcyBtZXRob2Qgd2lsbCBtdXRhdGUgdGhlIG9yaWdpbmFsIGFycmF5LlxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgbGV0IGNvdW50ZXIgPSBhcnJheS5sZW5ndGg7XG4gICAgLy8gV2hpbGUgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICAgIHdoaWxlIChjb3VudGVyID4gMCkge1xuICAgICAgICAvLyBQaWNrIGEgcmFuZG9tIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY291bnRlcik7XG4gICAgICAgIC8vIERlY3JlYXNlIGNvdW50ZXIgYnkgMVxuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIC8vIEFuZCBzd2FwIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCBpdFxuICAgICAgICBbYXJyYXlbY291bnRlcl0sIGFycmF5W2luZGV4XV0gPSBbYXJyYXlbaW5kZXhdLCBhcnJheVtjb3VudGVyXV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG4vKipcbiAqIEVycm9yIG1lc3NhZ2UgZm9yIGNvbm5lY3Rpb24gYmVpbmcgZGlzY29ubmVjdGVkXG4gKi9cbmV4cG9ydHMuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHID0gXCJDb25uZWN0aW9uIGlzIGNsb3NlZC5cIjtcbmZ1bmN0aW9uIHppcE1hcChrZXlzLCB2YWx1ZXMpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZXNbaW5kZXhdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwO1xufVxuZXhwb3J0cy56aXBNYXAgPSB6aXBNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/lodash.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/utils/lodash.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArguments = exports.defaults = exports.noop = void 0;\nconst defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/lodash.defaults/index.js\");\nexports.defaults = defaults;\nconst isArguments = __webpack_require__(/*! lodash.isarguments */ \"(rsc)/./node_modules/lodash.isarguments/index.js\");\nexports.isArguments = isArguments;\nfunction noop() { }\nexports.noop = noop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9sb2Rhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWTtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsZ0JBQWdCO0FBQ2hCLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFvQjtBQUNoRCxtQkFBbUI7QUFDbkI7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvbG9kYXNoLmpzP2ZhNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQXJndW1lbnRzID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMubm9vcCA9IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZShcImxvZGFzaC5kZWZhdWx0c1wiKTtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmNvbnN0IGlzQXJndW1lbnRzID0gcmVxdWlyZShcImxvZGFzaC5pc2FyZ3VtZW50c1wiKTtcbmV4cG9ydHMuaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/lodash.js\n");

/***/ })

};
;